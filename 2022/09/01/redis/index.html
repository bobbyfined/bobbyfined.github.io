<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis基础 | 停云笺</title><meta name="author" content="当"><meta name="copyright" content="当"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Redis篇">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis基础">
<meta property="og:url" content="http://1008610.xyz/2022/09/01/redis/index.html">
<meta property="og:site_name" content="停云笺">
<meta property="og:description" content="Redis篇">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://1008610.xyz/img/cover.png">
<meta property="article:published_time" content="2022-09-01T12:07:36.000Z">
<meta property="article:modified_time" content="2025-02-18T01:37:29.909Z">
<meta property="article:author" content="当">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://1008610.xyz/img/cover.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Redis基础",
  "url": "http://1008610.xyz/2022/09/01/redis/",
  "image": "http://1008610.xyz/img/cover.png",
  "datePublished": "2022-09-01T12:07:36.000Z",
  "dateModified": "2025-02-18T01:37:29.909Z",
  "author": [
    {
      "@type": "Person",
      "name": "当",
      "url": "http://1008610.xyz/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/title-boke.png"><link rel="canonical" href="http://1008610.xyz/2022/09/01/redis/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis基础',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/modify.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/img/yun.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/cover.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">停云笺</span></a><a class="nav-page-title" href="/"><span class="site-name">Redis基础</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Redis基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-01T12:07:36.000Z" title="发表于 2022-09-01 20:07:36">2022-09-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-18T01:37:29.909Z" title="更新于 2025-02-18 09:37:29">2025-02-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Redis/">Redis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Redis篇"><a href="#Redis篇" class="headerlink" title="Redis篇"></a><strong>Redis篇</strong></h1><span id="more"></span>

<h2 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h2><p>Redis是一款内存高速缓存数据库。Redis全称为：<strong>Remote Dictionary Server</strong>（远程数据服务），使用C语言编写，Redis是一个key-value存储系统（键值存储系统），支持丰富的数据类型，如：String、list、set、zset、hash。</p>
<p>Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。</p>
<h2 id="WhyRedis"><a href="#WhyRedis" class="headerlink" title="WhyRedis"></a>WhyRedis</h2><blockquote>
<p>一个产品的使用场景肯定是需要根据产品的特性，先列举一下Redis的特点：</p>
</blockquote>
<ul>
<li>读写性能优异<ul>
<li>Redis能读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s （测试条件见下一节）。</li>
</ul>
</li>
<li>数据类型丰富<ul>
<li>Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li>
</ul>
</li>
<li>原子性<ul>
<li>Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</li>
</ul>
</li>
<li>丰富的特性<ul>
<li>Redis支持 publish&#x2F;subscribe, 通知, key 过期等特性。</li>
</ul>
</li>
<li>持久化<ul>
<li>Redis支持RDB, AOF等持久化方式</li>
</ul>
</li>
<li>发布订阅<ul>
<li>Redis支持发布&#x2F;订阅模式</li>
</ul>
</li>
<li>分布式<ul>
<li>Redis Cluste</li>
</ul>
</li>
</ul>
<p> 总结：速度快，完全基于内存，使用C语言实现，网络层使用epoll解决高并发问题，单线程模型避免了不必要的上下文切换及竞争条件；</p>
<p>其他类型产品：</p>
<table>
<thead>
<tr>
<th></th>
<th>GuavaCache</th>
<th>Tair</th>
<th>EVCache</th>
<th>Aerospike</th>
</tr>
</thead>
<tbody><tr>
<td>类别</td>
<td>本地JVM缓存</td>
<td>分布式缓存</td>
<td>分布式缓存</td>
<td>分布式nosql数据库</td>
</tr>
<tr>
<td>应用</td>
<td>本地缓存</td>
<td>淘宝</td>
<td>Netflix、AWS</td>
<td>广告</td>
</tr>
<tr>
<td>性能</td>
<td>非常高</td>
<td>较高</td>
<td>很高</td>
<td>较高</td>
</tr>
<tr>
<td>持久化</td>
<td>无</td>
<td>有</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>集群</td>
<td>无</td>
<td>灵活配置</td>
<td>有</td>
<td>自动扩容</td>
</tr>
</tbody></table>
<p> 与传统数据库不同的是 Redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。另外，Redis 也经常用来做分布式锁。除此之外，Redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。</p>
<p>不同产品的介绍：</p>
<h4 id="1、redis"><a href="#1、redis" class="headerlink" title="1、redis"></a>1、redis</h4><p> 1）完全基于内存，绝大部分请求是纯粹的内存操作。数据存在内存中，类似于 HashMap，查找和操作的时间复杂度都是O(1)；</p>
<p> 2）数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；</p>
<p> 3）采用<strong>单线程</strong>，避免了多线程不必要的上下文切换和竞争条件，不存在加锁释放锁操作，减少了因为锁竞争导致的性能消耗；（6.0以后多线程）</p>
<p> 4）使用EPOLL多路 I&#x2F;O 复用模型，非阻塞 IO；</p>
<p> 5）使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p>
<h4 id="Redis的使用场景"><a href="#Redis的使用场景" class="headerlink" title="Redis的使用场景"></a>Redis的使用场景</h4><blockquote>
<p>redis应用场景总结redis平时我们用到的地方蛮多的，下面就了解的应用场景做个总结：</p>
</blockquote>
<h5 id="热点数据的缓存"><a href="#热点数据的缓存" class="headerlink" title="# 热点数据的缓存"></a><a href="#%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BC%93%E5%AD%98">#</a> 热点数据的缓存</h5><p>缓存是Redis最常见的应用场景，之所有这么使用，主要是因为Redis读写性能优异。而且逐渐有取代memcached，成为首选服务端缓存的组件。而且，Redis内部是支持事务的，在使用时候能有效保证数据的一致性。</p>
<p>作为缓存使用时，一般有两种方式保存数据：</p>
<ul>
<li>读取前，先去读Redis，如果没有数据，读取数据库，将数据拉入Redis。</li>
<li>插入数据时，同时写入Redis。</li>
</ul>
<p>方案一：实施起来简单，但是有两个需要注意的地方：</p>
<ul>
<li>避免缓存击穿。（数据库没有就需要命中的数据，导致Redis一直没有数据，而一直命中数据库。）</li>
<li>数据的实时性相对会差一点。</li>
</ul>
<p>方案二：数据实时性强，但是开发时不便于统一处理。</p>
<p>当然，两种方式根据实际情况来适用。如：方案一适用于对于数据实时性要求不是特别高的场景。方案二适用于字典表、数据量不大的数据存储。</p>
<h5 id="限时业务的运用"><a href="#限时业务的运用" class="headerlink" title="# 限时业务的运用"></a><a href="#%E9%99%90%E6%97%B6%E4%B8%9A%E5%8A%A1%E7%9A%84%E8%BF%90%E7%94%A8">#</a> 限时业务的运用</h5><p>redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。</p>
<h5 id="计数器相关问题"><a href="#计数器相关问题" class="headerlink" title="# 计数器相关问题"></a><a href="#%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98">#</a> 计数器相关问题</h5><p>redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。</p>
<h5 id="分布式锁"><a href="#分布式锁" class="headerlink" title="# 分布式锁"></a><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">#</a> 分布式锁</h5><p>这个主要利用redis的setnx命令进行，setnx：”set if not exists”就是如果不存在则成功设置缓存同时返回1，否则返回0 ，这个特性在很多后台中都有所运用，因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先 通过setnx设置一个lock， 如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。</p>
<p>在分布式锁的场景中，主要用在比如秒杀系统等。</p>
<h5 id="延时操作"><a href="#延时操作" class="headerlink" title="# 延时操作"></a><a href="#%E5%BB%B6%E6%97%B6%E6%93%8D%E4%BD%9C">#</a> 延时操作</h5><p>比如在订单生产后我们占用了库存，10分钟后去检验用户是否真正购买，如果没有购买将该单据设置无效，同时还原库存。 由于redis自2.8.0之后版本提供Keyspace Notifications功能，允许客户订阅Pub&#x2F;Sub频道，以便以某种方式接收影响Redis数据集的事件。 所以我们对于上面的需求就可以用以下解决方案，我们在订单生产时，设置一个key，同时设置10分钟后过期， 我们在后台实现一个监听器，监听key的实效，监听到key失效时将后续逻辑加上。</p>
<p>当然我们也可以利用rabbitmq、activemq等消息中间件的延迟队列服务实现该需求。</p>
<h5 id="排行榜相关问题"><a href="#排行榜相关问题" class="headerlink" title="# 排行榜相关问题"></a><a href="#%E6%8E%92%E8%A1%8C%E6%A6%9C%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98">#</a> 排行榜相关问题</h5><p>关系型数据库在排行榜方面查询速度普遍偏慢，所以可以借助redis的SortedSet进行热点数据的排序。</p>
<p>比如点赞排行榜，做一个SortedSet, 然后以用户的openid作为上面的username, 以用户的点赞数作为上面的score, 然后针对每个用户做一个hash, 通过zrangebyscore就可以按照点赞数获取排行榜，然后再根据username获取用户的hash信息，这个当时在实际运用中性能体验也蛮不错的。</p>
<h5 id="点赞、好友等相互关系的存储"><a href="#点赞、好友等相互关系的存储" class="headerlink" title="# 点赞、好友等相互关系的存储"></a><a href="#%E7%82%B9%E8%B5%9E%E3%80%81%E5%A5%BD%E5%8F%8B%E7%AD%89%E7%9B%B8%E4%BA%92%E5%85%B3%E7%B3%BB%E7%9A%84%E5%AD%98%E5%82%A8">#</a> 点赞、好友等相互关系的存储</h5><p>Redis 利用集合的一些命令，比如求交集、并集、差集等。</p>
<p>在微博应用中，每个用户关注的人存在一个集合中，就很容易实现求两个人的共同好友功能。</p>
<h5 id="简单队列"><a href="#简单队列" class="headerlink" title="# 简单队列"></a><a href="#%E7%AE%80%E5%8D%95%E9%98%9F%E5%88%97">#</a> 简单队列</h5><p>由于Redis有list push和list pop这样的命令，所以能够很方便的执行队列操作。</p>
<h4 id="2、Memcache"><a href="#2、Memcache" class="headerlink" title="2、Memcache"></a>2、Memcache</h4><table>
<thead>
<tr>
<th>redis</th>
<th>Memcached</th>
</tr>
</thead>
<tbody><tr>
<td>内存高速数据库</td>
<td>高性能分布式内存缓存数据库</td>
</tr>
<tr>
<td>支持hash、list、set、zset、string结构</td>
<td>只支持key-value结构</td>
</tr>
<tr>
<td>将大部分数据放到内存</td>
<td>全部数据放到内存中</td>
</tr>
<tr>
<td>支持持久化、主从复制备份</td>
<td>不支持数据持久化及数据备份</td>
</tr>
<tr>
<td>数据丢失可通过AOF恢复</td>
<td>挂掉后，数据不可恢复</td>
</tr>
<tr>
<td>单线程（2~4万TPS）</td>
<td>多线程（20-40万TPS）</td>
</tr>
</tbody></table>
<h5 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a><strong>使用场景：</strong></h5><p> 1、如果有持久方面的需求或对数据类型和处理有要求的应该选择redis。</p>
<p> 2、如果简单的key&#x2F;value 存储应该选择memcached。</p>
<h4 id="3、Tair"><a href="#3、Tair" class="headerlink" title="3、Tair"></a>3、Tair</h4><p> Tair(Taobao Pair)是淘宝开发的分布式Key-Value存储引擎，既可以做缓存也可以做数据源（三种引擎切换）</p>
<ul>
<li>MDB（Memcache）属于内存型产品,支持kv和类hashMap结构,性能最优</li>
<li>RDB（Redis）支持List.Set.Zset等复杂的数据结构,性能次之,可提供缓存和持久化存储两种模式</li>
<li>LDB（levelDB）属于持久化产品,支持kv和类hashmap结构,性能较前两者稍低,但持久化可靠性最高</li>
</ul>
<p><strong>分布式缓存</strong></p>
<p>大访问少量临时数据的存储（kb左右）</p>
<p>用于缓存，降低对后端数据库的访问压力</p>
<p>session场景</p>
<p>高速访问某些数据结构的应用和计算（rdb）</p>
<p><strong>数据源存储</strong></p>
<p>快速读取数据（fdb）</p>
<p>持续大数据量的存入读取（ldb），交易快照</p>
<p>高频度的更新读取（ldb），库存</p>
<p><strong>痛点</strong>：redis集群中，想借用缓存资源必须得指明redis服务器地址去要。这就增加了程序的维护复杂度。因为redis服务器很可能是需要频繁变动的。所以人家淘宝就想啊，为什么不能像操作分布式数据库或者hadoop那样。增加一个中央节点，让他去代理所有事情。在tair中程序只要跟tair中心节点交互就OK了。同时tair里还有配置服务器概念。又免去了像操作hadoop那样，还得每台hadoop一套一模一样配置文件。改配置文件得整个集群都跟着改。</p>
<h4 id="4、Guava"><a href="#4、Guava" class="headerlink" title="4、Guava"></a>4、Guava</h4><p> 分布式缓存一致性更好一点，用于集群环境下多节点使用同一份缓存的情况；有网络IO，吞吐率与缓存的数据大小有较大关系；</p>
<p> 本地缓存非常高效，本地缓存会占用堆内存，影响垃圾回收、影响系统性能。</p>
<p><strong>本地缓存设计：</strong></p>
<p> 以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况，每个实例都需要各自保存一份缓存，缓存不具有一致性。</p>
<p><strong>解决缓存过期：</strong></p>
<p> 1、将缓存过期时间调为永久</p>
<p> 2、将缓存失效时间分散开，不要将缓存时间长度都设置成一样；比如我们可以在原有的失效时间基础上增加一个随机值，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p>
<p><strong>解决内存溢出：</strong></p>
<p> <strong>第一步</strong>，修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)</p>
<p>　<strong>第二步</strong>，检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。</p>
<p>　<strong>第三步</strong>，对代码进行走查和分析，找出可能发生内存溢出的位置。</p>
<p><strong>Google Guava Cache</strong></p>
<p><strong>自己设计本地缓存痛点：</strong></p>
<ul>
<li>不能按照一定的规则淘汰数据，如 LRU，LFU，FIFO 等。</li>
<li>清除数据时的回调通知</li>
<li>并发处理能力差，针对并发可以使用CurrentHashMap，但缓存的其他功能需要自行实现</li>
<li>缓存过期处理，缓存数据加载刷新等都需要手工实现</li>
</ul>
<p><strong>Guava Cache 的场景：</strong></p>
<ul>
<li>对性能有非常高的要求</li>
<li>不经常变化，占用内存不大</li>
<li>有访问整个集合的需求</li>
<li>数据允许不实时一致</li>
</ul>
<p><strong>Guava Cache 的优势</strong>：</p>
<ul>
<li>缓存过期和淘汰机制</li>
</ul>
<p>在GuavaCache中可以设置Key的过期时间，包括访问过期和创建过期。GuavaCache在缓存容量达到指定大小时，采用LRU的方式，将不常使用的键值从Cache中删除</p>
<ul>
<li>并发处理能力</li>
</ul>
<p>GuavaCache类似CurrentHashMap，是线程安全的。提供了设置并发级别的api，使得缓存支持并发的写入和读取，采用分离锁机制，分离锁能够减小锁力度，提升并发能力，分离锁是分拆锁定，把一个集合看分成若干partition, 每个partiton一把锁。更新锁定</p>
<ul>
<li>防止缓存击穿</li>
</ul>
<p>一般情况下，在缓存中查询某个key，如果不存在，则查源数据，并回填缓存。（Cache Aside Pattern）在高并发下会出现，多次查源并重复回填缓存，可能会造成源的宕机（DB），性能下降 GuavaCache可以在CacheLoader的load方法中加以控制，对同一个key，只让一个请求去读源并回填缓存，其他请求阻塞等待。（相当于集成数据源，方便用户使用）</p>
<ul>
<li>监控缓存加载&#x2F;命中情况</li>
</ul>
<p>统计</p>
<p><strong>问题：</strong></p>
<p> OOM-&gt;设置过期时间、使用弱引用、配置过期策略</p>
<h4 id="5、EVCache"><a href="#5、EVCache" class="headerlink" title="5、EVCache"></a>5、EVCache</h4><p>EVCache是一个Netflflix（网飞）公司开源、快速的分布式缓存，是基于Memcached的内存存储实现的，用以构建超大容量、高性能、低延时、跨区域的全球可用的缓存数据层。</p>
<p>E：Ephemeral：数据存储是短暂的，有自身的存活时间</p>
<p>V：Volatile：数据可以在任何时候消失</p>
<p>EVCache典型地适合对强一致性没有必须要求的场合</p>
<p>典型用例：Netflflix向用户推荐用户感兴趣的电影</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/0c8bd20c483867b2013cffe847fa944fd85ffe5c3191156b9c52fd0129773fe6/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676d6170646e683079616a33306b75306169676d632e6a7067"><img src="https://camo.githubusercontent.com/0c8bd20c483867b2013cffe847fa944fd85ffe5c3191156b9c52fd0129773fe6/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676d6170646e683079616a33306b75306169676d632e6a7067" alt="image-20210103185340548"></a></p>
<p><strong>EVCache集群</strong>在峰值每秒可以处理<strong>200kb</strong>的请求，</p>
<p>Netflflix生产系统中部署的EVCache经常要处理超过<strong>每秒3000万个</strong>请求，存储数十亿个对象，</p>
<p>跨数千台memcached服务器。整个EVCache集群<strong>每天处理近2万亿个</strong>请求。</p>
<p>EVCache集群响应平均延时大约是1-5毫秒，最多不会超过20毫秒。</p>
<p>EVCache集群的缓存命中率在99%左右。</p>
<p><strong>典型部署</strong></p>
<p>EVCache 是线性扩展的，可以在一分钟之内完成扩容，在几分钟之内完成负载均衡和缓存预热。</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/33102298c3f3d5abe4f00c8e7f176d490a90620fea4a51a9058ee62fe3a47d8b/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676d617067393971386c6a333069783066336a72772e6a7067"><img src="https://camo.githubusercontent.com/33102298c3f3d5abe4f00c8e7f176d490a90620fea4a51a9058ee62fe3a47d8b/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676d617067393971386c6a333069783066336a72772e6a7067" alt="image-20210103185611516"></a></p>
<p>1、集群启动时，EVCache向服务注册中心（Zookeeper、Eureka）注册各个实例</p>
<p>2、在web应用启动时，查询命名服务中的EVCache服务器列表，并建立连接。</p>
<p>3、客户端通过key使用一致性hash算法，将数据分片到集群上。</p>
<h4 id="6、ETCD"><a href="#6、ETCD" class="headerlink" title="6、ETCD"></a>6、ETCD</h4><p> <strong>和Zookeeper一样，CP模型追求数据一致性，越来越多的系统开始用它保存关键数据。比如，秒杀系统经常用它保存各节点信</strong>息，以便控制消费 MQ 的服务数量。还有些业务系统的<strong>配置数据</strong>，也会通过 etcd 实时同步给业务系统的各节点，比如，秒杀管理后台会使用 etcd 将秒杀活动的<strong>配置数据实时同步给秒杀 API 服务各节点</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/b4c59c1cbe5f5ae99de66c57b6f60219e98726f7fc941f47271cb0356f2a0a37/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f3030386933736b4e6c7931677832746739717330306a333074613067343076632e6a7067"><img src="https://camo.githubusercontent.com/b4c59c1cbe5f5ae99de66c57b6f60219e98726f7fc941f47271cb0356f2a0a37/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f3030386933736b4e6c7931677832746739717330306a333074613067343076632e6a7067" alt="image-20210418174251742"></a></p>
<h3 id="Redis底层"><a href="#Redis底层" class="headerlink" title="Redis底层"></a>Redis底层</h3><p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20240702224859420.png" alt="image-20240702224859420"></p>
<h4 id="1、redis数据类型"><a href="#1、redis数据类型" class="headerlink" title="1、redis数据类型"></a>1、redis数据类型</h4><p>五种基本数据类型</p>
<p><a target="_blank" rel="noopener" href="https://pdai.tech/md/db/nosql-redis/db-redis-data-types.html">https://pdai.tech/md/db/nosql-redis/db-redis-data-types.html</a></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>底层</th>
<th>应用场景</th>
<th>编码类型</th>
</tr>
</thead>
<tbody><tr>
<td>String</td>
<td>SDS数组</td>
<td>帖子、评论、热点数据、输入缓冲</td>
<td>RAW &lt;&lt; EMBSTR &lt;&lt; INT</td>
</tr>
<tr>
<td>List</td>
<td>QuickList</td>
<td>评论列表、商品列表、发布与订阅、慢查询、监视器</td>
<td>LINKEDLIST &lt;&lt; ZIPLIST</td>
</tr>
<tr>
<td>Set</td>
<td>intSet</td>
<td>适合交集、并集、查集操作，例如朋友关系</td>
<td>HT &lt;&lt; INSET</td>
</tr>
<tr>
<td>Zset</td>
<td>跳跃表</td>
<td>去重后排序，适合排名场景</td>
<td>SKIPLIST &lt;&lt; ZIPLIST</td>
</tr>
<tr>
<td>Hash</td>
<td>哈希</td>
<td>结构化数据，比如存储对象</td>
<td>HT &lt;&lt; ZIPLIST</td>
</tr>
<tr>
<td>Stream</td>
<td>紧凑列表</td>
<td>消息队列</td>
<td></td>
</tr>
</tbody></table>
<h4 id="2、相关API"><a href="#2、相关API" class="headerlink" title="2、相关API"></a><strong>2、相关API</strong></h4><blockquote>
<p><a target="_blank" rel="noopener" href="http://redisdoc.com/">http://redisdoc.com</a></p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>String</td>
<td>SET</td>
<td>SETNX</td>
<td>SETEX</td>
<td>GET</td>
<td>GETSET</td>
<td>INCR</td>
<td>DECR</td>
<td>MSET</td>
<td>MGET</td>
</tr>
<tr>
<td>Hash</td>
<td>HSET</td>
<td>HSETNX</td>
<td>HGET</td>
<td>HDEL</td>
<td>HLEN</td>
<td>HMSET</td>
<td>HMGET</td>
<td>HKEYS</td>
<td>HGETALL</td>
</tr>
<tr>
<td>LIST</td>
<td>LPUSH</td>
<td>LPOP</td>
<td>RPUSH</td>
<td>RPOP</td>
<td>LINDEX</td>
<td>LREM</td>
<td>LRANGE</td>
<td>LLEN</td>
<td>RPOPLPUSH</td>
</tr>
<tr>
<td>ZSET</td>
<td>ZADD</td>
<td>ZREM</td>
<td>ZSCORE</td>
<td>ZCARD</td>
<td>ZRANGE</td>
<td>ZRANK</td>
<td>ZREVRANK</td>
<td></td>
<td>ZREVRANGE</td>
</tr>
<tr>
<td>SET</td>
<td>SADD</td>
<td>SREM</td>
<td>SISMEMBER</td>
<td>SCARD</td>
<td>SINTER</td>
<td>SUNION</td>
<td>SDIFF</td>
<td>SPOP</td>
<td>SMEMBERS</td>
</tr>
<tr>
<td>事务</td>
<td>MULTI</td>
<td>EXEC</td>
<td>DISCARD</td>
<td>WATCH</td>
<td>UNWATCH</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="3、redis各个类型的底层结构"><a href="#3、redis各个类型的底层结构" class="headerlink" title="3、redis各个类型的底层结构"></a>3、redis各个类型的底层结构</h4><p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20240703203721396.png" alt="image-20240703203721396"></p>
<h5 id="1-String（字符串）"><a href="#1-String（字符串）" class="headerlink" title="1. String（字符串）"></a>1. String（字符串）</h5><ul>
<li>简单动态字符串（SDS）<ul>
<li>当字符串比较短时，Redis 使用 SDS 结构来存储。SDS 是 Redis 自定义的一种字符串类型，支持高效的字符串操作。</li>
<li>SDS 结构包含了实际的字符串数据、已用空间长度、总空间长度，以及额外的未使用空间，用于减少内存分配次数和频繁的内存复制。</li>
</ul>
</li>
<li>整数编码（int）<ul>
<li>当字符串表示的是一个整数，并且在特定范围内时，Redis 会使用整数编码来存储该字符串，以节省内存。</li>
</ul>
</li>
</ul>
<h5 id="2-List（列表）"><a href="#2-List（列表）" class="headerlink" title="2. List（列表）"></a>2. List（列表）</h5><ul>
<li><strong>压缩列表（Ziplist）</strong>：<ul>
<li>当列表元素数量较少且每个元素的长度都较小时，Redis 使用压缩列表。压缩列表是一种连续内存块，紧凑地存储多个元素，节省内存空间。</li>
</ul>
</li>
<li><strong>双向链表（Linked List）</strong>：<ul>
<li>当列表元素数量较多或者元素较大时，Redis 使用双向链表。这种结构支持高效的插入和删除操作，但占用的内存较多。</li>
</ul>
</li>
<li><strong>快速列表（Quicklist）</strong>：<ul>
<li>Redis 4.0 引入了一种混合数据结构，结合了压缩列表和双向链表的优点。Quicklist 是由多个小的压缩列表组成的双向链表，既节省内存又保持了操作的高效性。</li>
</ul>
</li>
</ul>
<h5 id="3-Hash（哈希表）"><a href="#3-Hash（哈希表）" class="headerlink" title="3. Hash（哈希表）"></a>3. Hash（哈希表）</h5><ul>
<li><strong>压缩列表（Ziplist）</strong>：<ul>
<li>当哈希表中的键值对数量较少，且每个键和值都较短时，使用压缩列表来存储。</li>
</ul>
</li>
<li><strong>哈希表（Hashtable）</strong>：<ul>
<li>当哈希表中的键值对数量较多或者某些键和值较长时，使用哈希表结构。哈希表使用链地址法解决冲突，提供 O(1) 时间复杂度的查找、插入和删除操作。</li>
</ul>
</li>
</ul>
<h5 id="4-Set（集合）"><a href="#4-Set（集合）" class="headerlink" title="4. Set（集合）"></a>4. Set（集合）</h5><ul>
<li><strong>整数集合（Intset）</strong>：<ul>
<li>当集合中的元素都是整数且数量较少时，Redis 使用整数集合存储。整数集合是一种有序且不重复的整数数组。</li>
</ul>
</li>
<li><strong>哈希表（Hashtable）</strong>：<ul>
<li>当集合中的元素较多或者包含非整数元素时，使用哈希表结构存储。哈希表提供 O(1) 时间复杂度的查找、插入和删除操作。</li>
</ul>
</li>
</ul>
<h5 id="5-Sorted-Set（有序集合）"><a href="#5-Sorted-Set（有序集合）" class="headerlink" title="5. Sorted Set（有序集合）"></a>5. Sorted Set（有序集合）</h5><ul>
<li><strong>压缩列表（Ziplist）</strong>：<ul>
<li>当有序集合中的元素数量较少，并且每个元素的长度较短时，使用压缩列表存储。</li>
</ul>
</li>
<li><strong>跳跃表和哈希表（Skip List and Hashtable）</strong>：<ul>
<li>当有序集合中的元素较多或者元素较大时，使用跳跃表和哈希表相结合的方式存储。跳跃表用于维持元素的有序性，提供范围查询功能；哈希表用于快速查找元素分值（score），提高操作效率。</li>
</ul>
</li>
</ul>
<h5 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h5><p><strong>Redis Stream</strong>的底层主要使用了listpack(紧凑列表)和Rax树(基数树)。</p>
<p> <strong>listpack</strong>表示一个字符串列表的序列化，listpack可用于存储字符串或整数。用于存储stream的消息内 容。</p>
<p> <strong>Rax树</strong>是一个有序字典树 (基数树 Radix Tree)，按照 key 的字典序排列，支持快速地定位、插入和删除操 作。</p>
<h4 id="4、Zset底层实现"><a href="#4、Zset底层实现" class="headerlink" title="4、Zset底层实现"></a>4、Zset底层实现</h4><p> 跳表(skip List)是一种随机化的数据结构，基于并联的链表，实现简单，插入、删除、查找的复杂度均为O(logN)。简单说来跳表也是链表的一种，只不过它在链表的基础上增加了跳跃功能，正是这个跳跃的功能，使得在查找元素时，跳表能够提供O(logN)的时间复杂度</p>
<p> Zset<strong>数据量少的时候使用压缩链表ziplist</strong>实现，有序集合使用紧挨在一起的压缩列表节点来保存，第一个节点保存member，第二个保存score。ziplist内的集合元素按score从小到大排序，score较小的排在表头位置。 <strong>数据量大的时候使用跳跃列表skiplist和哈希表hash_map</strong>结合实现，查找删除插入的时间复杂度都是O(longN)</p>
<p> Redis使用跳表而不使用红黑树，是因为跳表的索引结构序列化和反序列化更加快速，方便持久化。</p>
<p><strong>搜索</strong></p>
<p> 跳跃表按 score 从小到大保存所有集合元素，查找时间复杂度为平均 <em>O(logN)，最坏 O(N) 。</em></p>
<p><strong>插入</strong></p>
<p>  选用链表作为底层结构支持，为了高效地动态增删。因为跳表底层的单链表是有序的，为了维护这种有序性，在插入前需要遍历链表，找到该插入的位置，单链表遍历查找的时间复杂度是O(n)，同理可得，跳表的遍历也是需要遍历索引数，所以是O(logn)。</p>
<p><strong>删除</strong></p>
<p>  如果该节点还在索引中，删除时不仅要删除单链表中的节点，还要删除索引中的节点；单链表在知道删除的节点是谁时，时间复杂度为O(1)，但针对单链表来说，删除时都需要拿到前驱节点O(logN)才可改变引用关系从而删除目标节点。</p>
<h3 id="Redis可用性"><a href="#Redis可用性" class="headerlink" title="Redis可用性"></a><strong>Redis可用性</strong></h3><h4 id="1、redis持久化"><a href="#1、redis持久化" class="headerlink" title="1、redis持久化"></a>1、redis持久化</h4><p>持久化就是把内存中的数据持久化到本地磁盘，防止服务器宕机了内存数据丢失</p>
<p>Redis 提供两种持久化机制 <strong>RDB（默认）</strong> 和 <strong>AOF 机制</strong>，Redis4.0以后采用混合持久化，用 AOF 来<strong>保证数据不丢失</strong>，作为数据恢复的第一选择; 用 RDB 来做不同程度的<strong>冷备</strong></p>
<p>**RDB：**是Redis DataBase缩写快照</p>
<p> RDB是Redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。</p>
<p> <strong>优点：</strong></p>
<p> 1）只有一个文件 dump.rdb，方便持久化；</p>
<p> 2）容灾性好，一个文件可以保存到安全的磁盘。</p>
<p> 3）性能最大化，fork 子进程来进行持久化写操作，让主进程继续处理命令，只存在毫秒级不响应请求。</p>
<p> 4）相对于数据集大时，比 AOF 的启动效率更高。</p>
<p> <strong>缺点：</strong></p>
<p> 数据安全性低，RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。</p>
<p><strong>AOF：持久化</strong></p>
<p> AOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。</p>
<p> <strong>优点：</strong></p>
<p> 1）数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。</p>
<p> 2）通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</p>
<p><strong>缺点：</strong></p>
<p> 1）AOF 文件比 RDB 文件大，且恢复速度慢。</p>
<p> 2）数据集大的时候，比 rdb 启动效率低。</p>
<h4 id="2、redis事务"><a href="#2、redis事务" class="headerlink" title="2、redis事务"></a>2、redis事务</h4><p> 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p>
<p><strong>Redis事务的概念</strong></p>
<p> Redis 事务的本质是通过MULTI、EXEC、WATCH等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p>
<p>Redis的事务总是具有ACID中的<strong>一致性和隔离性</strong>，其他特性是不支持的。当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性。</p>
<p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的</p>
<p><strong>事务命令：</strong></p>
<p>**MULTI：**用于开启一个事务，它总是返回OK。MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。</p>
<p>**EXEC：**执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值 nil 。</p>
<p>**WATCH ：**是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。（<strong>秒杀场景</strong>）</p>
<p>**DISCARD：**调用该命令，客户端可以清空事务队列，并放弃执行事务，且客户端会从事务状态中退出。</p>
<p><strong>UNWATCH</strong>：命令可以取消watch对所有key的监控。</p>
<p><strong>问题：</strong></p>
<p><strong>redis是单线程的，本身不就是有事务吗，为什么还需要借助这些原语呢</strong>？</p>
<p>​	Redis 确实是单线程的，这意味着<strong>每个</strong>命令都是原子性的（atomic）。但是，Redis 的事务机制 (<code>MULTI</code> 和 <code>EXEC</code>) 提供了对<strong>一组</strong>命令进行原子操作的能力，使得它们在执行时不会被其他命令插入和打断。</p>
<h4 id="3、redis失效策略"><a href="#3、redis失效策略" class="headerlink" title="3、redis失效策略"></a>3、redis失效策略</h4><p><strong>内存淘汰策略</strong></p>
<p>1）全局的键空间选择性移除</p>
<p> <strong>noeviction</strong>：当内存不足以容纳新写入数据时，新写入操作会报错。（字典库常用）默认·</p>
<p> <strong>allkeys-lru</strong>：在键空间中，移除最近最少使用的key。（缓存常用）</p>
<p> <strong>allkeys-random</strong>：在键空间中，随机移除某个key。</p>
<p>2）设置过期时间的键空间选择性移除</p>
<p> <strong>volatile-lru</strong>：在设置了过期时间的键空间中，移除最近最少使用的key。</p>
<p> <strong>volatile-random</strong>：在设置了过期时间的键空间中，随机移除某个key。 </p>
<p> <strong>volatile-ttl</strong>：在设置了过期时间的键空间中，有更早过期时间的key优先移除。</p>
<p><strong>缓存失效策略</strong></p>
<p> **定时清除：**针对每个设置过期时间的key都创建指定定时器</p>
<p> **惰性清除：**访问时判断，对内存不友好</p>
<p> **定时扫描清除：**定时100ms随机20个检查过期的字典，若存在25%以上则继续循环删除。</p>
<h4 id="4、redis读写模式"><a href="#4、redis读写模式" class="headerlink" title="4、redis读写模式"></a>4、redis读写模式</h4><p> <strong>CacheAside旁路缓存</strong></p>
<p>写请求更新数据库后删除缓存数据。读请求不命中查询数据库，查询完成写入缓存</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/4f6ecd7d5622bcefd365e4401ecd0dea2118de6fc9cc095863b0dd66c7619532/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303830363139343331363533392e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c3278366546393261574e3062334a352c73697a655f31362c636f6c6f725f4646464646462c745f3730"><img src="https://camo.githubusercontent.com/4f6ecd7d5622bcefd365e4401ecd0dea2118de6fc9cc095863b0dd66c7619532/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303830363139343331363533392e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c3278366546393261574e3062334a352c73697a655f31362c636f6c6f725f4646464646462c745f3730" alt="在这里插入图片描述"></a></p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/49b8ac7e090eeca2a3f08c792e57e06bbf8be6d68d52cfdddc1a751fec288956/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303830363139343330303832362e706e67"><img src="https://camo.githubusercontent.com/49b8ac7e090eeca2a3f08c792e57e06bbf8be6d68d52cfdddc1a751fec288956/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303830363139343330303832362e706e67" alt="img"></a></p>
<p> 业务端处理所有数据访问细节，同时利用 <strong>Lazy 计算</strong>的思想，更新 DB 后，直接删除 cache 并通过 DB 更新，确保数据以 DB 结果为准，则可以大幅降低 cache 和 DB 中数据不一致的概率</p>
<p> 如果没有专门的存储服务，同时是对<strong>数据一致性要求比较高的业务，或者是缓存数据更新比较复杂的业务</strong>，适合使用 Cache Aside 模式。如微博发展初期，不少业务采用这种模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 延迟双删，用以保证最终一致性,防止小概率旧数据读请求在第一次删除后更新数据库</span><br><span class="line">public void write(String key,Object data)&#123;</span><br><span class="line">	redis.delKey(key);</span><br><span class="line">	db.updateData(data);</span><br><span class="line">	Thread.sleep(1000);</span><br><span class="line">	redis.delKey(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>高并发下保证绝对的一致，先删缓存再更新数据，需要用到<strong>内存队列做异步串行化</strong>。非高并发场景，先更新数据再删除缓存，<strong>延迟双删</strong>策略基本满足了</p>
<ul>
<li>先更新db后删除redis：删除redis失败则出现问题</li>
<li>先删redis后更新db：删除redis瞬间，旧数据被回填redis</li>
<li>先删redis后更新db休眠后删redis：同第二点，休眠后删除redis 可能宕机</li>
<li>java内部jvm队列：不适用分布式场景且降低并发</li>
</ul>
<p> <strong>Read&#x2F;Write Though</strong>（读写穿透）</p>
<p> <strong>先查询</strong>缓存中数据是否存在,如果存在则直接返回,如果<strong>不存在</strong>,则由<strong>缓存组件负责从数据库中同步加载数据.</strong></p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20240704172728882.png" alt="image-20240704172728882"></p>
<p><strong>场景：</strong></p>
<p>微博 Feed 的 Outbox Vector（即用户最新微博列表）就采用这种模式。一些粉丝较少且不活跃的用户发表微博后，Vector 服务会首先查询 Vector Cache，如果 cache 中没有该用户的 Outbox 记录，则不写该用户的 cache 数据，直接更新 DB 后就返回，只有 cache 中存在才会通过 CAS 指令进行更新。</p>
<p><strong>Write Behind Caching（异步缓存写入）</strong></p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/bb84938d32f1558559bd84a76a87191f74665ee11ad6e0f361459c15a155a6d3/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303865476d5a456c7931676f726c7367373469366a333139353065336468732e6a7067"><img src="https://camo.githubusercontent.com/bb84938d32f1558559bd84a76a87191f74665ee11ad6e0f361459c15a155a6d3/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303865476d5a456c7931676f726c7367373469366a333139353065336468732e6a7067" alt="img"></a></p>
<p>比如对一些计数业务，一条 <strong>Feed 被点赞</strong> 1万 次，如果更新 1万 次 DB 代价很大，而合并成一次请求直接加 1万，则是一个非常轻量的操作。但这种模型有个显著的缺点，即数据的一致性变差，甚至在一些极端场景下可能会丢失数据。</p>
<h4 id="5、多级缓存"><a href="#5、多级缓存" class="headerlink" title="5、多级缓存"></a>5、多级缓存</h4><p>**浏览器本地内存缓存：**专题活动，一旦上线，在活动期间是不会随意变更的。</p>
<p>**浏览器本地磁盘缓存：**Logo缓存，大图片懒加载</p>
<p>**服务端本地内存缓存：**由于没有持久化，重启时必定会被穿透</p>
<p><strong>服务端网络内存缓存</strong>：Redis等，针对穿透的情况下可以继续分层，必须保证数据库不被压垮</p>
<p><strong>为什么不是使用服务器本地磁盘做缓存？</strong></p>
<p> 当系统处理大量磁盘 IO 操作的时候，由于 CPU 和内存的速度远高于磁盘，可能导致 CPU 耗费太多时间等待磁盘返回处理的结果。对于这部分 CPU 在 IO 上的开销，我们称为 <strong>iowait</strong></p>
<h3 id="Redis七大经典问题"><a href="#Redis七大经典问题" class="headerlink" title="Redis七大经典问题"></a>Redis七大经典问题</h3><h4 id="1、缓存雪崩"><a href="#1、缓存雪崩" class="headerlink" title="1、缓存雪崩"></a>1、缓存雪崩</h4><p> 指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p> <strong>解决方案：</strong></p>
<ul>
<li><strong>Redis 高可用</strong>，主从+哨兵，Redis cluster，避免全盘崩溃</li>
<li>本地 ehcache 缓存 + hystrix <strong>限流&amp;降级</strong>，避免 MySQL 被打死</li>
<li>缓存数据的<strong>过期时间设置随机</strong>，防止同一时间大量数据过期现象发生。</li>
<li><strong>逻辑上永不过期</strong>给每一个缓存数据增加相应的<strong>缓存标记</strong>，缓存标记失效则更新数据缓存</li>
<li><strong>多级缓存</strong>，失效时通过二级更新一级，由第三方插件更新二级缓存。</li>
</ul>
<h4 id="2、缓存穿透"><a href="#2、缓存穿透" class="headerlink" title="2、缓存穿透"></a><strong>2、缓存穿透</strong></h4><p> <a target="_blank" rel="noopener" href="https://blog.csdn.net/lin777lin/article/details/105666839">https://blog.csdn.net/lin777lin/article/details/105666839</a></p>
<p> 缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p> <strong>解决方案：</strong></p>
<p> 1）<strong>接口层增加校验</strong>，如用户鉴权校验，id做基础校验，id&lt;&#x3D;0的直接拦截；</p>
<p> 2）从缓存取不到的数据，在数据库中也没有取到，这时也可以将<strong>key-value对写为key-null</strong>，缓存有效时间可以设置短点，如30秒。这样可以防止攻击用户反复用同一个id暴力攻击；</p>
<p> 3）采用<strong>布隆过滤器</strong>，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。（宁可错杀一千不可放过一人）</p>
<h4 id="3、缓存击穿"><a href="#3、缓存击穿" class="headerlink" title="3、缓存击穿"></a><strong>3、缓存击穿</strong></h4><p> 这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指<strong>并发查同一条数据</strong>，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库</p>
<p> <strong>解决方案：</strong></p>
<p> 1）设置<strong>热点数据永远不过期</strong>，异步线程处理。</p>
<p> 2）加<strong>写回操作加互斥锁</strong>，查询失败默认值快速返回。</p>
<p> 3）缓存预热</p>
<p> 系统上线后，将相关**可预期（例如排行榜）**热点数据直接加载到缓存。</p>
<p> 写一个缓存刷新页面，手动操作热点数据**（例如广告推广）**上下线。</p>
<h4 id="4、数据不一致"><a href="#4、数据不一致" class="headerlink" title="4、数据不一致"></a>4、数据不一致</h4><p> 在缓存机器的带宽被打满，或者机房网络出现波动时，缓存更新失败，新数据没有写入缓存，就会导致缓存和 DB 的数据不一致。缓存 rehash 时，某个缓存机器反复异常，多次上下线，更新请求多次 rehash。这样，一份数据存在多个节点，且每次 rehash 只更新某个节点，导致一些缓存节点产生脏数据。</p>
<ul>
<li>Cache 更新失败后，可以进行重试，则将重试失败的 key 写入mq，待缓存访问恢复后，将这些 key 从缓存删除。这些 key 在再次被查询时，重新从 DB 加载，从而保证数据的一致性</li>
<li>缓存时间适当调短，让缓存数据及早过期后，然后从 DB 重新加载，确保数据的最终一致性。</li>
<li>不采用 rehash 漂移策略，而采用缓存分层策略，尽量避免脏数据产生。</li>
</ul>
<h4 id="5、数据并发竞争"><a href="#5、数据并发竞争" class="headerlink" title="5、数据并发竞争"></a>5、数据并发竞争</h4><p> 数据并发竞争在大流量系统也比较常见，比如车票系统，如果某个火车车次缓存信息过期，但仍然有大量用户在查询该车次信息。又比如微博系统中，如果某条微博正好被缓存淘汰，但这条微博仍然有大量的转发、评论、赞。上述情况都会造成并发竞争读取的问题。</p>
<ul>
<li>加<strong>写回操作加互斥锁</strong>，查询失败默认值快速返回。</li>
<li>对缓存数据保持多个备份，减少并发竞争的概率</li>
</ul>
<h4 id="6、热点key问题"><a href="#6、热点key问题" class="headerlink" title="6、热点key问题"></a>6、热点key问题</h4><p> 明星结婚、离婚、出轨这种特殊突发事件，比如奥运、春节这些重大活动或节日，还比如秒杀、双12、618 等线上促销活动，都很容易出现 Hot key 的情况。</p>
<p>如何提前发现HotKey？</p>
<ul>
<li>对于重要节假日、线上促销活动这些提前已知的事情，可以提前评估出可能的热 key 来。</li>
<li>而对于突发事件，无法提前评估，可以<strong>通过 Spark，对应流任务进行实时分析</strong>，及时发现新发布的热点 key。而对于之前已发出的事情，逐步发酵成为热 key 的，则可以通过 Hadoop 对批处理任务离线计算，找出最近历史数据中的高频热 key。</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li>这 n 个 key 分散存在多个缓存节点，然后 client 端请求时，随机访问其中某个后缀的 hotkey，这样就可以把热 key 的请求打散，避免一个缓存节点过载</li>
<li>缓存集群可以单节点进行主从复制和垂直扩容</li>
<li>利用应用内的前置缓存，但是需注意需要设置上限</li>
<li>延迟不敏感，定时刷新，实时感知用主动刷新</li>
<li>和缓存穿透一样，限制逃逸流量，单请求进行数据回源并刷新前置</li>
<li>无论如何设计，最后都要写一个兜底逻辑，千万级流量说来就来</li>
</ul>
<h4 id="7、BigKey问题"><a href="#7、BigKey问题" class="headerlink" title="7、BigKey问题"></a>7、BigKey问题</h4><p> 比如互联网系统中需要保存用户最新 1万 个粉丝的业务，比如一个用户个人信息缓存，包括基本资料、关系图谱计数、发 feed 统计等。微博的 feed 内容缓存也很容易出现，一般用户微博在 140 字以内，但很多用户也会发表 1千 字甚至更长的微博内容，这些长微博也就成了大 key</p>
<ul>
<li>首先Redis底层数据结构里，根据Value的不同，会进行数据结构的重新选择</li>
<li>可以扩展新的数据结构，进行序列化构建，然后通过 restore 一次性写入</li>
<li>将大 key 分拆为多个 key，设置较长的过期时间</li>
</ul>
<h3 id="Redis分区容错"><a href="#Redis分区容错" class="headerlink" title="Redis分区容错"></a>Redis分区容错</h3><h4 id="1、redis数据分区"><a href="#1、redis数据分区" class="headerlink" title="1、redis数据分区"></a><strong>1、redis数据分区</strong></h4><p><strong>Hash：（不稳定）</strong></p>
<p> 客户端分片：哈希+取余</p>
<p> 节点伸缩：数据节点关系变化，导致数据迁移</p>
<p> 迁移数量和添加节点数量有关：建议翻倍扩容</p>
<p> 一个简单直观的想法是直接用Hash来计算，以Key做哈希后对节点数取模。可以看出，在key足够分散的情况下，均匀性可以获得，但一旦有节点加入或退出，所有的原有节点都会受到影响，稳定性无从谈起。</p>
<p><strong>一致性Hash：（不均衡）</strong></p>
<p> 客户端分片：哈希+顺时针（优化取余）</p>
<p> 节点伸缩：只影响邻近节点，但是还是有数据迁移</p>
<p> 翻倍伸缩：保证最小迁移数据和负载均衡</p>
<p> 一致性Hash可以很好的解决稳定问题，可以将所有的存储节点排列在收尾相接的Hash环上，每个key在计算Hash后会顺时针找到先遇到的一组存储节点存放。而当有节点加入或退出时，仅影响该节点在Hash环上顺时针相邻的后续节点，将数据从该节点接收或者给予。但这又带来均匀性的问题，即使可以将存储节点等距排列，也会在<strong>存储节点个数变化时带来数据的不均匀</strong>。</p>
<p><strong>Codis的Hash槽</strong></p>
<p> Codis 将所有的 key 默认划分为 1024 个槽位(slot)，它首先对客户端传过来的 key 进行 crc32 运算计算 哈希值，再将 hash 后的整数值对 1024 这个整数进行取模得到一个余数，这个余数就是对应 key 的槽位。</p>
<p><strong>RedisCluster</strong></p>
<p> Redis-cluster把所有的物理节点映射到[0-16383]个<strong>slot</strong>上,对key采用crc16算法得到hash值后对16384取模，基本上采用平均分配和连续分配的方式。</p>
<h4 id="2、主从模式-简单"><a href="#2、主从模式-简单" class="headerlink" title="2、主从模式&#x3D;简单"></a><strong>2、主从模式&#x3D;简单</strong></h4><p> 主从模式最大的优点是<strong>部署简单</strong>，最少<strong>两个节点便可以构成主从模式</strong>，并且可以通过<strong>读写分离避免读和写同时不可用</strong>。不过，一旦 Master 节点出现故障，主从节点就<strong>无法自动切换</strong>，直接导致 SLA 下降。所以，主从模式一般<strong>适合业务发展初期，并发量低，运维成本低</strong>的情况</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/57c39c05c9c63072ca6ee048e33086532da6d55e8e4651193363118a6d0674c5/68747470733a2f2f73302e6c677374617469632e636f6d2f692f696d6167652f4d30302f38302f32352f4369716331465f5167504f41614c38544141433545694e6c766f343739352e706e67"><img src="https://camo.githubusercontent.com/57c39c05c9c63072ca6ee048e33086532da6d55e8e4651193363118a6d0674c5/68747470733a2f2f73302e6c677374617469632e636f6d2f692f696d6167652f4d30302f38302f32352f4369716331465f5167504f41614c38544141433545694e6c766f343739352e706e67" alt="Drawing 1.png"></a></p>
<p><strong>主从复制原理：</strong></p>
<p> ①通过从服务器发送到PSYNC命令给主服务器</p>
<p> ②如果是首次连接，触发一次<strong>全量复制</strong>。此时主节点会启动一个后台线程，生成 RDB 快照文件</p>
<p> ③主节点会将这个 RDB 发送给从节点，slave 会先写入本地磁盘，再从本地磁盘加载到内存中</p>
<p> ④master会将此过程中的写命令写入缓存，从节点<strong>实时同步</strong>这些数据</p>
<p> ⑤如果网络断开了连接，自动重连后主节点通过命令传播<strong>增量复制</strong>给从节点部分缺少的数据</p>
<p><strong>缺点</strong></p>
<p> 所有的slave节点数据的复制和同步都由master节点来处理，会照成master节点压力太大，使用主从从结构来解决，redis4.0中引入psync2 解决了slave重启后仍然可以增量同步。</p>
<h4 id="3、哨兵模式-读多"><a href="#3、哨兵模式-读多" class="headerlink" title="3、哨兵模式&#x3D;读多"></a>3、<strong>哨兵模式</strong>&#x3D;读多</h4><p> 由一个或多个sentinel实例组成sentinel集群可以监视一个或多个主服务器和多个从服务器。<strong>哨兵模式适合读请求远多于写请求的业务场景，比如在秒杀系统</strong>中用来缓存活动信息。 如果写请求较多，当集群 Slave 节点数量多了后，Master 节点同步数据的压力会非常大。</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/14be4fd4607c8bae515a137326103bc995acafafb559a74c85c89389ec2f336e/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676c757136766c76676c6a33306e773065303736662e6a7067"><img src="https://camo.githubusercontent.com/14be4fd4607c8bae515a137326103bc995acafafb559a74c85c89389ec2f336e/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676c757136766c76676c6a33306e773065303736662e6a7067" alt="image-20201220231241725"></a></p>
<p>当主服务器进入下线状态时，sentinel可以将该主服务器下的某一从服务器升级为主服务器继续提供服务，从而保证redis的高可用性。</p>
<p><strong>检测主观下线状态</strong></p>
<p> Sentinel每秒一次向所有与它建立了命令连接的实例(主服务器、从服务器和其他Sentinel)发送PING命 令</p>
<p> 实例在down-after-milliseconds毫秒内返回无效回复Sentinel就会认为该实例主观下线(<strong>SDown</strong>)</p>
<p><strong>检查客观下线状态</strong></p>
<p> 当一个Sentinel将一个主服务器判断为主观下线后 ，Sentinel会向监控这个主服务器的所有其他Sentinel发送查询主机状态的命令</p>
<p> 如果达到Sentinel配置中的quorum数量的Sentinel实例都判断主服务器为主观下线，则该主服务器就会被判定为客观下线(<strong>ODown</strong>)。</p>
<p><strong>选举Leader Sentinel</strong></p>
<p> 当一个主服务器被判定为客观下线后，监视这个主服务器的所有Sentinel会通过选举算法(raft)，选出一个Leader Sentinel去执行**failover(故障转移)**操作。</p>
<p> <strong>Raft算法</strong></p>
<p> Raft协议是用来解决分布式系统一致性问题的协议。 Raft协议描述的节点共有三种状态:Leader, Follower, Candidate。 Raft协议将时间切分为一个个的Term(任期)，可以认为是一种“逻辑时间”。 选举流程: ①Raft采用心跳机制触发Leader选举系统启动后，全部节点初始化为Follower，term为0</p>
<p> ②节点如果收到了RequestVote或者AppendEntries，就会保持自己的Follower身份</p>
<p> ③节点如果一段时间内没收到AppendEntries消息，在该节点的超时时间内还没发现Leader，Follower就会转换成Candidate，自己开始竞选Leader。 一旦转化为Candidate，该节点立即开始下面几件事情: –增加自己的term，启动一个新的定时器 –给自己投一票，向所有其他节点发送RequestVote，并等待其他节点的回复。</p>
<p> ④如果在计时器超时前，节点收到多数节点的同意投票，就转换成Leader。同时通过 AppendEntries，向其他节点发送通知。</p>
<p> ⑤每个节点在一个term内只能投一票，采取先到先得的策略，Candidate投自己， Follower会投给第一个收到RequestVote的节点。</p>
<p> ⑥Raft协议的定时器采取随机超时时间（选举的关键），先转为Candidate的节点会先发起投票，从而获得多数票。</p>
<p><strong>主服务器的选择</strong></p>
<p> 当选举出Leader Sentinel后，Leader Sentinel会根据以下规则去从服务器中选择出新的主服务器。</p>
<ol>
<li>过滤掉主观、客观下线的节点</li>
<li>选择配置slave-priority最高的节点，如果有则返回没有就继续选择</li>
<li>选择出复制偏移量最大的系节点，因为复制偏移量越大则数据复制的越完整</li>
<li>选择run_id最小的节点，因为run_id越小说明重启次数越少</li>
</ol>
<p><strong>故障转移</strong></p>
<p> 当Leader Sentinel完成新的主服务器选择后，Leader Sentinel会对下线的主服务器执行故障转移操作，主要有三个步骤:</p>
<p> 1、它会将失效 Master 的其中一个 Slave 升级为新的 Master , 并让失效 Master 的其他 Slave 改为复制新的 Master ;</p>
<p> 2、当客户端试图连接失效的 Master 时，集群会向客户端返回新 Master 的地址，使得集群当前状态只有一个Master。</p>
<p> 3、Master 和 Slave 服务器切换后， Master 的 redis.conf 、 Slave 的 redis.conf 和 sentinel.conf 的配置文件的内容都会发生相应的改变，即 Master 主服务器的 redis.conf配置文件中会多一行 replicaof 的配置， sentinel.conf 的监控目标会随之调换。</p>
<h4 id="4、集群模式-写多"><a href="#4、集群模式-写多" class="headerlink" title="4、集群模式&#x3D;写多"></a>4、集群模式&#x3D;写多</h4><p> 为了避免单一节点负载过高导致不稳定，集群模式采用<strong>一致性哈希算法或者哈希槽的方法</strong>将 Key 分布到各个节点上。其中，每个 Master 节点后跟若干个 Slave 节点，用于<strong>出现故障时做主备切换</strong>，客户端可以<strong>连接任意 Master 节点</strong>，集群内部会按照<strong>不同 key 将请求转发到不同的 Master</strong> 节点</p>
<p> 集群模式是如何实现高可用的呢？集群内部节点之间会<strong>互相定时探测</strong>对方是否存活，如果多数节点判断某个节点挂了，则会将其踢出集群，然后从 <strong>Slave</strong> 节点中选举出一个节点<strong>替补</strong>挂掉的 Master 节点。<strong>整个原理基本和哨兵模式一致</strong></p>
<p> 虽然集群模式避免了 Master 单节点的问题，但<strong>集群内同步数据时会占用一定的带宽</strong>。所以，只有在<strong>写操作比较多的情况下人们才使用集群模式</strong>，其他大多数情况，使用<strong>哨兵模式</strong>都能满足需求</p>
<h4 id="5、分布式锁"><a href="#5、分布式锁" class="headerlink" title="5、分布式锁"></a>5、分布式锁</h4><p><strong>利用Watch实现Redis乐观锁</strong></p>
<p> 乐观锁基于CAS(Compare And Swap)比较并替换思想，不会产生锁等待而消耗资源，但是需要反复的重试，但也是因为重试的机制，能比较快的响应。因此我们可以利用redis来实现乐观锁**（秒杀）**。具体思路如下:</p>
<p>1、利用redis的watch功能，监控这个redisKey的状态值 2、获取redisKey的值，创建redis事务，给这个key的值+1 3、执行这个事务，如果key的值被修改过则回滚，key不加1</p>
<p><strong>利用setnx防止库存超卖</strong> 分布式锁是控制分布式系统之间同步访问共享资源的一种方式。 利用Redis的单线程特性对共享资源进行串行化处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 获取锁推荐使用set的方式</span><br><span class="line">String result = jedis.set(lockKey, requestId, &quot;NX&quot;, &quot;EX&quot;, expireTime);</span><br><span class="line">String result = jedis.setnx(lockKey, requestId); //如线程死掉，其他线程无法获取到锁</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 释放锁，非原子操作，可能会释放其他线程刚加上的锁</span><br><span class="line">if (requestId.equals(jedis.get(lockKey))) &#123; </span><br><span class="line">  jedis.del(lockKey);</span><br><span class="line">&#125;</span><br><span class="line">// 推荐使用redis+lua脚本</span><br><span class="line">String lua = &quot;if redis.call(&#x27;get&#x27;,KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;,KEYS[1]) else return 0 end&quot;;</span><br><span class="line">Object result = jedis.eval(lua, Collections.singletonList(lockKey),</span><br></pre></td></tr></table></figure>



<p><strong>分布式锁存在的问题</strong>：</p>
<ul>
<li><strong>客户端长时间阻塞导致锁失效问题</strong></li>
</ul>
<p> 计算时间内异步启动另外一个线程去检查的问题，这个key是否超时，当锁超时时间快到期且逻辑未执行完，延长锁超时时间。</p>
<ul>
<li><p>**Redis服务器时钟漂移问题导致同时加锁 redis的过期时间是依赖系统时钟的，如果时钟漂移过大时 理论上是可能出现的 **会影响到过期时间的计算。</p>
</li>
<li><p><strong>单点实例故障，锁未及时同步导致丢失</strong></p>
<p><strong>RedLock算法</strong></p>
</li>
</ul>
<ol>
<li><p>获取当前时间戳T0，配置时钟漂移误差T1</p>
</li>
<li><p>短时间内逐个获取全部N&#x2F;2+1个锁，结束时间点T2</p>
</li>
<li><p>实际锁能使用的处理时长变为：TTL - （T2 - T0）- T1</p>
<p>该方案通过多节点来<strong>防止Redis的单点故障</strong>，效果一般，也无法防止：</p>
</li>
</ol>
<ul>
<li><p><strong>主从切换导致的两个客户端同时持有锁</strong></p>
<p>大部分情况下<strong>持续时间极短</strong>，而且使用<strong>Redlock在切换的瞬间</strong>获取到节点的锁，也存在问题。已经是极低概率的时间，无法避免。<strong>Redis分布式锁适合幂等性事务</strong>，如果一定要<strong>保证安全</strong>，应该<strong>使用Zookeeper或者DB</strong>，但是，<strong>性能会急剧下降</strong>。</p>
</li>
</ul>
<p><strong>与zookeeper分布式锁对比</strong></p>
<ul>
<li>redis 分布式锁，其实<strong>需要自己不断去尝试获取锁</strong>，比较消耗性能。</li>
<li>zk 分布式锁，注册个监听器即可，不需要不断主动尝试获取锁，ZK获取锁会按照加锁的顺序，所以是公平锁，性能和mysql差不多，和redis差别大</li>
</ul>
<p><strong>Redission生产环境的分布式锁</strong></p>
<p> Redisson是基于NIO的Netty框架上的一个Java驻内存数据网格(In-Memory Data Grid)分布式锁开源组件。</p>
<p>[<img src="https://camo.githubusercontent.com/d4bb39450b12931a1c541b9f4cf298c192b80e07401161695c63af3589cdcc02/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676c75726c66727270346a3330716b3067383736632e6a7067" alt="image-20201221000119586"></p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/d4bb39450b12931a1c541b9f4cf298c192b80e07401161695c63af3589cdcc02/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676c75726c66727270346a3330716b3067383736632e6a7067"></a></p>
<ol>
<li>客户端请求加锁</li>
</ol>
<ul>
<li><strong>客户端1请求加锁</strong>：客户端1通过 Redisson 向 Redis 发送加锁请求。</li>
<li><strong>是否加锁</strong>：Redisson 会检查是否能够成功获取锁。如果能获取锁，则进入下一步，否则根据哈希算法选择一个节点进行加锁。</li>
</ul>
<ol start="2">
<li>加锁过程</li>
</ol>
<ul>
<li><strong>根据哈希算法选择一个节点</strong>：Redisson 根据哈希算法选择一个 Redis 主节点来处理加锁请求。</li>
<li><strong>执行Lua脚本加锁</strong>：加锁操作通过 Lua 脚本在 Redis 主节点上执行，确保操作的原子性。</li>
</ul>
<ol start="3">
<li>看门狗机制</li>
</ol>
<ul>
<li><strong>看门狗定时续约</strong>：一旦客户端1成功获取锁，Redisson 的看门狗机制启动。看门狗每隔10秒检查锁的状态，如果客户端还持有锁，则会自动延长锁的生存时间，防止锁过期。</li>
</ul>
<ol start="4">
<li>客户端释放锁</li>
</ol>
<ul>
<li><strong>释放锁和删除 key</strong>：当客户端1完成任务后，会主动释放锁并删除对应的 Redis 键。</li>
</ul>
<ol start="5">
<li>另一个客户端请求加锁</li>
</ol>
<ul>
<li><strong>客户端2请求加锁</strong>：客户端2通过 Redisson 发送加锁请求。</li>
<li><strong>是否加锁</strong>：Redisson 会检查是否能够成功获取锁。如果不能成功获取锁，客户端2会进入一个循环，不断尝试获取锁，直到成功。</li>
</ul>
<p>Redis 集群</p>
<ul>
<li><strong>Redis 集群架构</strong>：Redis 集群由多个主从节点组成，主节点负责写操作，从节点负责读操作和数据复制。</li>
</ul>
<p>但当业务必须要数据的强一致性，即不允许重复获得锁，比如金融场景(重复下单，重复转账)，<strong>请不要使用redis分布式锁</strong>。可以使用CP模型实现，比如:<strong>zookeeper和etcd。</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>Redis</th>
<th>zookeeper</th>
<th>etcd</th>
</tr>
</thead>
<tbody><tr>
<td>一致性算法</td>
<td>无</td>
<td>paxos(ZAB)</td>
<td>raft</td>
</tr>
<tr>
<td>CAP</td>
<td>AP</td>
<td>CP</td>
<td>CP</td>
</tr>
<tr>
<td>高可用</td>
<td>主从集群</td>
<td>n+1</td>
<td>n+1</td>
</tr>
<tr>
<td>实现</td>
<td>setNX</td>
<td>createNode</td>
<td>restfulAPI</td>
</tr>
</tbody></table>
<h4 id="6、redis心跳检测"><a href="#6、redis心跳检测" class="headerlink" title="6、redis心跳检测"></a>6、redis心跳检测</h4><p>在命令传播阶段，从服务器默认会以每秒一次的频率向主服务器发送ACK命令:</p>
<p> 1、检测主从的连接状态 检测主从服务器的网络连接状态</p>
<p> lag的值应该在0或1之间跳动，如果超过1则说明主从之间的连接有 故障。</p>
<p> 2、辅助实现min-slaves,Redis可以通过配置防止主服务器在不安全的情况下执行写命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write 3 (min-replicas-to-write 3 )</span><br><span class="line"></span><br><span class="line">min-slaves-max-lag 10 (min-replicas-max-lag 10)</span><br></pre></td></tr></table></figure>



<p> 上面的配置表示:从服务器的数量少于3个，或者三个从服务器的延迟(lag)值都大于或等于10 秒时，主服务器将拒绝执行写命令。</p>
<p> 3、检测命令丢失，增加重传机制</p>
<p> 如果因为网络故障，主服务器传播给从服务器的写命令在半路丢失，那么当从服务器向主服务器发 送REPLCONF ACK命令时，主服务器将发觉从服务器当前的复制偏移量少于自己的复制偏移量， 然后主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区里面找到从服务器缺少的数据，并将这些数据重新发送给从服务器。</p>
<h3 id="Redis实战"><a href="#Redis实战" class="headerlink" title="Redis实战"></a>Redis实战</h3><h4 id="1、Redis优化"><a href="#1、Redis优化" class="headerlink" title="1、Redis优化"></a>1、Redis优化</h4><p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/4a389e85310aee19c0ed6e9c1a5c881ace5b5a181ebdc4f240b7a64b7d6e0a51/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303865476d5a456c7931676f726d356d376234676a3330757930686a7766702e6a7067"><img src="https://camo.githubusercontent.com/4a389e85310aee19c0ed6e9c1a5c881ace5b5a181ebdc4f240b7a64b7d6e0a51/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303865476d5a456c7931676f726d356d376234676a3330757930686a7766702e6a7067" alt="img"></a></p>
<p><strong>读写方式</strong> 简单来说就是不用<strong>keys</strong>等，用<strong>range、contains</strong>之类。比如，用户粉丝数，大 V 的粉丝更是高达几千万甚至过亿，因此，获取粉丝列表只能部分获取。另外在判断某用户是否关注了另外一个用户时，也只需要关注列表上进行检查判断，然后返回 True&#x2F;False 或 0&#x2F;1 的方式更为高效。</p>
<p><strong>KV size</strong> 如果单个业务的 KV size 过大，需要分拆成多个 KV 来缓存。拆分时应<strong>考虑访问频率</strong></p>
<p><strong>key 的数量</strong> 如果数据量巨大，则在缓存中尽可能只保留频繁访问的热数据，对于冷数据直接访问 DB。</p>
<p><strong>读写峰值</strong> 如果小于 10万 级别，简单分拆到独立 Cache 池即可 如果达到 100万 级的QPS，则需要对 Cache 进行分层处理，可以同时使用 Local-Cache 配合远程 cache，甚至远程缓存内部继续分层叠加分池进行处理。<strong>（多级缓存）</strong></p>
<p><strong>命中率</strong> 缓存的命中率对整个服务体系的性能影响甚大。对于核心高并发访问的业务，需要预留足够的容量，确保核心业务缓存维持较高的命中率。比如微博中的 Feed Vector Cache（<strong>热点资讯</strong>），常年的命中率高达 99.5% 以上。为了持续保持缓存的命中率，缓存体系需要持续监控，及时进行故障处理或故障转移。同时在部分缓存节点异常、命中率下降时，故障转移方案，需要考虑是采用一致性 Hash 分布的访问漂移策略，还是采用数据多层备份策略。</p>
<p><strong>过期策略</strong></p>
<p> 可以设置较短的过期时间，让冷 key 自动过期；也可以让 key 带上时间戳，同时设置较长的过期时间，比如很多业务系统内部有这样一些 key：key_20190801。</p>
<p><strong>缓存穿透时间</strong> 平均缓存穿透加载时间在某些业务场景下也很重要，对于一些缓存穿透后，加载时间特别长或者需要复杂计算的数据，而且访问量还比较大的业务数据，要配置更多容量，维持更高的命中率，从而减少穿透到 DB 的概率，来确保整个系统的访问性能。</p>
<p><strong>缓存可运维性</strong> 对于缓存的可运维性考虑，则需要考虑缓存体系的集群管理，如何进行一键扩缩容，如何进行缓存组件的升级和变更，如何快速发现并定位问题，如何持续监控报警，最好有一个完善的运维平台，将各种运维工具进行集成。</p>
<p><strong>缓存安全性</strong> 对于缓存的安全性考虑，一方面可以限制来源 IP，只允许内网访问，同时加密鉴权访问。</p>
<h4 id="2、Redis热升级"><a href="#2、Redis热升级" class="headerlink" title="2、Redis热升级"></a>2、Redis热升级</h4><blockquote>
<p>在 Redis 需要升级版本或修复 bug 时，如果直接重启变更，由于需要数据恢复，这个过程需要近 10 分钟的时间，时间过长，会严重影响系统的可用性。面对这种问题，可以对 Redis 扩展热升级功能，从而在毫秒级完成升级操作，完全不影响业务访问。</p>
</blockquote>
<p>热升级方案如下，首先构建一个 Redis 壳程序，将 redisServer 的所有属性（包括redisDb、client等）保存为全局变量。然后将 Redis 的处理逻辑代码全部封装到动态连接库 so 文件中。Redis 第一次启动，从磁盘加载恢复数据，在后续升级时，通过指令，壳程序重新加载 Redis 新的 redis-4.so 到 redis-5.so 文件，即可完成功能升级，毫秒级完成 Redis 的版本升级。而且整个过程中，所有 Client 连接仍然保留，在升级成功后，原有 Client 可以继续进行读写操作，整个过程对业务完全透明。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://1008610.xyz">当</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://1008610.xyz/2022/09/01/redis/">http://1008610.xyz/2022/09/01/redis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://1008610.xyz" target="_blank">停云笺</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/redis/">redis</a></div><div class="post-share"><div class="social-share" data-image="/img/cover.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2022/08/01/JVM/" title="JVM基础"><img class="cover" src="/img/cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">JVM基础</div></div><div class="info-2"><div class="info-item-1">JVM  JVM（执行字节码，转为机器码）Java虚拟机概述 Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。 JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回收器，以及可靠的即时编译器。 Java技术的核心就是Java虚拟机（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。  作用​	Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释&#x2F;编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。 特点 一次编译，到处运行 自动内存管理 自动垃圾回收功能  JVM的整体结构 类加载器 运行时数据区 JVM 定义的Java...</div></div></div></a><a class="pagination-related" href="/2022/10/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统"><img class="cover" src="/img/cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">操作系统</div></div><div class="info-2"><div class="info-item-1">操作系统  死锁需要满足的条件 互斥：资源使用必须互斥，多个进程不能同时使用 循环等待：请求资源的进程都在等待上一个进程占用的资源，形成一个回环 非剥夺：进程已获得的资源在完成操作时不可以被剥夺，需要进程自己主动释放 请求与保持：进程获得资源后，又对其他资源进程请求并且不释放自己已经获得的资源  解除死锁的方法破环满足的任一条件，如：  乐观锁，破坏互斥条件（请求资源时不会对资源进行上锁） 剥夺资源，即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件，数据库deadlock超时 资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，从而破坏环路等待的条件，转账场景 资源一次性分配，从而剥夺请求和保持条件、tryLock  </div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">当</div><div class="author-info-description">live my life</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/bobbyfined" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:15217299047@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">Redis篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRedis"><span class="toc-number">1.1.</span> <span class="toc-text">什么是Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WhyRedis"><span class="toc-number">1.2.</span> <span class="toc-text">WhyRedis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81redis"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">1、redis</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">Redis的使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BC%93%E5%AD%98"><span class="toc-number">1.2.0.2.1.</span> <span class="toc-text"> 热点数据的缓存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%99%90%E6%97%B6%E4%B8%9A%E5%8A%A1%E7%9A%84%E8%BF%90%E7%94%A8"><span class="toc-number">1.2.0.2.2.</span> <span class="toc-text"> 限时业务的运用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.0.2.3.</span> <span class="toc-text"> 计数器相关问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">1.2.0.2.4.</span> <span class="toc-text"> 分布式锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BB%B6%E6%97%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.0.2.5.</span> <span class="toc-text"> 延时操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%92%E8%A1%8C%E6%A6%9C%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.0.2.6.</span> <span class="toc-text"> 排行榜相关问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%82%B9%E8%B5%9E%E3%80%81%E5%A5%BD%E5%8F%8B%E7%AD%89%E7%9B%B8%E4%BA%92%E5%85%B3%E7%B3%BB%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">1.2.0.2.7.</span> <span class="toc-text"> 点赞、好友等相互关系的存储</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E9%98%9F%E5%88%97"><span class="toc-number">1.2.0.2.8.</span> <span class="toc-text"> 简单队列</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81Memcache"><span class="toc-number">1.2.0.3.</span> <span class="toc-text">2、Memcache</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">1.2.0.3.1.</span> <span class="toc-text">使用场景：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81Tair"><span class="toc-number">1.2.0.4.</span> <span class="toc-text">3、Tair</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81Guava"><span class="toc-number">1.2.0.5.</span> <span class="toc-text">4、Guava</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81EVCache"><span class="toc-number">1.2.0.6.</span> <span class="toc-text">5、EVCache</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81ETCD"><span class="toc-number">1.2.0.7.</span> <span class="toc-text">6、ETCD</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%BA%95%E5%B1%82"><span class="toc-number">1.2.1.</span> <span class="toc-text">Redis底层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">1、redis数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%9B%B8%E5%85%B3API"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">2、相关API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81redis%E5%90%84%E4%B8%AA%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">3、redis各个类型的底层结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-String%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89"><span class="toc-number">1.2.1.3.1.</span> <span class="toc-text">1. String（字符串）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-List%EF%BC%88%E5%88%97%E8%A1%A8%EF%BC%89"><span class="toc-number">1.2.1.3.2.</span> <span class="toc-text">2. List（列表）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-Hash%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89"><span class="toc-number">1.2.1.3.3.</span> <span class="toc-text">3. Hash（哈希表）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-Set%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89"><span class="toc-number">1.2.1.3.4.</span> <span class="toc-text">4. Set（集合）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-Sorted-Set%EF%BC%88%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%89"><span class="toc-number">1.2.1.3.5.</span> <span class="toc-text">5. Sorted Set（有序集合）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Stream"><span class="toc-number">1.2.1.3.6.</span> <span class="toc-text">Stream</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81Zset%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">4、Zset底层实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%8F%AF%E7%94%A8%E6%80%A7"><span class="toc-number">1.2.2.</span> <span class="toc-text">Redis可用性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81redis%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">1、redis持久化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81redis%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2、redis事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81redis%E5%A4%B1%E6%95%88%E7%AD%96%E7%95%A5"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">3、redis失效策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81redis%E8%AF%BB%E5%86%99%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">4、redis读写模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">5、多级缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%B8%83%E5%A4%A7%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.3.</span> <span class="toc-text">Redis七大经典问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">1、缓存雪崩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">2、缓存穿透</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">3、缓存击穿</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">4、数据不一致</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%8F%91%E7%AB%9E%E4%BA%89"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">5、数据并发竞争</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E7%83%AD%E7%82%B9key%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.3.6.</span> <span class="toc-text">6、热点key问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81BigKey%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.3.7.</span> <span class="toc-text">7、BigKey问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%88%86%E5%8C%BA%E5%AE%B9%E9%94%99"><span class="toc-number">1.2.4.</span> <span class="toc-text">Redis分区容错</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81redis%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">1、redis数据分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">2、主从模式&#x3D;简单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F-%E8%AF%BB%E5%A4%9A"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">3、哨兵模式&#x3D;读多</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F-%E5%86%99%E5%A4%9A"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">4、集群模式&#x3D;写多</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">1.2.4.5.</span> <span class="toc-text">5、分布式锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81redis%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B"><span class="toc-number">1.2.4.6.</span> <span class="toc-text">6、redis心跳检测</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%AE%9E%E6%88%98"><span class="toc-number">1.2.5.</span> <span class="toc-text">Redis实战</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81Redis%E4%BC%98%E5%8C%96"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">1、Redis优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81Redis%E7%83%AD%E5%8D%87%E7%BA%A7"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">2、Redis热升级</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/02/19/hello-world/" title="Hello World"><img src="/img/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2025/02/19/hello-world/" title="Hello World">Hello World</a><time datetime="2025-02-19T15:04:18.552Z" title="发表于 2025-02-19 23:04:18">2025-02-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/13/%E4%BD%BF%E7%94%A8ollama%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAdeepseek/" title="使用ollama本地搭建deepseek"><img src="/img/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用ollama本地搭建deepseek"/></a><div class="content"><a class="title" href="/2025/02/13/%E4%BD%BF%E7%94%A8ollama%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAdeepseek/" title="使用ollama本地搭建deepseek">使用ollama本地搭建deepseek</a><time datetime="2025-02-13T06:32:22.000Z" title="发表于 2025-02-13 14:32:22">2025-02-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/08/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/" title="在Cursor中开发Java项目 -- 开发环境常用插件"><img src="/img/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="在Cursor中开发Java项目 -- 开发环境常用插件"/></a><div class="content"><a class="title" href="/2025/02/08/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/" title="在Cursor中开发Java项目 -- 开发环境常用插件">在Cursor中开发Java项目 -- 开发环境常用插件</a><time datetime="2025-02-08T12:35:22.000Z" title="发表于 2025-02-08 20:35:22">2025-02-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/08/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/" title="在Cursor中开发Java项目 -- 开发环境常用插件"><img src="/img/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="在Cursor中开发Java项目 -- 开发环境常用插件"/></a><div class="content"><a class="title" href="/2025/02/08/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/" title="在Cursor中开发Java项目 -- 开发环境常用插件">在Cursor中开发Java项目 -- 开发环境常用插件</a><time datetime="2025-02-08T12:32:22.000Z" title="发表于 2025-02-08 20:32:22">2025-02-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/18/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="多线程"><img src="/img/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="多线程"/></a><div class="content"><a class="title" href="/2024/12/18/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="多线程">多线程</a><time datetime="2024-12-18T12:14:36.000Z" title="发表于 2024-12-18 20:14:36">2024-12-18</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By 当</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23ct2vz0d4GgoviQT8',
      clientSecret: 'b6e6ffe5501f5423537511112b2908d2d2ec78e9',
      repo: 'boke-comments',
      owner: 'bobbyfined',
      admin: ['bobbyfined'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '7822eecac4b7ee92b272c11a8184f264'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>