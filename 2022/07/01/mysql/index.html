<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>MySQL基础 | 停云笺</title><meta name="author" content="当"><meta name="copyright" content="当"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="MySQL篇">
<meta property="og:type" content="website">
<meta property="og:title" content="MySQL基础">
<meta property="og:url" content="http://1008610.xyz/2022/07/01/mysql/index.html">
<meta property="og:site_name" content="停云笺">
<meta property="og:description" content="MySQL篇">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://1008610.xyz/img/cover.png">
<meta property="article:published_time" content="2022-07-01T06:14:36.000Z">
<meta property="article:modified_time" content="2025-02-07T15:00:37.947Z">
<meta property="article:author" content="当">
<meta property="article:tag" content="mysql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://1008610.xyz/img/cover.png"><link rel="shortcut icon" href="/img/title-boke.png"><link rel="canonical" href="http://1008610.xyz/2022/07/01/mysql/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySQL基础',
  isHighlightShrink: false,
  isToc: false,
  pageType: 'title'
}</script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/img/yun.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-video"></i><span> 照片</span></a></li></ul></div></div></div></div><div class="page" id="body-wrap"><header class="not-home-page" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">停云笺</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-video"></i><span> 照片</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="page-site-info"><h1 id="site-title">MySQL基础</h1></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img gist" style="background-image: url(/null)"></div><article class="post-content" id="article-container"><h1 id="MySQL篇"><a href="#MySQL篇" class="headerlink" title="MySQL篇"></a>MySQL篇</h1><span id="more"></span>

<h3 id="WhyMysql？"><a href="#WhyMysql？" class="headerlink" title="WhyMysql？"></a>WhyMysql？</h3><p>NoSQL数据库四大家族</p>
<ul>
<li>列存储 Hbase</li>
<li>K-V存储 Redis</li>
<li>图像存储 Neo4j</li>
<li>文档存储 MongoDB</li>
</ul>
<p>云存储OSS</p>
<h4 id="海量Aerospike"><a href="#海量Aerospike" class="headerlink" title="海量Aerospike"></a>海量Aerospike</h4><p> Aerospike（简称AS）是一个分布式，可扩展的键值存储的NoSQL<strong>数据库</strong>。T级别大数据高并发的结构化<strong>数据存储，</strong>采用混合架构，索引存储在内存中，而数据可存储在机械硬盘(HDD)或固态硬盘(SSD) 上，读写操作达微妙级，99%的响应可在1毫秒内实现。</p>
<table>
<thead>
<tr>
<th></th>
<th>Aerospike</th>
<th>Redis</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>Nosql数据库</td>
<td>缓存</td>
</tr>
<tr>
<td>线程数</td>
<td>多线程</td>
<td>单线程</td>
</tr>
<tr>
<td>数据分片</td>
<td>自动处理相当于分片</td>
<td>提供分片算法、平衡各分片数据</td>
</tr>
<tr>
<td>数据扩容</td>
<td>动态增加数据卷平衡流量</td>
<td>需停机</td>
</tr>
<tr>
<td>数据同步</td>
<td>设置复制因子后可以透明的完成故障转移</td>
<td>手动故障转移和数据同步</td>
</tr>
<tr>
<td>载体</td>
<td>内存存储索引+SSD存储数据</td>
<td>内存</td>
</tr>
</tbody></table>
<p> Aerospike作为一个大容量的NoSql解决方案，适合对<strong>容量要求比较大，QPS相对低</strong>一些的场景，主要用在广告行业，<strong>个性化推荐厂告</strong>是建立在了和掌握消费者独特的偏好和习性的基础之上，对消费者的购买需求做出准确的预测或引导，在合适的位置、合适的时间，以合适的形式向消费者呈现与其需求高度吻合的广告，以此来促进用户的消费行为。</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/cd14944dd2a162a3cc5ff7f769126d104281620ea41026b96b73b058862e5525/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676d616d3433623434626a333064393064346161372e6a7067"><img src="https://camo.githubusercontent.com/cd14944dd2a162a3cc5ff7f769126d104281620ea41026b96b73b058862e5525/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676d616d3433623434626a333064393064346161372e6a7067" alt="image-20210103170039711"></a></p>
<p> （ETL数据仓库技术）抽取（extract）、转换（transform）、加载（load）</p>
<ul>
<li><p>用户行为日志收集系统收集日志之后推送到ETL做数据的清洗和转换</p>
</li>
<li><p>把ETL过后的数据发送到推荐引擎计算每个消费者的推荐结果，其中推荐逻辑包括规则和算法两部分</p>
</li>
<li><p>收集用户最近浏览、最长停留等特征，分析商品相似性、用户相似性、相似性等算法。</p>
</li>
<li><p>把推荐引擎的结果存入Aerospike集群中，并提供给广告投放引擎实时获取</p>
<p>分别通过HDFS和HBASE对日志进行离线和实时的分析，然后把用户画像的标签(tag : 程序猿、宅男…)结果存入高性能的Nosql数据库Aerospike中，同时把数据备份到异地数据中心。前端广告投放请求通过决策引擎（投放引擎）向用户画像数据库中读取相应的用户画像数据，然后根据竞价算法出价进行竞价。竞价成功之后就可以展现广告了。而在竞价成功之后，具体给用户展现什么样的广告，就是有上面说的个性化推荐广告来完成的。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Aerospike</th>
<th>Mysql</th>
</tr>
</thead>
<tbody><tr>
<td>库名</td>
<td>Namespace</td>
<td>Database</td>
</tr>
<tr>
<td>表名</td>
<td>Set</td>
<td>Table</td>
</tr>
<tr>
<td>记录</td>
<td>Bin</td>
<td>Column</td>
</tr>
<tr>
<td>字段</td>
<td>Record</td>
<td>Row</td>
</tr>
<tr>
<td>索引</td>
<td>key 、 pk 、kv</td>
<td>pk</td>
</tr>
</tbody></table>
<h4 id="图谱Neo4j"><a href="#图谱Neo4j" class="headerlink" title="图谱Neo4j"></a>图谱Neo4j</h4><blockquote>
<p>Neo4j是一个开源基于java开发的图形noSql数据库，它将结构化数据存储在图中而不是表中。它是一个嵌入式的、基于磁盘的、具备完全的事务特性的Java持久化引擎。程序数据是在一个面向对象的、灵活的网络结构下，而不是严格的表中，但具备完全的事务特性、企业级的数据库的所有好处。</p>
</blockquote>
<p>一种基于图的数据结构，由节点(Node)和边(Edge)组成。其中节点即实体，由一个全局唯一的ID标示，边就是关系用于连接两个节点。通俗地讲，知识图谱就是把所有不同种类的信息，连接在一起而得到的一个关系网络。知识图谱提供了从“关系”的角度去分析问题的能力。</p>
<p>互联网、大数据的背景下，谷歌、百度、搜狗等搜索引擎纷纷基于该背景，创建自己的知识图<strong>Knowledge Graph（谷歌</strong>）、<strong>知心（百度）和知立方（搜狗）</strong>，主要用于改进搜索质量。</p>
<p>自己项目主要用作好友推荐，图数据库(Graph database)指的是以图数据结构的形式来存储和查询数据的数据库。关系图谱中，关系的组织形式采用的就是图结构，所以非常适合用图库进行存储。</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/52f1c7041e734d0a78b73af0b6f593a5e4371fb7da13dbc3fdffa8c9ca7d84a5/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676d6171306a396f74646a3330707a30656e30766d2e6a7067"><img src="https://camo.githubusercontent.com/52f1c7041e734d0a78b73af0b6f593a5e4371fb7da13dbc3fdffa8c9ca7d84a5/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676d6171306a396f74646a3330707a30656e30766d2e6a7067" alt="image-20210103191540372"></a></p>
<p>优势总结:</p>
</li>
<li><p>性能上，使用cql查询，对长程关系的查询速度快</p>
</li>
<li><p>擅于发现隐藏的关系，例如通过判断图上两点之间有没有走的通的路径，就可以发现事物间的关联</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/96885ec084dd4190ed377c82069748bde17edbbf6abc920a2da49873d52fb3cf/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676d61716337357936626a333077633064363075342e6a7067"><img src="https://camo.githubusercontent.com/96885ec084dd4190ed377c82069748bde17edbbf6abc920a2da49873d52fb3cf/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676d61716337357936626a333077633064363075342e6a7067" alt="image-20210103192653004"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 查询三层级关系节点如下：with可以将前面查询结果作为后面查询条件</span><br><span class="line">match (na:Person)-[re]-(nb:Person) where na.name=&quot;林婉儿&quot; WITH na,re,nb match (nb:Person)- [re2:Friends]-&gt;(nc:Person) return na,re,nb,re2,nc</span><br><span class="line">// 直接拼接关系节点查询</span><br><span class="line">match data=(na:Person&#123;name:&quot;范闲&quot;&#125;)-[re]-&gt;(nb:Person)-[re2]-&gt;(nc:Person) return data</span><br><span class="line">// 使用深度运算符</span><br><span class="line">显然使用以上方式比较繁琐,可变数量的关系-&gt;节点可以使用-[:TYPE*minHops..maxHops]-。</span><br><span class="line">match data=(na:Person&#123;name:&quot;范闲&quot;&#125;)-[*1..2]-(nb:Person) return data</span><br></pre></td></tr></table></figure>



<h4 id="文档MongoDB"><a href="#文档MongoDB" class="headerlink" title="文档MongoDB"></a><strong>文档MongoDB</strong></h4><blockquote>
<p>MongoDB 是一个基于分布式文件存储的数据库，是非关系数据库中功能最丰富、最像关系数据库的。在高负载的情况下，通过添加更多的节点，可以保证服务器性能。由 C++ 编写，可以为 WEB 应用提供可扩展、高性能、易部署的数据存储解决方案。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/f76c639d290aba63911606ba1168371bf87403a262711ed49c104170cf2a9662/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676d61717970373571736a333132713069387135662e6a7067"><img src="https://camo.githubusercontent.com/f76c639d290aba63911606ba1168371bf87403a262711ed49c104170cf2a9662/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676d61717970373571736a333132713069387135662e6a7067" alt="image-20210103194830654"></a></p>
<p><strong>什么是BSON</strong></p>
<blockquote>
<p>{key:value,key2:value2}和Json类似，是一种二进制形式的存储格式，支持内嵌的文档对象和数组对象，但是BSON有JSON没有的一些数据类型，比如 value包括字符串,double,Array,DateBSON可以做为网络数据交换的一种存储形式,它的优点是灵活性高，但它的缺点是空间利用率不是很理想。</p>
</blockquote>
<p>BSON有三个特点：轻量性、可遍历性、高效性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 查询 find() 方法可以传入多个键(key)，每个键(key)以逗号隔开*/</span><br><span class="line">db.collection.find(&#123;key1:value1, key2:value2&#125;).pretty()</span><br><span class="line">/* 更新 $set ：设置字段值 $unset :删除指定字段 $inc：对修改的值进行自增*/</span><br><span class="line">db.collection.update(&#123;where&#125;,&#123;$set:&#123;字段名:值&#125;&#125;,&#123;multi:true&#125;)</span><br><span class="line">/* 删除 justOne :如果设为true，只删除一个文档，默认false，删除所有匹配条件的文档*/</span><br><span class="line">db.collection.remove(&#123;where&#125;, &#123;justOne: &lt;boolean&gt;, writeConcern: &lt;回执&gt; &#125; )</span><br></pre></td></tr></table></figure>



<p><strong>优点：</strong></p>
<ul>
<li><p><strong>文档结构的存储方式，能够更便捷的获取数据。</strong></p>
<p>对于一个层级式的数据结构来说，使用扁平式的，表状的结构来查询保存数据非常的困难。</p>
</li>
<li><p><strong>内置GridFS，支持大容量的存储。</strong></p>
<p>GridFS是一个出色的分布式文件系统，支持海量的数据存储，满足对大数据集的快速范围查询。</p>
</li>
<li><p><strong>性能优越</strong></p>
<p>千万级别的文档对象，近10G的数据，对有索引的ID的查询 不会比mysql慢，而对非索引字段的查询，则是全面胜出。 mysql实际无法胜任大数据量下任意字段的查询，而mongodb的查询性能实在牛逼。写入性能同样很令人满意，同样写入百万级别的数据，mongodb基本10分钟以下可以解决。</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>不支持事务</li>
<li>磁盘占用空间大</li>
</ul>
<h4 id="MySQL-8-0-版本"><a href="#MySQL-8-0-版本" class="headerlink" title="MySQL 8.0 版本"></a>MySQL 8.0 版本</h4><p><strong>1. 性能</strong>：MySQL 8.0 的速度要比 MySQL 5.7 快 2 倍。</p>
<p><strong>2. NoSQL</strong>：MySQL 从 5.7 版本开始提供 NoSQL 存储功能，在 8.0 版本中nosql得到了更大的改进。</p>
<p><strong>3. 窗口函数</strong>：实现若干新的查询方式。窗口函数与 SUM()、COUNT() 这种集合函数类似，但它不会将多行查询结果合并为一行，而是将结果放回多行当中，即窗口函数不需要 GROUP BY。</p>
<p><strong>4. 隐藏索引</strong>：在 MySQL 8.0 中，索引可以被“隐藏”和“显示”。当对索引进行隐藏时，它不会被查询优化器所使用。我们可以使用这个特性用于性能调试，例如我们先隐藏一个索引，然后观察其对数据库的影响。如果数据库性能有所下降，说明这个索引是有用的，然后将其“恢复显示”即可；如果数据库性能看不出变化，说明这个索引是多余的，可以考虑删掉。</p>
<h4 id="云存储"><a href="#云存储" class="headerlink" title="云存储"></a><strong>云存储</strong></h4><table>
<thead>
<tr>
<th></th>
<th>OSS</th>
<th>自建</th>
</tr>
</thead>
<tbody><tr>
<td>可靠性</td>
<td>可用性不低于99.995% 数据设计持久性不低于99.9999999999%（12个9）</td>
<td>受限于硬件可靠性，易出问题，一旦出现磁盘坏道，容易出现不可逆转的数据丢失。人工数据恢复困难、耗时、耗力。</td>
</tr>
<tr>
<td>安全</td>
<td>服务端加密、客户端加密、防盗链、IP黑白名单等。多用户资源隔离机制，支持异地容灾机制。</td>
<td>需要另外购买清洗和黑洞设备。需要单独实现安全机制。</td>
</tr>
<tr>
<td>成本</td>
<td>多线BGP骨干网络，无带宽限制，上行流量免费。无需运维人员与托管费用，0成本运维。</td>
<td>单线或双线接入速度慢，有带宽限制，峰值时期需人工扩容。需专人运维，成本高。</td>
</tr>
</tbody></table>
<p><strong>使用步骤</strong></p>
<p> 1、开通服务</p>
<p> 2、创建存储空间</p>
<p> 3、上传文件、下载文件、删除文件</p>
<p> 4、域名绑定、日志记录</p>
<p> 5、根据开放接口进行鉴权访问</p>
<p><strong>功能</strong></p>
<p> 图片编辑（裁剪、模糊、水印）</p>
<p> 视频截图</p>
<p> 音频转码、视频修复</p>
<p><strong>CDN加速</strong></p>
<p> 对象存储OSS与阿里云CDN服务结合，可优化静态热点文件下载加速的场景（即同一地区大量用户同时下载同一个静态文件的场景）。可以将OSS的存储空间（Bucket）作为源站，利用阿里云CDN将源内容发布到边缘节点。当大量终端用户重复访问同一文件时，可以直接从边缘节点获取已缓存的数据，提高访问的响应速度</p>
<h4 id="FastDFS"><a href="#FastDFS" class="headerlink" title="FastDFS"></a><strong>FastDFS</strong></h4><blockquote>
<p><strong>开源的轻量级分布式文件系统</strong>。它对文件进行管理，功能包括：<strong>文件存储、文件同步、文件访问</strong>（文件上传、文件下载）等，解决了<strong>大容量存储和负载均衡</strong>的问题。使用FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。如<strong>相册网站、视频网站</strong>等</p>
</blockquote>
<p><strong>扩展能力:</strong> 支持水平扩展，可以动态扩容；</p>
<p><strong>高可用性:</strong> 一是整个文件系统的可用性，二是数据的完整和一致性；</p>
<p><strong>弹性存储:</strong> 可以根据业务需要灵活地增删存储池中的资源，而不需要中断系统运行。</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/58747336811595da167be5bd93a23be0b220e6573eb6b9e51c3abfebed2afd88/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303865476d5a456c7931676d66686a6b766f35396a33307a753062346469622e6a7067"><img src="https://camo.githubusercontent.com/58747336811595da167be5bd93a23be0b220e6573eb6b9e51c3abfebed2afd88/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303865476d5a456c7931676d66686a6b766f35396a33307a753062346469622e6a7067" alt="image-20210107221022658"></a></p>
<p>特性</p>
<ul>
<li>和流行的web server无缝衔接，FastDFS已提供apache和nginx扩展模块</li>
<li>文件ID由FastDFS生成，作为文件访问凭证，FastDFS不需要传统的name server</li>
<li>分组存储，灵活简洁、对等结构，不存在单点</li>
<li>文件不分块存储，上传的文件和OS文件系统中的文件一一对应</li>
<li>中、小文件均可以很好支持，支持海量小文件存储</li>
<li>支持相同内容的文件只保存一份，节约磁盘空间</li>
<li>支持多块磁盘，支持单盘数据恢复</li>
<li>支持在线扩容 支持主从文件</li>
<li>下载文件支持多线程方式，支持断点续传</li>
</ul>
<p><strong>组成</strong></p>
<ul>
<li><p><strong>客户端（client）</strong></p>
<p>通过专有接口，使用TCP&#x2F;IP协议与跟踪器服务器或存储节点进行数据交互。</p>
</li>
<li><p><strong>跟踪器（tracker）</strong></p>
<p>Trackerserver作用是负载均衡和调度，通过Tracker server在文件上传时可以根据策略找到文件上传的地址。Tracker在访问上起负载均衡的作用。</p>
</li>
<li><p><strong>存储节点（storage）</strong></p>
<p>Storageserver作用是文件存储，客户端上传的文件最终存储在Storage服务器上，Storage server<strong>没有实现自己的文件系统而是利用操作系统的文件系统来管理文件</strong>。存储节点中的服务器均可以<strong>随时增加或下线而不会影响线上服务</strong>。</p>
</li>
</ul>
<p><strong>上传</strong></p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/edd264822ed486a33a9262901b6a53a5cde3594012a2d41e83bf6ae57236ba9a/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303865476d5a456c7931676d6668766b3077777a6a33307565306834646c772e6a7067"><img src="https://camo.githubusercontent.com/edd264822ed486a33a9262901b6a53a5cde3594012a2d41e83bf6ae57236ba9a/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303865476d5a456c7931676d6668766b3077777a6a33307565306834646c772e6a7067" alt="image-20210107222155291"></a></p>
<p><strong>下载</strong></p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/e900373916040832996ceba751552f1c87722d42ab4fdf042ee84a32ed64a952/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303865476d5a456c7931676d66687777387a6d666a333075773067366e33372e6a7067"><img src="https://camo.githubusercontent.com/e900373916040832996ceba751552f1c87722d42ab4fdf042ee84a32ed64a952/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303865476d5a456c7931676d66687777387a6d666a333075773067366e33372e6a7067" alt="image-20210107222312338"></a></p>
<p><strong>断点续传</strong></p>
<p> 续传涉及到的文件大小MD5不会改变。续传流程与文件上传类似，先<strong>定位到源storage</strong>，完成完整或部分上传，再<strong>通过binlog进行同group内server文件同步</strong>。</p>
<p><strong>配置优化</strong></p>
<p>配置文件：tracker.conf 和 storage.conf</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// FastDFS采用内存池的做法。 </span><br><span class="line">// v5.04对预分配采用增量方式，tracker一次预分配 1024个，storage一次预分配256个。 </span><br><span class="line">max_connections = 10240</span><br><span class="line">// 根据实际需要将 max_connections 设置为一个较大的数值，比如 10240 甚至更大。</span><br><span class="line">// 同时需要将一个进程允许打开的最大文件数调大</span><br><span class="line">vi /etc/security/limits.conf 重启系统生效 </span><br><span class="line">* soft nofile 65535 </span><br><span class="line">* hard nofile 65535</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">work_threads = 4 </span><br><span class="line">// 说明：为了避免CPU上下文切换的开销，以及不必要的资源消耗，不建议将本参数设置得过大。</span><br><span class="line">// 公式为： work_threads + (reader_threads + writer_threads) = CPU数</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 对于单盘挂载方式，磁盘读写线程分 别设置为 1即可 </span><br><span class="line">// 如果磁盘做了RAID，那么需要酌情加大读写线程数，这样才能最大程度地发挥磁盘性能</span><br><span class="line">disk_rw_separated：磁盘读写是否分离 </span><br><span class="line">disk_reader_threads：单个磁盘读线程数 </span><br><span class="line">disk_writer_threads：单个磁盘写线程数 </span><br></pre></td></tr></table></figure>



<p><strong>避免重复</strong></p>
<p> 如何避免文件重复上传 解决方案 上传成功后计算文件对应的MD5然后<strong>存入MySQL</strong>,添加文件时把<strong>文件MD5和之前存入MYSQL中的存储的信息对比</strong> 。DigestUtils.md5DigestAsHex(bytes)。</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="1、事务4大特性"><a href="#1、事务4大特性" class="headerlink" title="1、事务4大特性"></a><strong>1、事务4大特性</strong></h4><p><strong>事务4大特性：</strong>原子性、一致性、隔离性、持久性</p>
<p> <strong>原⼦性：</strong> 事务是最⼩的执⾏单位，不允许分割。事务的原⼦性确保动作要么全部完成，要么全不执行</p>
<p> <strong>一致性：</strong> 执⾏事务前后，数据保持⼀致，多个事务对同⼀个数据读取的结果是相同的；</p>
<p> <strong>隔离性：</strong> 并发访问数据库时，⼀个⽤户的事务不被其他事务所⼲扰，各并发事务之间数据库是独⽴的；</p>
<p> <strong>持久性：</strong> ⼀个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发⽣故障也不应该对其有任何影响。</p>
<p><strong>实现保证：</strong></p>
<p> MySQL的存储引擎InnoDB使用重做日志保证一致性与持久性，回滚日志保证原子性，使用各种锁来保证隔离性。</p>
<h4 id="2、事务隔离级别"><a href="#2、事务隔离级别" class="headerlink" title="2、事务隔离级别"></a><strong>2、事务隔离级别</strong></h4><p><strong>读未提交：</strong>最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p>
<p><strong>读已提交：</strong>允许读取并发事务已经提交的数据，可以阻⽌脏读，但是幻读或不可重复读仍有可能发⽣。</p>
<p><strong>可重复读：</strong>同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务⾃⼰所修改，可以阻⽌脏读和不可重复读，会有幻读。</p>
<p><strong>串行化：</strong>最⾼的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执⾏，这样事务之间就完全不可能产⽣⼲扰。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>并发问题</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交</td>
<td>可能会导致脏读、幻读或不可重复读</td>
</tr>
<tr>
<td>读已提交</td>
<td>可能会导致幻读或不可重复读</td>
</tr>
<tr>
<td>可重复读</td>
<td>可能会导致幻读</td>
</tr>
<tr>
<td>可串行化</td>
<td>不会产⽣⼲扰</td>
</tr>
</tbody></table>
<h4 id="3、默认隔离级别-RR"><a href="#3、默认隔离级别-RR" class="headerlink" title="3、默认隔离级别-RR"></a><strong>3、默认隔离级别-RR</strong></h4><p><strong>默认隔离级别：</strong>可重复读；</p>
<p> 同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务⾃⼰所修改；</p>
<p> 可重复读是有可能出现幻读的，如果要保证绝对的安全只能把隔离级别设置成SERIALIZABLE；这样所有事务都只能顺序执行，自然不会因为并发有什么影响了，但是性能会下降许多。</p>
<p> 第二种方式，使用MVCC解决<strong>快照读幻读问题</strong>（如简单select），读取的不是最新的数据。维护一个字段作为version，这样可以控制到每次只能有一个人更新一个版本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id from table_xx where id = ? and version = V</span><br><span class="line">update id from table_xx where id = ? and version = V+1</span><br></pre></td></tr></table></figure>



<p> 第三种方式，如果需要读最新的数据，可以通过GapLock+Next-KeyLock可以解决<strong>当前读幻读问题</strong>，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id from table_xx where id &gt; 100 for update;</span><br><span class="line">select id from table_xx where id &gt; 100 lock in share mode;</span><br></pre></td></tr></table></figure>

<h4 id="4、RR和RC使用场景"><a href="#4、RR和RC使用场景" class="headerlink" title="4、RR和RC使用场景"></a><strong>4、RR和RC使用场景</strong></h4><p> 事务隔离级别RC(read commit)和RR（repeatable read）两种事务隔离级别基于多版本并发控制MVCC(multi-version concurrency control）来实现。</p>
<table>
<thead>
<tr>
<th></th>
<th>RC</th>
<th>RR</th>
</tr>
</thead>
<tbody><tr>
<td>实现</td>
<td>多条查询语句会创建多个不同的ReadView</td>
<td>仅需要一个版本的ReadView</td>
</tr>
<tr>
<td>粒度</td>
<td>语句级读一致性</td>
<td>事务级读一致性</td>
</tr>
<tr>
<td>准确性</td>
<td>每次语句执行时间点的数据</td>
<td>第一条语句执行时间点的数据</td>
</tr>
</tbody></table>
<h4 id="5、行锁，表锁，意向锁（事务隔离时用到的）"><a href="#5、行锁，表锁，意向锁（事务隔离时用到的）" class="headerlink" title="5、行锁，表锁，意向锁（事务隔离时用到的）"></a><strong>5、行锁，表锁，意向锁</strong>（事务隔离时用到的）</h4><p><strong>InnoDB⽀持⾏级锁(row-level locking)和表级锁,默认为⾏级锁</strong></p>
<p> InnoDB按照不同的分类的锁：</p>
<p> 共享&#x2F;排它锁(Shared and Exclusive Locks)：行级别锁，</p>
<p> 意向锁(Intention Locks)：表级别锁</p>
<p> 间隙锁(Gap Locks)：锁定一个区间</p>
<p> 记录锁(Record Locks)：锁定一个行记录</p>
<p><strong>表级锁：（串行化）</strong></p>
<p> Mysql中锁定 粒度最大的一种锁，对当前操作的整张表加锁，实现简单 ，资源消耗也比较少，加锁快，不会出现死锁 。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。</p>
<p><strong>行级锁：（RR、RC）</strong></p>
<p> Mysql中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。 InnoDB支持的行级锁，包括如下几种：</p>
<p> <strong>记录锁（Record Lock）:</strong> 对索引项加锁，锁定<strong>符合条件的行</strong>。其他事务不能修改和删除加锁项；</p>
<p> <strong>间隙锁（Gap Lock）:</strong> 对索引项之间的“间隙”加锁，锁定<strong>记录的范围</strong>，不包含索引项本身，其他事务不能在锁范围内插入数据。</p>
<p> <strong>Next-key Lock：</strong> 锁定索引项本身和索引范围。即Record Lock和Gap Lock的结合。可解决幻读问题。</p>
<p>InnoDB 支持多粒度锁（multiple granularity locking），它允许行级锁与表级锁共存，而意向锁就是其中的一种表锁。</p>
<p><strong>共享锁</strong>（ shared lock, S ）锁允许持有锁读取行的事务。加锁时将自己和子节点全加S锁，父节点直到表头全加IS锁</p>
<p><strong>排他锁</strong>（ exclusive lock， X ）锁允许持有锁修改行的事务。 加锁时将自己和子节点全加X锁，父节点直到表头全加IX锁</p>
<p><strong>意向共享锁</strong>（intention shared lock, IS）：事务有意向对表中的某些行加<strong>共享锁</strong>（S锁）</p>
<p><strong>意向排他锁</strong>（intention exclusive lock, IX）：事务有意向对表中的某些行加<strong>排他锁</strong>（X锁）</p>
<table>
<thead>
<tr>
<th>互斥性</th>
<th>共享锁（S）</th>
<th>排它锁（X）</th>
<th>意向共享锁IS</th>
<th>意向排他锁IX</th>
</tr>
</thead>
<tbody><tr>
<td>共享锁（S）</td>
<td>✅</td>
<td>❌</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>排它锁（X）</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>意向共享锁IS</td>
<td>✅</td>
<td>❌</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>意向排他锁IX</td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
<td>✅</td>
</tr>
</tbody></table>
<h4 id="6、MVCC多版本并发控制"><a href="#6、MVCC多版本并发控制" class="headerlink" title="6、MVCC多版本并发控制"></a><strong>6、MVCC多版本并发控制</strong></h4><p> MVCC是一种多版本并发控制机制，通过事务的可见性看到自己预期的数据，能降低其系统开销.（RC和RR级别工作）</p>
<p> InnoDB的MVCC,是通过在每行记录后面保存系统版本号(可以理解为事务的ID)，每开始一个新的事务，系统版本号就会自动递增，事务开始时刻的系统版本号会作为事务的ID。这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的，防止幻读的产生。</p>
<p> 1.MVCC手段只适用于Msyql隔离级别中的读已提交（Read committed）和可重复读（Repeatable Read）.</p>
<p> 2.Read uncimmitted由于存在脏读，即能读到未提交事务的数据行，所以不适用MVCC.</p>
<p> 3.简单的select快照度不会加锁，删改及select for update等需要当前读的场景会加锁</p>
<p> 原因是MVCC的创建版本和删除版本只要在事务提交后才会产生。客观上，mysql使用的是乐观锁的一整实现方式，就是每行都有版本号，保存时根据版本号决定是否成功。Innodb的MVCC使用到的快照存储在Undo日志中，该日志通过回滚指针把一个数据行所有快照连接起来。</p>
<p><strong>版本链</strong></p>
<p>在InnoDB引擎表中，它的聚簇索引记录中有两个必要的隐藏列：</p>
<p><strong>trx_id</strong></p>
<p>这个id用来存储的每次对某条聚簇索引记录进行修改的时候的事务id。</p>
<p><strong>roll_pointer</strong></p>
<p>每次对哪条聚簇索引记录有修改的时候，都会把老版本写入undo日志中。这个roll_pointer就是存了一个指针，它指向这条聚簇索引记录的上一个版本的位置，通过它来获得上一个版本的记录信息。(注意插入操作的undo日志没有这个属性，因为它没有老版本)</p>
<p>每次修改都会在版本链中记录。<strong>SELECT可以去版本链中拿记录，这就实现了读-写，写-读的并发执行，</strong>提升了系统的性能。</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="1、Innodb和Myisam引擎"><a href="#1、Innodb和Myisam引擎" class="headerlink" title="1、Innodb和Myisam引擎"></a><strong>1、Innodb和Myisam引擎</strong></h4><p><strong>Myisam：</strong>支持表锁，适合读密集的场景，不支持外键，不支持事务，索引与数据在不同的文件</p>
<p><strong>Innodb：</strong>支持行、表锁，默认为行锁，适合并发场景，支持外键，支持事务，索引与数据同一文件</p>
<h4 id="2、哈希索引"><a href="#2、哈希索引" class="headerlink" title="2、哈希索引"></a><strong>2、哈希索引</strong></h4><p> 哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存执该值所在行数据的物理位置，因为使用散列算法，因此访问速度非常快，但是一个值只能对应一个hashCode，而且是散列的分布方式，<strong>因此哈希索引不支持范围查找和排序的功能</strong></p>
<h4 id="3、B-树索引"><a href="#3、B-树索引" class="headerlink" title="3、B+树索引"></a><strong>3、B+树索引</strong></h4><p><strong>优点：</strong></p>
<p> B+树的磁盘读写代价低，更少的查询次数，查询效率更加稳定，有利于对数据库的扫描</p>
<p> B+树是B树的升级版，B+树只有叶节点存放数据，其余节点用来索引。索引节点可以全部加入内存，增加查询效率，叶子节点可以做双向链表，从而<strong>提高范围查找的效率，增加的索引的范围</strong></p>
<p> 在大规模数据存储的时候，红黑树往往出现由于<strong>树的深度过大</strong>而造成磁盘IO读写过于频繁，进而导致效率低下的情况。所以，只要我们通过某种较好的树结构减少树的结构尽量减少树的高度，B树与B+树可以有多个子女，从几十到上千，可以降低树的高度。</p>
<p> <strong>磁盘预读原理</strong>：将一个节点的大小设为等于一个页，这样每个节点只需要一次I&#x2F;O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证<strong>一个节点物理上也存储在一个页里</strong>，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I&#x2F;O。</p>
<h4 id="4、创建索引"><a href="#4、创建索引" class="headerlink" title="4、创建索引"></a>4、创建索引</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE  [UNIQUE | FULLTEXT]  INDEX  索引名 ON  表名(字段名) [USING 索引方法]；</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">UNIQUE:可选。表示索引为唯一性索引。</span><br><span class="line">FULLTEXT:可选。表示索引为全文索引 加速大文本。</span><br><span class="line">NORMAL：可选。加速查询操作，包括精确匹配、范围查询和排序。</span><br><span class="line">SPATIAL：可选。专门用于处理地理空间数据，支持几何数据类型。</span><br><span class="line">INDEX和KEY:用于指定字段为索引，两者选择其中之一就可以了，作用是一样的。</span><br><span class="line">索引名:可选。给创建的索引取一个新名称。</span><br><span class="line">字段名1:指定索引对应的字段的名称，该字段必须是前面定义好的字段。</span><br><span class="line">注：索引方法默认使用B+TREE。</span><br></pre></td></tr></table></figure>



<h4 id="5、聚簇索引和非聚簇索引"><a href="#5、聚簇索引和非聚簇索引" class="headerlink" title="5、聚簇索引和非聚簇索引"></a><strong>5、聚簇索引和非聚簇索引</strong></h4><p> <strong>聚簇索引：</strong>将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据（存储的是表的主键）（<strong>主键索引</strong>）</p>
<p> <strong>非聚簇索引：</strong>将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置（<strong>辅助索引</strong>）</p>
<p>聚集索引和非聚集索引的区别：<br>1.聚集索引中的非叶子节点存储的是表的主键，非聚集索引的非叶子节点存储的是自己设置的索引字段对应的值(如果是联合索引，那就是联合索引的几个字段对应的值)<br>2.聚集索引的叶子节点，存储着当前表中每条记录的所有信息；非聚集索引的叶子节点，只存储当前记录对应的主键ID(也就是聚集索引的非叶子节点存储的值)</p>
<h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>在MySQL的InnoDB存储引擎中，聚簇索引是自动管理的，不需要显式创建。以下是几种情况：</p>
<ol>
<li><p><strong>使用主键创建聚簇索引</strong>：</p>
<ul>
<li>如果在表定义时创建了主键，那么该主键会自动成为聚簇索引。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE my_table (</span><br><span class="line">    id INT PRIMARY KEY,</span><br><span class="line">    name VARCHAR(50),</span><br><span class="line">    age INT</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>id</code>列是主键，因此会自动成为聚簇索引。</p>
</li>
<li><p><strong>没有主键但有唯一非空索引</strong>：</p>
<ul>
<li>如果表中没有主键，但有一个唯一非空索引，那么这个唯一索引将成为聚簇索引。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE my_table (</span><br><span class="line">    id INT NOT NULL,</span><br><span class="line">    name VARCHAR(50) UNIQUE NOT NULL,</span><br><span class="line">    age INT</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>name</code>列是唯一且非空的，因此会成为聚簇索引。</p>
</li>
<li><p><strong>没有主键和唯一非空索引</strong>：</p>
<ul>
<li>如果表中既没有主键，也没有唯一非空索引，InnoDB会自动创建一个隐藏的聚簇索引。</li>
</ul>
</li>
</ol>
<h4 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h4><p>非聚簇索引需要显式创建，可以在创建表时定义，也可以在表创建后添加。</p>
<ol>
<li><p><strong>在创建表时定义非聚簇索引</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE my_table (</span><br><span class="line">    id INT PRIMARY KEY,</span><br><span class="line">    name VARCHAR(50),</span><br><span class="line">    age INT,</span><br><span class="line">    INDEX (name)</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>name</code>列上的索引是一个非聚簇索引。</p>
</li>
<li><p><strong>在表创建后添加非聚簇索引</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_name ON my_table(name);</span><br></pre></td></tr></table></figure>

<p>这个命令在<code>my_table</code>表的<code>name</code>列上创建了一个非聚簇索引。</p>
</li>
</ol>
<h4 id="6、最左前缀问题"><a href="#6、最左前缀问题" class="headerlink" title="6、最左前缀问题"></a>6、最左前缀问题</h4><p> 最左前缀原则主要使用在联合索引中，联合索引的B+Tree是按照第一个关键字进行索引排列的。</p>
<p> 联合索引的底层是一颗B+树，只不过联合索引的B+树节点中存储的是键值。由于构建一棵B+树只能根据一个值来确定索引关系，所以数据库依赖联合索引最左的字段来构建。</p>
<p> 采用&gt;、&lt;等进行匹配都会导致后面的列无法走索引，因为通过以上方式匹配到的数据是不可知的。</p>
<p><strong>创建索引时选择性高的列放在前面，以提高索引的效率。</strong></p>
<h3 id="SQL查询"><a href="#SQL查询" class="headerlink" title="SQL查询"></a>SQL查询</h3><h4 id="1、SQL语句的执行过程"><a href="#1、SQL语句的执行过程" class="headerlink" title="1、SQL语句的执行过程"></a><strong>1、SQL语句的执行过程</strong></h4><p><strong>查询语句：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student  A where A.age=&#x27;18&#x27; and A.name=&#x27;张三&#x27;;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/5be2a1549f0d5ac83e11e42bdbd2d94f10da13bb82baf6e593ee3f023282ed62/687474703a2f2f73302e6c677374617469632e636f6d2f692f696d616765322f4d30312f38422f30462f43676f744f56313479534b414d786f6841414832564863417a6b453631322e706e67"><img src="https://camo.githubusercontent.com/5be2a1549f0d5ac83e11e42bdbd2d94f10da13bb82baf6e593ee3f023282ed62/687474703a2f2f73302e6c677374617469632e636f6d2f692f696d616765322f4d30312f38422f30462f43676f744f56313479534b414d786f6841414832564863417a6b453631322e706e67" alt="img"></a></p>
<p>结合上面的说明，我们分析下这个语句的执行流程：</p>
<p>①通过客户端&#x2F;服务器通信协议与 MySQL 建立连接。并查询是否有权限</p>
<p>②Mysql8.0之前开看是否开启缓存，开启了 Query Cache 且命中完全相同的 SQL 语句，则将查询结果直接返回给客户端；</p>
<p>③由解析器进行语法语义解析，并生成解析树。如查询是select、表名tb_student、条件是id&#x3D;’1’</p>
<p>④查询优化器生成执行计划。根据索引看看是否可以优化</p>
<p>⑤查询执行引擎执行 SQL 语句，根据存储引擎类型，得到查询结果。若开启了 Query Cache，则缓存，否则直接返回。</p>
<h4 id="2、回表查询和覆盖索引"><a href="#2、回表查询和覆盖索引" class="headerlink" title="2、回表查询和覆盖索引"></a><strong>2、回表查询和覆盖索引</strong></h4><p>解释：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/CPLASF_/article/details/108799381">https://blog.csdn.net/CPLASF_/article/details/108799381</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Courage129/p/14166775.html">https://www.cnblogs.com/Courage129/p/14166775.html</a></p>
<p><strong>普通索引</strong>（唯一索引+联合索引+全文索引）需要扫描两遍索引树</p>
<p>（1）先通过普通索引定位到主键值id&#x3D;5；</p>
<p>（2）在通过聚集索引定位到行记录；</p>
<p>这就是所谓的<strong>回表查询</strong>，先定位主键值，再定位行记录，它的性能较扫一遍索引树更低。</p>
<p><strong>覆盖索引</strong>：主键索引&#x3D;&#x3D;聚簇索引&#x3D;&#x3D;覆盖索引</p>
<p> 如果where条件的列和返回的数据在一个索引中，那么不需要回查表，那么就叫覆盖索引。</p>
<p><strong>实现覆盖索引</strong>：常见的方法是，将被查询的字段，建立到联合索引里去。</p>
<h4 id="3、Explain及优化"><a href="#3、Explain及优化" class="headerlink" title="3、Explain及优化"></a>3、Explain及优化</h4><p>参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8fab76bbf448">https://www.jianshu.com/p/8fab76bbf448</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from staff;</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-------+</span><br><span class="line">|  1 | SIMPLE      | staff | ALL  | NULL          | 索引  | NULL    | NULL |    2 | NULL  |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-------+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure>



<p><strong>索引优化：</strong></p>
<p> ①最左前缀索引：like只用于’string%’，语句中的&#x3D;和in会动态调整顺序</p>
<p> ②唯一索引：唯一键区分度在0.1以上</p>
<p> ③无法使用索引：!&#x3D; 、is null 、 or、&gt;&lt; 、（<strong>5.7以后根据数量自动判定）in 、not in</strong></p>
<p> ④联合索引：避免select * ，查询列使用覆盖索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT uid From user Where gid = 2 order by ctime asc limit 10</span><br><span class="line">ALTER TABLE user add index idx_gid_ctime_uid(gid,ctime,uid) #创建联合覆盖索引，避免回表查询</span><br></pre></td></tr></table></figure>



<p><strong>语句优化：</strong></p>
<p> ①CHAR vs. VARCHAR</p>
<p>​	<strong>CHAR</strong>：固定长度字符类型，查询效率较高，因为每个值占用的空间是固定的。适合存储定长字符串。</p>
<p>​	<strong>VARCHAR</strong>：可变长度字符类型，第一个字节记录数据长度（在MySQL 5.0及以下版本中，第一个或两个字节记录长度，取决于		最大长度）。存储可变长度的字符串更节省空间，但在查询时由于长度不固定，可能稍慢于CHAR。</p>
<p> ②应该针对Explain中Rows增加索引</p>
<p> ③group&#x2F;order by字段均会涉及索引</p>
<p> ④Limit中分页查询会随着start值增大而变缓慢，通过子查询+表连接解决</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mytbl <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">100000</span>,<span class="number">10</span>  改进后的<span class="keyword">SQL</span>语句如下：</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mytbl <span class="keyword">where</span> id <span class="operator">&gt;=</span> ( <span class="keyword">select</span> id <span class="keyword">from</span> mytbl <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">100000</span>,<span class="number">1</span> ) limit <span class="number">10</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mytbl <span class="keyword">inner</span> ori <span class="keyword">join</span> (<span class="keyword">select</span> id <span class="keyword">from</span> mytbl <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">100000</span>,<span class="number">10</span>) <span class="keyword">as</span> tmp <span class="keyword">on</span> tmp.id<span class="operator">=</span>ori.id;</span><br></pre></td></tr></table></figure>

<p> ⑤count会进行全表扫描，如果估算可以使用explain</p>
<p> ⑥delete删除表时会增加大量undo和redo日志， 确定删除可使用trancate</p>
<p>​	</p>
<p><strong>表结构优化：</strong></p>
<p> ①单库不超过200张表</p>
<p> ②单表不超过500w数据</p>
<p> ③单表不超过40列</p>
<p> ④单表索引不超过5个</p>
<p><strong>数据库范式</strong> ：</p>
<p> ①第一范式（1NF）列不可分割</p>
<p> ②第二范式（2NF）属性完全依赖于主键 [ 消除部分子函数依赖 ]</p>
<p> ③第三范式（3NF）属性不依赖于其它非主属性 [ 消除传递依赖 ]</p>
<p>数据库范式（Normal Forms）是数据库设计中的重要概念，通过规范化规则确保数据库结构的合理性和有效性。以下是关于数据库第一范式（1NF）、第二范式（2NF）和第三范式（3NF）的详细解释：</p>
<h5 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h5><p><strong>定义</strong>：表中的每一列都是原子的，即每一个列值都是不可再分的基本数据项。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>每一列只能包含一个值，不能有重复的列。</li>
<li>表中的每一个字段必须是单一值，不允许有表或数组类型的字段。</li>
</ul>
<p><strong>示例</strong>：</p>
<p>不符合第一范式的表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plaintext复制代码| StudentID | Name       | Subjects        |</span><br><span class="line">|-----------|------------|-----------------|</span><br><span class="line">| 1         | Alice      | Math, Science   |</span><br><span class="line">| 2         | Bob        | Math, History   |</span><br></pre></td></tr></table></figure>

<p>符合第一范式的表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plaintext复制代码| StudentID | Name       | Subject   |</span><br><span class="line">|-----------|------------|-----------|</span><br><span class="line">| 1         | Alice      | Math      |</span><br><span class="line">| 1         | Alice      | Science   |</span><br><span class="line">| 2         | Bob        | Math      |</span><br><span class="line">| 2         | Bob        | History   |</span><br></pre></td></tr></table></figure>

<h5 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h5><p><strong>定义</strong>：在满足第一范式的基础上，表中的每一个非主键列必须完全依赖于主键，不能依赖于主键的一部分。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>必须已经满足1NF。</li>
<li>所有非主键列都完全依赖于主键，消除部分依赖。</li>
</ul>
<p><strong>示例</strong>：</p>
<p>不符合第二范式的表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plaintext复制代码| StudentID | CourseID | StudentName | CourseName |</span><br><span class="line">|-----------|----------|-------------|------------|</span><br><span class="line">| 1         | 101      | Alice       | Math       |</span><br><span class="line">| 2         | 102      | Bob         | History    |</span><br></pre></td></tr></table></figure>

<p>符合第二范式的表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">plaintext复制代码Students</span><br><span class="line">| StudentID | StudentName |</span><br><span class="line">|-----------|-------------|</span><br><span class="line">| 1         | Alice       |</span><br><span class="line">| 2         | Bob         |</span><br><span class="line"></span><br><span class="line">Courses</span><br><span class="line">| CourseID | CourseName |</span><br><span class="line">|----------|------------|</span><br><span class="line">| 101      | Math       |</span><br><span class="line">| 102      | History    |</span><br><span class="line"></span><br><span class="line">Enrollments</span><br><span class="line">| StudentID | CourseID |</span><br><span class="line">|-----------|----------|</span><br><span class="line">| 1         | 101      |</span><br><span class="line">| 2         | 102      |</span><br></pre></td></tr></table></figure>

<h5 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h5><p><strong>定义</strong>：在满足第二范式的基础上，表中的每一个非主键列必须直接依赖于主键，而不是通过其他非主键列传递依赖于主键。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>必须已经满足2NF。</li>
<li>消除传递依赖，即非主键列之间不应该有依赖关系，所有非主键列都应该直接依赖于主键。</li>
</ul>
<p><strong>示例</strong>：</p>
<p>不符合第三范式的表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plaintext复制代码| StudentID | StudentName | Advisor | AdvisorOffice |</span><br><span class="line">|-----------|-------------|---------|---------------|</span><br><span class="line">| 1         | Alice       | Dr. Smith | Room 101     |</span><br><span class="line">| 2         | Bob         | Dr. Jones | Room 102     |</span><br></pre></td></tr></table></figure>

<p>符合第三范式的表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">plaintext复制代码Students</span><br><span class="line">| StudentID | StudentName | AdvisorID |</span><br><span class="line">|-----------|-------------|-----------|</span><br><span class="line">| 1         | Alice       | 201       |</span><br><span class="line">| 2         | Bob         | 202       |</span><br><span class="line"></span><br><span class="line">Advisors</span><br><span class="line">| AdvisorID | AdvisorName | AdvisorOffice |</span><br><span class="line">|-----------|-------------|---------------|</span><br><span class="line">| 201       | Dr. Smith   | Room 101      |</span><br><span class="line">| 202       | Dr. Jones   | Room 102      |</span><br></pre></td></tr></table></figure>

<p>通过以上三个范式的规范化，可以避免数据冗余，提高数据的一致性和完整性。然而，在实际应用中，有时为了性能考虑，可能会适当地进行反规范化。了解和运用这些范式能够帮助设计出更高效、易维护的数据库结构。</p>
<p><strong>配置优化：</strong></p>
<p> 配置连接数、禁用Swap、增加内存、升级SSD硬盘</p>
<h4 id="4、JOIN查询"><a href="#4、JOIN查询" class="headerlink" title="4、JOIN查询"></a>4、JOIN查询</h4><p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/9ce7c502faf2ab3da4869e86c90b69fb9ef9d3d41d07e0847c4a642199eeaf56/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3237362f3738302f323736373830373538392d356331323235383661323363345f61727469636c6578"><img src="https://camo.githubusercontent.com/9ce7c502faf2ab3da4869e86c90b69fb9ef9d3d41d07e0847c4a642199eeaf56/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3237362f3738302f323736373830373538392d356331323235383661323363345f61727469636c6578" alt="img"></a></p>
<p><strong>left join(左联接)</strong> 返回包括左表中的所有记录和右表中关联字段相等的记录（返回左表中的所有行，无论右表中是否有匹配的行。如果右表没有匹配的行，右表的对应列将返回 <code>NULL</code>。）</p>
<p><strong>right join(右联接)</strong> 返回包括右表中的所有记录和左表中关联字段相等的记录（返回右表中的所有行，无论左表中是否有匹配的行。如果左表没有匹配的行，左表的对应列将返回 <code>NULL</code>。）</p>
<p><strong>inner join(等值连接)</strong> 只返回两个表中关联字段相等的行</p>
<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a><strong>集群</strong></h3><h4 id="1、主从复制过程"><a href="#1、主从复制过程" class="headerlink" title="1、主从复制过程"></a>1、主从复制过程</h4><p><strong>MySQl主从复制：</strong></p>
<ul>
<li><strong>原理</strong>：将主服务器的binlog日志复制到从服务器上执行一遍，达到主从数据的一致状态。</li>
<li><strong>过程</strong>：从库开启一个I&#x2F;O线程，向主库请求Binlog日志。主节点开启一个binlog dump线程，检查自己的二进制日志，并发送给从节点；从库将接收到的数据保存到中继日志（Relay log）中，另外开启一个SQL线程，把Relay中的操作在自身机器上执行一遍</li>
<li>优点<ul>
<li>作为备用数据库，并且不影响业务</li>
<li>可做读写分离，一个写库，一个或多个读库，在不同的服务器上，充分发挥服务器和数据库的性能，但要保证数据的一致性</li>
</ul>
</li>
</ul>
<p><strong>binlog记录格式：</strong>statement、row、mixed</p>
<p> 基于语句statement的复制、基于行row的复制、基于语句和行（mix）的复制。其中基于row的复制方式更能保证主从库数据的一致性，但日志量较大，在设置时考虑磁盘的空间问题</p>
<h4 id="2、数据一致性问题及解决方案"><a href="#2、数据一致性问题及解决方案" class="headerlink" title="2、数据一致性问题及解决方案"></a>2、数据一致性问题及解决方案</h4><p>“主从复制有延时”，这个延时期间读取从库，可能读到不一致的数据。</p>
<p><strong>缓存记录写key法：</strong></p>
<p> 在cache里记录哪些记录发生过的写请求，来路由读主库还是读从库</p>
<p><strong>异步复制：</strong></p>
<p> 在异步复制中，主库执行完操作后，写入binlog日志后，就返回客户端，这一动作就结束了，并不会验证从库有没有收到，完不完整，所以这样可能<strong>会造成数据的不一致</strong>。</p>
<p><strong>半同步复制：</strong></p>
<p> 当主库每提交一个事务后，不会立即返回，而是等待其中一个从库接收到Binlog并成功写入Relay-log中才返回客户端，通过一份在主库的Binlog，另一份在其中一个从库的Relay-log，可以保证了数据的安全性和一致性。</p>
<p><strong>全同步复制：</strong></p>
<p> 指当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。因为需要等待所有从库执行完该事务才能返回，所以全同步复制的<strong>性能必然会收到严重的影响</strong>。</p>
<h4 id="3、集群架构"><a href="#3、集群架构" class="headerlink" title="3、集群架构"></a>3、集群架构</h4><p><strong>Keepalived + VIP + MySQL 主从&#x2F;双主</strong></p>
<p> 当写节点 Master db1 出现故障时，由 MMM Monitor 或 Keepalived 触发切换脚本，将 VIP 漂移到可用的 Master db2 上。当出现网络抖动或网络分区时，MMM Monitor 会误判，严重时来回切换写 VIP 导致集群双写，当数据复制延迟时，应用程序会出现数据错乱或数据冲突的故障。有效避免单点失效的架构就是<strong>采用共享存储</strong>，单点故障切换可以通过<strong>分布式哨兵系统监控</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/c5ba81924cc27fec84a1b232d67053d3bbad3569607c8162fbb8338acb0856e0/687474703a2f2f73302e6c677374617469632e636f6d2f692f696d616765322f4d30312f38392f34382f43676f42356c31324b7547414c662d634141477548566d4d6b48733734332e706e67"><img src="https://camo.githubusercontent.com/c5ba81924cc27fec84a1b232d67053d3bbad3569607c8162fbb8338acb0856e0/687474703a2f2f73302e6c677374617469632e636f6d2f692f696d616765322f4d30312f38392f34382f43676f42356c31324b7547414c662d634141477548566d4d6b48733734332e706e67" alt="img"></a></p>
<p><strong>架构选型：</strong>MMM 集群 -&gt; MHA集群 -&gt; MHA+Arksentinel。</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/8debfd1e74e7b81fec83c5f736263c63be82db1b90ef843ff77cd149f3a75eaf/687474703a2f2f73302e6c677374617469632e636f6d2f692f696d616765322f4d30312f38392f36382f43676f744f5631324b754b41655f484f4141426c2d7752415461303737322e706e67"><img src="https://camo.githubusercontent.com/8debfd1e74e7b81fec83c5f736263c63be82db1b90ef843ff77cd149f3a75eaf/687474703a2f2f73302e6c677374617469632e636f6d2f692f696d616765322f4d30312f38392f36382f43676f744f5631324b754b41655f484f4141426c2d7752415461303737322e706e67" alt="img"></a></p>
<h4 id="4、故障转移和恢复"><a href="#4、故障转移和恢复" class="headerlink" title="4、故障转移和恢复"></a>4、故障转移和恢复</h4><p><strong>转移方式及恢复方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 虚拟IP或DNS服务 （Keepalived +VIP/DNS  和 MMM 架构）</span><br></pre></td></tr></table></figure>

<p> 问题：在虚拟 IP 运维过程中，刷新ARP过程中有时会出现一个 VIP 绑定在多台服务器同时提供连接的问题。这也是为什么要避免使用 Keepalived+VIP 和 MMM 架构的原因之一，因为它处理不了这类问题而导致集群多点写入。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. 提升备库为主库（MHA、QMHA）</span><br></pre></td></tr></table></figure>

<p> 尝试将原 Master 设置 read_only 为 on，避免集群多点写入。借助 binlog server 保留 Master 的 Binlog；当出现数据延迟时，再提升 Slave 为新 Master 之前需要进行数据补齐，否则会丢失数据。</p>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><h4 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h4><h5 id="如何进行分库分表"><a href="#如何进行分库分表" class="headerlink" title="如何进行分库分表"></a>如何进行分库分表</h5><blockquote>
<p><strong>分表</strong>用户id进行分表，每个表控制在300万数据。</p>
<p><strong>分库</strong>根据业务场景和地域分库，每个库并发不超过2000</p>
</blockquote>
<p><strong>Sharding-jdbc</strong> 这种 client 层方案的<strong>优点在于不用部署，运维成本低，不需要代理层的二次转发请求，性能很高</strong>，但是各个系统都需要<strong>耦合</strong> Sharding-jdbc 的依赖，升级比较麻烦</p>
<p><strong>Mycat</strong> 这种 proxy 层方案的<strong>缺点在于需要部署</strong>，自己运维一套中间件，运维成本高，但是<strong>好处在于对于各个项目是透明的</strong>，如果遇到升级之类的都是自己中间件那里搞就行了</p>
<p><strong>水平拆分</strong>：一个表放到多个库，分担高并发，加快查询速度</p>
<ul>
<li><strong>id</strong>保证业务在关联多张表时可以在同一库上操作</li>
<li><strong>range</strong>方便扩容和数据统计</li>
<li><strong>hash</strong>可以使得数据更加平均</li>
</ul>
<p><strong>垂直拆分</strong>：一个表拆成多个表，可以将一些冷数据拆分到冗余库中</p>
<blockquote>
<p>不是写瓶颈优先进行分表</p>
</blockquote>
<ul>
<li>分库数据间的数据无法再通过数据库直接查询了。会产生深分页的问题</li>
<li>分库越多，出现问题的可能性越大，维护成本也变得更高。</li>
<li>分库后无法保障跨库间事务，只能借助其他中间件实现最终一致性。</li>
</ul>
<p>分库首先需考虑满足业务最核心的场景：</p>
<p>1、订单数据按<strong>用户</strong>分库，可以<strong>提升用户的全流程体验</strong></p>
<p>2、超级客户导致<strong>数据倾斜</strong>可以使用最细粒度唯一标识进行hash拆分</p>
<p>3、按照最细粒度如订单号拆分以后，数据库就无法进行单库排重了</p>
<p>三个问题：</p>
<ul>
<li><p>富查询：采用分库分表之后，如何满足跨越分库的查询？<strong>使用ES</strong>的宽表</p>
<p>借助<strong>分库网关+分库业务</strong>虽然能够实现<strong>多维度查询的能力</strong>，但整体上性能不佳且对正常的写入请求有一定的影响。业界应对<strong>多维度实时查询</strong>的最常见方式便是借助 <strong>ElasticSearch</strong></p>
</li>
<li><p>数据倾斜：数据分库基础上再进行分表</p>
</li>
<li><p>分布式事务：跨多库的修改及多个微服务间的写操作导致的分布式事务问题？</p>
</li>
<li><p>深分页问题：按游标查询，或者叫每次查询都带上上一次查询经过排序后的最大 ID</p>
</li>
</ul>
<h3 id="查看当前线程操作"><a href="#查看当前线程操作" class="headerlink" title="查看当前线程操作"></a>查看当前线程操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">法一</span><br><span class="line"><span class="keyword">SHOW</span> PROCESSLIST;</span><br><span class="line">法二</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.PROCESSLIST;</span><br></pre></td></tr></table></figure>

<p><strong>完整查询</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">FULL</span> PROCESSLIST;</span><br></pre></td></tr></table></figure>

<p><strong>终止查询：</strong></p>
<ul>
<li><p>仅终止查询但不终止连接：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KILL QUERY Id;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>终止线程：</strong></p>
<ul>
<li><p>终止整个线程，包括连接：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KILL Id;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="表级锁和行级锁了解吗？有什么区别？"><a href="#表级锁和行级锁了解吗？有什么区别？" class="headerlink" title="表级锁和行级锁了解吗？有什么区别？"></a>表级锁和行级锁了解吗？有什么区别？</h3><ol>
<li>表级锁：粒度大，消耗资源少，加锁快，不会出现死锁，针对非索引字段，但是触发锁冲突概率高且并发下效率低。innodb和myisam都支持。</li>
<li>行级锁：粒度小，消耗资源大，加锁慢，会出现死锁，针对索引字段，但是并发下效率高，innodb支持</li>
</ol>
<h3 id="行级锁的使用有什么注意事项？"><a href="#行级锁的使用有什么注意事项？" class="headerlink" title="行级锁的使用有什么注意事项？"></a>行级锁的使用有什么注意事项？</h3><p>只针对索引字段生效，所以当update，delete时where子句没有命中索引的话会失效而会使用表级锁。</p>
<h3 id="InnDB有那些行级锁"><a href="#InnDB有那些行级锁" class="headerlink" title="InnDB有那些行级锁"></a>InnDB有那些行级锁</h3><ol>
<li>记录锁（record lock）：只锁住当前记录</li>
<li>间隙锁（gap lock）：锁住一个范围，不包括当前记录</li>
<li>临键锁 (next-key lock)：Record Lock+Gap Lock。锁住一个范围，包括当前记录。主要是为了解决幻读问题。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li>
</ol>
<p>在InnoDB默认的隔离级别（不可重复读）下，会有幻读的问题。因此当执行update，delete语句时，如果where子句不是命中<strong>唯一索引</strong>的话，会使用next-key lock方式。防止其他事务修改该记录，能保证当前事务执行时不会产生幻读问题。</p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20240722232804342.png" alt="image-20240722232804342"></p>
<h3 id="共享锁和排他锁呢？"><a href="#共享锁和排他锁呢？" class="headerlink" title="共享锁和排他锁呢？"></a>共享锁和排他锁呢？</h3><p><strong>不论是表级锁还是行级锁</strong>，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类</p>
<ul>
<li>共享锁：读锁S锁，事务在读取记录时会获取共享锁，允许多个事务同时获取（锁兼容）</li>
<li>排他锁：写锁X锁。事务写记录时获取，不允许事务同时获取（锁不兼容）</li>
</ul>
<p>排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">S 锁</th>
<th align="left">X 锁</th>
</tr>
</thead>
<tbody><tr>
<td align="left">S 锁</td>
<td align="left">不冲突</td>
<td align="left">冲突</td>
</tr>
<tr>
<td align="left">X 锁</td>
<td align="left">冲突</td>
<td align="left">冲突</td>
</tr>
</tbody></table>
<p>由于 MVCC（多版本并发控制） 的存在，对于一般的 <code>SELECT</code> 语句，InnoDB 不会加任何锁。不过， 你可以通过以下语句显式加共享锁或排他锁。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 共享锁 可以在 MySQL <span class="number">5.7</span> 和 MySQL <span class="number">8.0</span> 中使用</span><br><span class="line"><span class="keyword">SELECT</span> ... LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"># 共享锁 可以在 MySQL <span class="number">8.0</span> 中使用</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> SHARE;</span><br><span class="line"># 排他锁</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<h3 id="意向锁有什么作用"><a href="#意向锁有什么作用" class="headerlink" title="意向锁有什么作用?"></a>意向锁有什么作用?</h3><p>在并发下，如果有事务想要获取表级锁需要去判断该表是否有行级锁（事务一想要加表级锁并获取排他锁（写），而表中已经有事务二对一些行加了行级锁并获取了排他锁，这样事务一就会阻塞了）。需要一行行排查，效率底下。为了实现多粒度锁机制，所以有了意向锁，用来协调表锁和行锁。</p>
<p>意向锁是表锁：</p>
<ul>
<li>意向共享锁（IS）：当事务想对一些行加共享锁时，会对表加意向共享锁</li>
<li>意向排他锁（IX）：当事务想对一些行加排他锁时，会对表加意向排他锁</li>
</ul>
<p>意向共享锁和意向排他锁两两互相兼容</p>
<p>意向锁之间是互相兼容的。（不同事务锁住不同行就有会多个IS或者IX）</p>
<table>
<thead>
<tr>
<th></th>
<th>IS 锁</th>
<th>IX 锁</th>
</tr>
</thead>
<tbody><tr>
<td>IS 锁</td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr>
<td>IX 锁</td>
<td>兼容</td>
<td>兼容</td>
</tr>
</tbody></table>
<p>意向锁和共享锁和排它锁互斥（表级别的共享锁排他锁）</p>
<table>
<thead>
<tr>
<th>IS 锁</th>
<th>IX 锁</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>S 锁</td>
<td>兼容</td>
<td>互斥</td>
</tr>
<tr>
<td>X 锁</td>
<td>互斥</td>
<td>互斥</td>
</tr>
</tbody></table>
<h3 id="多个人同时往表里插数据，数据库表主键是自增，能正常执行吗？"><a href="#多个人同时往表里插数据，数据库表主键是自增，能正常执行吗？" class="headerlink" title="多个人同时往表里插数据，数据库表主键是自增，能正常执行吗？"></a>多个人同时往表里插数据，数据库表主键是自增，能正常执行吗？</h3><p>可以的，在多用户并发插入数据的情况下，MySQL InnoDB使用自增锁（auto-increment lock）来确保自增主键的唯一性。自增锁有两种模式：</p>
<p><strong>传统模式（Traditional Mode）</strong>：</p>
<ul>
<li>自增锁是在每次插入新行时获取，并在插入操作完成后立即释放。这确保了自增列值的连续性和唯一性。传统模式下，所有并发插入都会被串行化，以确保自增值的正确性。</li>
</ul>
<p><strong>互斥锁模式（Interleaved Mode）</strong>：</p>
<ul>
<li>自MySQL 5.1.22起，引入了互斥锁模式。它使用轻量级的互斥锁（mutex），允许多个事务同时分配自增值，而不需要完全串行化。这提高了并发插入的性能。互斥锁模式下，自增值可能不连续，但仍然是唯一的。</li>
</ul>
<p>	  </p>
</article></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">当</div><div class="author-info-description">live my life</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/bobbyfined"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/bobbyfined" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:15217299047@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">日常的随笔</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/02/13/%E4%BD%BF%E7%94%A8ollama%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAdeepseek/" title="使用ollama本地搭建deepseek"><img src="/img/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用ollama本地搭建deepseek"/></a><div class="content"><a class="title" href="/2025/02/13/%E4%BD%BF%E7%94%A8ollama%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAdeepseek/" title="使用ollama本地搭建deepseek">使用ollama本地搭建deepseek</a><time datetime="2025-02-13T06:32:22.000Z" title="发表于 2025-02-13 14:32:22">2025-02-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/08/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/" title="在Cursor中开发Java项目 -- 开发环境常用插件"><img src="/img/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="在Cursor中开发Java项目 -- 开发环境常用插件"/></a><div class="content"><a class="title" href="/2025/02/08/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/" title="在Cursor中开发Java项目 -- 开发环境常用插件">在Cursor中开发Java项目 -- 开发环境常用插件</a><time datetime="2025-02-08T12:35:22.000Z" title="发表于 2025-02-08 20:35:22">2025-02-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/08/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/" title="在Cursor中开发Java项目 -- 开发环境常用插件"><img src="/img/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="在Cursor中开发Java项目 -- 开发环境常用插件"/></a><div class="content"><a class="title" href="/2025/02/08/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/" title="在Cursor中开发Java项目 -- 开发环境常用插件">在Cursor中开发Java项目 -- 开发环境常用插件</a><time datetime="2025-02-08T12:32:22.000Z" title="发表于 2025-02-08 20:32:22">2025-02-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/18/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="多线程"><img src="/img/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="多线程"/></a><div class="content"><a class="title" href="/2024/12/18/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="多线程">多线程</a><time datetime="2024-12-18T12:14:36.000Z" title="发表于 2024-12-18 20:14:36">2024-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/01/ansible-playbook/" title="ansible-playbook"><img src="/img/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ansible-playbook"/></a><div class="content"><a class="title" href="/2024/12/01/ansible-playbook/" title="ansible-playbook">ansible-playbook</a><time datetime="2024-12-01T13:14:36.000Z" title="发表于 2024-12-01 21:14:36">2024-12-01</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            <a class="card-more-btn" href="/categories/" title="查看更多">
      <i class="fas fa-angle-right"></i></a>
          </div>
          <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/AI/"><span class="card-category-list-name">AI</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/GIT/"><span class="card-category-list-name">GIT</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Linux/"><span class="card-category-list-name">Linux</span><span class="card-category-list-count">3</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Redis/"><span class="card-category-list-name">Redis</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/ansible/"><span class="card-category-list-name">ansible</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/cursor/"><span class="card-category-list-name">cursor</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/java/"><span class="card-category-list-name">java</span><span class="card-category-list-count">16</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="card-category-list-name">操作系统</span><span class="card-category-list-count">1</span></a></li>
          </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 1.1em; color: #999">设计模式</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BD%BF%E7%94%A8/" style="font-size: 1.1em; color: #999">工具类使用</a> <a href="/tags/GIT/" style="font-size: 1.3em; color: #99a1ac">GIT</a> <a href="/tags/mysql/" style="font-size: 1.3em; color: #99a1ac">mysql</a> <a href="/tags/mybatis/" style="font-size: 1.2em; color: #999da3">mybatis</a> <a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 1.1em; color: #999">基础</a> <a href="/tags/jvm/" style="font-size: 1.1em; color: #999">jvm</a> <a href="/tags/deepseek/" style="font-size: 1.1em; color: #999">deepseek</a> <a href="/tags/%E6%A1%86%E6%9E%B6/" style="font-size: 1.4em; color: #99a5b6">框架</a> <a href="/tags/redis/" style="font-size: 1.1em; color: #999">redis</a> <a href="/tags/ansbile/" style="font-size: 1.1em; color: #999">ansbile</a> <a href="/tags/java/" style="font-size: 1.5em; color: #99a9bf">java</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 1.1em; color: #999">操作系统</a> <a href="/tags/ansible/" style="font-size: 1.1em; color: #999">ansible</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 1.1em; color: #999">多线程</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 1.1em; color: #999">网络</a> <a href="/tags/cursor/" style="font-size: 1.2em; color: #999da3">cursor</a> <a href="/tags/Linux/" style="font-size: 1.3em; color: #99a1ac">Linux</a> <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 1.1em; color: #999">面试题</a></div></div><div class="card-widget card-archives">
    <div class="item-headline">
      <i class="fas fa-archive"></i>
      <span>归档</span>
      <a class="card-more-btn" href="/archives/"
            title="查看更多">
            <i class="fas fa-angle-right"></i>
          </a>
    </div>
  
    <ul class="card-archive-list">
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/02/">
            <span class="card-archive-list-date">
              二月 2025
            </span>
            <span class="card-archive-list-count">3</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2024/12/">
            <span class="card-archive-list-date">
              十二月 2024
            </span>
            <span class="card-archive-list-count">2</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2024/10/">
            <span class="card-archive-list-date">
              十月 2024
            </span>
            <span class="card-archive-list-count">1</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2024/09/">
            <span class="card-archive-list-date">
              九月 2024
            </span>
            <span class="card-archive-list-count">2</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2024/08/">
            <span class="card-archive-list-date">
              八月 2024
            </span>
            <span class="card-archive-list-count">2</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2024/06/">
            <span class="card-archive-list-date">
              六月 2024
            </span>
            <span class="card-archive-list-count">1</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2024/05/">
            <span class="card-archive-list-date">
              五月 2024
            </span>
            <span class="card-archive-list-count">1</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2023/12/">
            <span class="card-archive-list-date">
              十二月 2023
            </span>
            <span class="card-archive-list-count">1</span>
          </a>
        </li>
      
    </ul>
  </div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站信息</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">34</div></div><div class="webinfo-item"><div class="item-name">本站总字数 :</div><div class="item-count">74.2k</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总浏览量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2025-02-16T14:45:18.735Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By 当</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>