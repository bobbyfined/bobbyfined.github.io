<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/title-boke.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/title-boke.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"1008610.xyz","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="MySQL篇">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL基础">
<meta property="og:url" content="http://1008610.xyz/2022/07/01/mysql/index.html">
<meta property="og:site_name" content="活页本">
<meta property="og:description" content="MySQL篇">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://camo.githubusercontent.com/cd14944dd2a162a3cc5ff7f769126d104281620ea41026b96b73b058862e5525/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676d616d3433623434626a333064393064346161372e6a7067">
<meta property="og:image" content="https://camo.githubusercontent.com/52f1c7041e734d0a78b73af0b6f593a5e4371fb7da13dbc3fdffa8c9ca7d84a5/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676d6171306a396f74646a3330707a30656e30766d2e6a7067">
<meta property="og:image" content="https://camo.githubusercontent.com/96885ec084dd4190ed377c82069748bde17edbbf6abc920a2da49873d52fb3cf/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676d61716337357936626a333077633064363075342e6a7067">
<meta property="og:image" content="https://camo.githubusercontent.com/f76c639d290aba63911606ba1168371bf87403a262711ed49c104170cf2a9662/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676d61717970373571736a333132713069387135662e6a7067">
<meta property="og:image" content="https://camo.githubusercontent.com/58747336811595da167be5bd93a23be0b220e6573eb6b9e51c3abfebed2afd88/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303865476d5a456c7931676d66686a6b766f35396a33307a753062346469622e6a7067">
<meta property="og:image" content="https://camo.githubusercontent.com/edd264822ed486a33a9262901b6a53a5cde3594012a2d41e83bf6ae57236ba9a/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303865476d5a456c7931676d6668766b3077777a6a33307565306834646c772e6a7067">
<meta property="og:image" content="https://camo.githubusercontent.com/e900373916040832996ceba751552f1c87722d42ab4fdf042ee84a32ed64a952/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303865476d5a456c7931676d66687777387a6d666a333075773067366e33372e6a7067">
<meta property="og:image" content="https://camo.githubusercontent.com/5be2a1549f0d5ac83e11e42bdbd2d94f10da13bb82baf6e593ee3f023282ed62/687474703a2f2f73302e6c677374617469632e636f6d2f692f696d616765322f4d30312f38422f30462f43676f744f56313479534b414d786f6841414832564863417a6b453631322e706e67">
<meta property="og:image" content="https://camo.githubusercontent.com/9ce7c502faf2ab3da4869e86c90b69fb9ef9d3d41d07e0847c4a642199eeaf56/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3237362f3738302f323736373830373538392d356331323235383661323363345f61727469636c6578">
<meta property="og:image" content="https://camo.githubusercontent.com/c5ba81924cc27fec84a1b232d67053d3bbad3569607c8162fbb8338acb0856e0/687474703a2f2f73302e6c677374617469632e636f6d2f692f696d616765322f4d30312f38392f34382f43676f42356c31324b7547414c662d634141477548566d4d6b48733734332e706e67">
<meta property="og:image" content="https://camo.githubusercontent.com/8debfd1e74e7b81fec83c5f736263c63be82db1b90ef843ff77cd149f3a75eaf/687474703a2f2f73302e6c677374617469632e636f6d2f692f696d616765322f4d30312f38392f36382f43676f744f5631324b754b41655f484f4141426c2d7752415461303737322e706e67">
<meta property="og:image" content="c:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20240722232804342.png">
<meta property="article:published_time" content="2022-07-01T06:14:36.000Z">
<meta property="article:modified_time" content="2025-02-07T15:00:37.947Z">
<meta property="article:author" content="当">
<meta property="article:tag" content="mysql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://camo.githubusercontent.com/cd14944dd2a162a3cc5ff7f769126d104281620ea41026b96b73b058862e5525/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676d616d3433623434626a333064393064346161372e6a7067">

<link rel="canonical" href="http://1008610.xyz/2022/07/01/mysql/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>MySQL基础 | 活页本</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">活页本</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://1008610.xyz/2022/07/01/mysql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="当">
      <meta itemprop="description" content="live my life">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="活页本">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL基础
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-01 14:14:36" itemprop="dateCreated datePublished" datetime="2022-07-01T14:14:36+08:00">2022-07-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-07 23:00:37" itemprop="dateModified" datetime="2025-02-07T23:00:37+08:00">2025-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="MySQL篇"><a href="#MySQL篇" class="headerlink" title="MySQL篇"></a>MySQL篇</h1><span id="more"></span>

<h3 id="WhyMysql？"><a href="#WhyMysql？" class="headerlink" title="WhyMysql？"></a>WhyMysql？</h3><p>NoSQL数据库四大家族</p>
<ul>
<li>列存储 Hbase</li>
<li>K-V存储 Redis</li>
<li>图像存储 Neo4j</li>
<li>文档存储 MongoDB</li>
</ul>
<p>云存储OSS</p>
<h4 id="海量Aerospike"><a href="#海量Aerospike" class="headerlink" title="海量Aerospike"></a>海量Aerospike</h4><p> Aerospike（简称AS）是一个分布式，可扩展的键值存储的NoSQL<strong>数据库</strong>。T级别大数据高并发的结构化<strong>数据存储，</strong>采用混合架构，索引存储在内存中，而数据可存储在机械硬盘(HDD)或固态硬盘(SSD) 上，读写操作达微妙级，99%的响应可在1毫秒内实现。</p>
<table>
<thead>
<tr>
<th></th>
<th>Aerospike</th>
<th>Redis</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>Nosql数据库</td>
<td>缓存</td>
</tr>
<tr>
<td>线程数</td>
<td>多线程</td>
<td>单线程</td>
</tr>
<tr>
<td>数据分片</td>
<td>自动处理相当于分片</td>
<td>提供分片算法、平衡各分片数据</td>
</tr>
<tr>
<td>数据扩容</td>
<td>动态增加数据卷平衡流量</td>
<td>需停机</td>
</tr>
<tr>
<td>数据同步</td>
<td>设置复制因子后可以透明的完成故障转移</td>
<td>手动故障转移和数据同步</td>
</tr>
<tr>
<td>载体</td>
<td>内存存储索引+SSD存储数据</td>
<td>内存</td>
</tr>
</tbody></table>
<p> Aerospike作为一个大容量的NoSql解决方案，适合对<strong>容量要求比较大，QPS相对低</strong>一些的场景，主要用在广告行业，<strong>个性化推荐厂告</strong>是建立在了和掌握消费者独特的偏好和习性的基础之上，对消费者的购买需求做出准确的预测或引导，在合适的位置、合适的时间，以合适的形式向消费者呈现与其需求高度吻合的广告，以此来促进用户的消费行为。</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/cd14944dd2a162a3cc5ff7f769126d104281620ea41026b96b73b058862e5525/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676d616d3433623434626a333064393064346161372e6a7067"><img src="https://camo.githubusercontent.com/cd14944dd2a162a3cc5ff7f769126d104281620ea41026b96b73b058862e5525/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676d616d3433623434626a333064393064346161372e6a7067" alt="image-20210103170039711"></a></p>
<p> （ETL数据仓库技术）抽取（extract）、转换（transform）、加载（load）</p>
<ul>
<li><p>用户行为日志收集系统收集日志之后推送到ETL做数据的清洗和转换</p>
</li>
<li><p>把ETL过后的数据发送到推荐引擎计算每个消费者的推荐结果，其中推荐逻辑包括规则和算法两部分</p>
</li>
<li><p>收集用户最近浏览、最长停留等特征，分析商品相似性、用户相似性、相似性等算法。</p>
</li>
<li><p>把推荐引擎的结果存入Aerospike集群中，并提供给广告投放引擎实时获取</p>
<p>分别通过HDFS和HBASE对日志进行离线和实时的分析，然后把用户画像的标签(tag : 程序猿、宅男…)结果存入高性能的Nosql数据库Aerospike中，同时把数据备份到异地数据中心。前端广告投放请求通过决策引擎（投放引擎）向用户画像数据库中读取相应的用户画像数据，然后根据竞价算法出价进行竞价。竞价成功之后就可以展现广告了。而在竞价成功之后，具体给用户展现什么样的广告，就是有上面说的个性化推荐广告来完成的。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Aerospike</th>
<th>Mysql</th>
</tr>
</thead>
<tbody><tr>
<td>库名</td>
<td>Namespace</td>
<td>Database</td>
</tr>
<tr>
<td>表名</td>
<td>Set</td>
<td>Table</td>
</tr>
<tr>
<td>记录</td>
<td>Bin</td>
<td>Column</td>
</tr>
<tr>
<td>字段</td>
<td>Record</td>
<td>Row</td>
</tr>
<tr>
<td>索引</td>
<td>key 、 pk 、kv</td>
<td>pk</td>
</tr>
</tbody></table>
<h4 id="图谱Neo4j"><a href="#图谱Neo4j" class="headerlink" title="图谱Neo4j"></a>图谱Neo4j</h4><blockquote>
<p>Neo4j是一个开源基于java开发的图形noSql数据库，它将结构化数据存储在图中而不是表中。它是一个嵌入式的、基于磁盘的、具备完全的事务特性的Java持久化引擎。程序数据是在一个面向对象的、灵活的网络结构下，而不是严格的表中，但具备完全的事务特性、企业级的数据库的所有好处。</p>
</blockquote>
<p>一种基于图的数据结构，由节点(Node)和边(Edge)组成。其中节点即实体，由一个全局唯一的ID标示，边就是关系用于连接两个节点。通俗地讲，知识图谱就是把所有不同种类的信息，连接在一起而得到的一个关系网络。知识图谱提供了从“关系”的角度去分析问题的能力。</p>
<p>互联网、大数据的背景下，谷歌、百度、搜狗等搜索引擎纷纷基于该背景，创建自己的知识图<strong>Knowledge Graph（谷歌</strong>）、<strong>知心（百度）和知立方（搜狗）</strong>，主要用于改进搜索质量。</p>
<p>自己项目主要用作好友推荐，图数据库(Graph database)指的是以图数据结构的形式来存储和查询数据的数据库。关系图谱中，关系的组织形式采用的就是图结构，所以非常适合用图库进行存储。</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/52f1c7041e734d0a78b73af0b6f593a5e4371fb7da13dbc3fdffa8c9ca7d84a5/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676d6171306a396f74646a3330707a30656e30766d2e6a7067"><img src="https://camo.githubusercontent.com/52f1c7041e734d0a78b73af0b6f593a5e4371fb7da13dbc3fdffa8c9ca7d84a5/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676d6171306a396f74646a3330707a30656e30766d2e6a7067" alt="image-20210103191540372"></a></p>
<p>优势总结:</p>
</li>
<li><p>性能上，使用cql查询，对长程关系的查询速度快</p>
</li>
<li><p>擅于发现隐藏的关系，例如通过判断图上两点之间有没有走的通的路径，就可以发现事物间的关联</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/96885ec084dd4190ed377c82069748bde17edbbf6abc920a2da49873d52fb3cf/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676d61716337357936626a333077633064363075342e6a7067"><img src="https://camo.githubusercontent.com/96885ec084dd4190ed377c82069748bde17edbbf6abc920a2da49873d52fb3cf/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676d61716337357936626a333077633064363075342e6a7067" alt="image-20210103192653004"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 查询三层级关系节点如下：with可以将前面查询结果作为后面查询条件</span><br><span class="line">match (na:Person)-[re]-(nb:Person) where na.name=&quot;林婉儿&quot; WITH na,re,nb match (nb:Person)- [re2:Friends]-&gt;(nc:Person) return na,re,nb,re2,nc</span><br><span class="line">// 直接拼接关系节点查询</span><br><span class="line">match data=(na:Person&#123;name:&quot;范闲&quot;&#125;)-[re]-&gt;(nb:Person)-[re2]-&gt;(nc:Person) return data</span><br><span class="line">// 使用深度运算符</span><br><span class="line">显然使用以上方式比较繁琐,可变数量的关系-&gt;节点可以使用-[:TYPE*minHops..maxHops]-。</span><br><span class="line">match data=(na:Person&#123;name:&quot;范闲&quot;&#125;)-[*1..2]-(nb:Person) return data</span><br></pre></td></tr></table></figure>



<h4 id="文档MongoDB"><a href="#文档MongoDB" class="headerlink" title="文档MongoDB"></a><strong>文档MongoDB</strong></h4><blockquote>
<p>MongoDB 是一个基于分布式文件存储的数据库，是非关系数据库中功能最丰富、最像关系数据库的。在高负载的情况下，通过添加更多的节点，可以保证服务器性能。由 C++ 编写，可以为 WEB 应用提供可扩展、高性能、易部署的数据存储解决方案。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/f76c639d290aba63911606ba1168371bf87403a262711ed49c104170cf2a9662/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676d61717970373571736a333132713069387135662e6a7067"><img src="https://camo.githubusercontent.com/f76c639d290aba63911606ba1168371bf87403a262711ed49c104170cf2a9662/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676d61717970373571736a333132713069387135662e6a7067" alt="image-20210103194830654"></a></p>
<p><strong>什么是BSON</strong></p>
<blockquote>
<p>{key:value,key2:value2}和Json类似，是一种二进制形式的存储格式，支持内嵌的文档对象和数组对象，但是BSON有JSON没有的一些数据类型，比如 value包括字符串,double,Array,DateBSON可以做为网络数据交换的一种存储形式,它的优点是灵活性高，但它的缺点是空间利用率不是很理想。</p>
</blockquote>
<p>BSON有三个特点：轻量性、可遍历性、高效性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 查询 find() 方法可以传入多个键(key)，每个键(key)以逗号隔开*/</span><br><span class="line">db.collection.find(&#123;key1:value1, key2:value2&#125;).pretty()</span><br><span class="line">/* 更新 $set ：设置字段值 $unset :删除指定字段 $inc：对修改的值进行自增*/</span><br><span class="line">db.collection.update(&#123;where&#125;,&#123;$set:&#123;字段名:值&#125;&#125;,&#123;multi:true&#125;)</span><br><span class="line">/* 删除 justOne :如果设为true，只删除一个文档，默认false，删除所有匹配条件的文档*/</span><br><span class="line">db.collection.remove(&#123;where&#125;, &#123;justOne: &lt;boolean&gt;, writeConcern: &lt;回执&gt; &#125; )</span><br></pre></td></tr></table></figure>



<p><strong>优点：</strong></p>
<ul>
<li><p><strong>文档结构的存储方式，能够更便捷的获取数据。</strong></p>
<p>对于一个层级式的数据结构来说，使用扁平式的，表状的结构来查询保存数据非常的困难。</p>
</li>
<li><p><strong>内置GridFS，支持大容量的存储。</strong></p>
<p>GridFS是一个出色的分布式文件系统，支持海量的数据存储，满足对大数据集的快速范围查询。</p>
</li>
<li><p><strong>性能优越</strong></p>
<p>千万级别的文档对象，近10G的数据，对有索引的ID的查询 不会比mysql慢，而对非索引字段的查询，则是全面胜出。 mysql实际无法胜任大数据量下任意字段的查询，而mongodb的查询性能实在牛逼。写入性能同样很令人满意，同样写入百万级别的数据，mongodb基本10分钟以下可以解决。</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>不支持事务</li>
<li>磁盘占用空间大</li>
</ul>
<h4 id="MySQL-8-0-版本"><a href="#MySQL-8-0-版本" class="headerlink" title="MySQL 8.0 版本"></a>MySQL 8.0 版本</h4><p><strong>1. 性能</strong>：MySQL 8.0 的速度要比 MySQL 5.7 快 2 倍。</p>
<p><strong>2. NoSQL</strong>：MySQL 从 5.7 版本开始提供 NoSQL 存储功能，在 8.0 版本中nosql得到了更大的改进。</p>
<p><strong>3. 窗口函数</strong>：实现若干新的查询方式。窗口函数与 SUM()、COUNT() 这种集合函数类似，但它不会将多行查询结果合并为一行，而是将结果放回多行当中，即窗口函数不需要 GROUP BY。</p>
<p><strong>4. 隐藏索引</strong>：在 MySQL 8.0 中，索引可以被“隐藏”和“显示”。当对索引进行隐藏时，它不会被查询优化器所使用。我们可以使用这个特性用于性能调试，例如我们先隐藏一个索引，然后观察其对数据库的影响。如果数据库性能有所下降，说明这个索引是有用的，然后将其“恢复显示”即可；如果数据库性能看不出变化，说明这个索引是多余的，可以考虑删掉。</p>
<h4 id="云存储"><a href="#云存储" class="headerlink" title="云存储"></a><strong>云存储</strong></h4><table>
<thead>
<tr>
<th></th>
<th>OSS</th>
<th>自建</th>
</tr>
</thead>
<tbody><tr>
<td>可靠性</td>
<td>可用性不低于99.995% 数据设计持久性不低于99.9999999999%（12个9）</td>
<td>受限于硬件可靠性，易出问题，一旦出现磁盘坏道，容易出现不可逆转的数据丢失。人工数据恢复困难、耗时、耗力。</td>
</tr>
<tr>
<td>安全</td>
<td>服务端加密、客户端加密、防盗链、IP黑白名单等。多用户资源隔离机制，支持异地容灾机制。</td>
<td>需要另外购买清洗和黑洞设备。需要单独实现安全机制。</td>
</tr>
<tr>
<td>成本</td>
<td>多线BGP骨干网络，无带宽限制，上行流量免费。无需运维人员与托管费用，0成本运维。</td>
<td>单线或双线接入速度慢，有带宽限制，峰值时期需人工扩容。需专人运维，成本高。</td>
</tr>
</tbody></table>
<p><strong>使用步骤</strong></p>
<p> 1、开通服务</p>
<p> 2、创建存储空间</p>
<p> 3、上传文件、下载文件、删除文件</p>
<p> 4、域名绑定、日志记录</p>
<p> 5、根据开放接口进行鉴权访问</p>
<p><strong>功能</strong></p>
<p> 图片编辑（裁剪、模糊、水印）</p>
<p> 视频截图</p>
<p> 音频转码、视频修复</p>
<p><strong>CDN加速</strong></p>
<p> 对象存储OSS与阿里云CDN服务结合，可优化静态热点文件下载加速的场景（即同一地区大量用户同时下载同一个静态文件的场景）。可以将OSS的存储空间（Bucket）作为源站，利用阿里云CDN将源内容发布到边缘节点。当大量终端用户重复访问同一文件时，可以直接从边缘节点获取已缓存的数据，提高访问的响应速度</p>
<h4 id="FastDFS"><a href="#FastDFS" class="headerlink" title="FastDFS"></a><strong>FastDFS</strong></h4><blockquote>
<p><strong>开源的轻量级分布式文件系统</strong>。它对文件进行管理，功能包括：<strong>文件存储、文件同步、文件访问</strong>（文件上传、文件下载）等，解决了<strong>大容量存储和负载均衡</strong>的问题。使用FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。如<strong>相册网站、视频网站</strong>等</p>
</blockquote>
<p><strong>扩展能力:</strong> 支持水平扩展，可以动态扩容；</p>
<p><strong>高可用性:</strong> 一是整个文件系统的可用性，二是数据的完整和一致性；</p>
<p><strong>弹性存储:</strong> 可以根据业务需要灵活地增删存储池中的资源，而不需要中断系统运行。</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/58747336811595da167be5bd93a23be0b220e6573eb6b9e51c3abfebed2afd88/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303865476d5a456c7931676d66686a6b766f35396a33307a753062346469622e6a7067"><img src="https://camo.githubusercontent.com/58747336811595da167be5bd93a23be0b220e6573eb6b9e51c3abfebed2afd88/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303865476d5a456c7931676d66686a6b766f35396a33307a753062346469622e6a7067" alt="image-20210107221022658"></a></p>
<p>特性</p>
<ul>
<li>和流行的web server无缝衔接，FastDFS已提供apache和nginx扩展模块</li>
<li>文件ID由FastDFS生成，作为文件访问凭证，FastDFS不需要传统的name server</li>
<li>分组存储，灵活简洁、对等结构，不存在单点</li>
<li>文件不分块存储，上传的文件和OS文件系统中的文件一一对应</li>
<li>中、小文件均可以很好支持，支持海量小文件存储</li>
<li>支持相同内容的文件只保存一份，节约磁盘空间</li>
<li>支持多块磁盘，支持单盘数据恢复</li>
<li>支持在线扩容 支持主从文件</li>
<li>下载文件支持多线程方式，支持断点续传</li>
</ul>
<p><strong>组成</strong></p>
<ul>
<li><p><strong>客户端（client）</strong></p>
<p>通过专有接口，使用TCP&#x2F;IP协议与跟踪器服务器或存储节点进行数据交互。</p>
</li>
<li><p><strong>跟踪器（tracker）</strong></p>
<p>Trackerserver作用是负载均衡和调度，通过Tracker server在文件上传时可以根据策略找到文件上传的地址。Tracker在访问上起负载均衡的作用。</p>
</li>
<li><p><strong>存储节点（storage）</strong></p>
<p>Storageserver作用是文件存储，客户端上传的文件最终存储在Storage服务器上，Storage server<strong>没有实现自己的文件系统而是利用操作系统的文件系统来管理文件</strong>。存储节点中的服务器均可以<strong>随时增加或下线而不会影响线上服务</strong>。</p>
</li>
</ul>
<p><strong>上传</strong></p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/edd264822ed486a33a9262901b6a53a5cde3594012a2d41e83bf6ae57236ba9a/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303865476d5a456c7931676d6668766b3077777a6a33307565306834646c772e6a7067"><img src="https://camo.githubusercontent.com/edd264822ed486a33a9262901b6a53a5cde3594012a2d41e83bf6ae57236ba9a/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303865476d5a456c7931676d6668766b3077777a6a33307565306834646c772e6a7067" alt="image-20210107222155291"></a></p>
<p><strong>下载</strong></p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/e900373916040832996ceba751552f1c87722d42ab4fdf042ee84a32ed64a952/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303865476d5a456c7931676d66687777387a6d666a333075773067366e33372e6a7067"><img src="https://camo.githubusercontent.com/e900373916040832996ceba751552f1c87722d42ab4fdf042ee84a32ed64a952/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303865476d5a456c7931676d66687777387a6d666a333075773067366e33372e6a7067" alt="image-20210107222312338"></a></p>
<p><strong>断点续传</strong></p>
<p> 续传涉及到的文件大小MD5不会改变。续传流程与文件上传类似，先<strong>定位到源storage</strong>，完成完整或部分上传，再<strong>通过binlog进行同group内server文件同步</strong>。</p>
<p><strong>配置优化</strong></p>
<p>配置文件：tracker.conf 和 storage.conf</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// FastDFS采用内存池的做法。 </span><br><span class="line">// v5.04对预分配采用增量方式，tracker一次预分配 1024个，storage一次预分配256个。 </span><br><span class="line">max_connections = 10240</span><br><span class="line">// 根据实际需要将 max_connections 设置为一个较大的数值，比如 10240 甚至更大。</span><br><span class="line">// 同时需要将一个进程允许打开的最大文件数调大</span><br><span class="line">vi /etc/security/limits.conf 重启系统生效 </span><br><span class="line">* soft nofile 65535 </span><br><span class="line">* hard nofile 65535</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">work_threads = 4 </span><br><span class="line">// 说明：为了避免CPU上下文切换的开销，以及不必要的资源消耗，不建议将本参数设置得过大。</span><br><span class="line">// 公式为： work_threads + (reader_threads + writer_threads) = CPU数</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 对于单盘挂载方式，磁盘读写线程分 别设置为 1即可 </span><br><span class="line">// 如果磁盘做了RAID，那么需要酌情加大读写线程数，这样才能最大程度地发挥磁盘性能</span><br><span class="line">disk_rw_separated：磁盘读写是否分离 </span><br><span class="line">disk_reader_threads：单个磁盘读线程数 </span><br><span class="line">disk_writer_threads：单个磁盘写线程数 </span><br></pre></td></tr></table></figure>



<p><strong>避免重复</strong></p>
<p> 如何避免文件重复上传 解决方案 上传成功后计算文件对应的MD5然后<strong>存入MySQL</strong>,添加文件时把<strong>文件MD5和之前存入MYSQL中的存储的信息对比</strong> 。DigestUtils.md5DigestAsHex(bytes)。</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="1、事务4大特性"><a href="#1、事务4大特性" class="headerlink" title="1、事务4大特性"></a><strong>1、事务4大特性</strong></h4><p><strong>事务4大特性：</strong>原子性、一致性、隔离性、持久性</p>
<p> <strong>原⼦性：</strong> 事务是最⼩的执⾏单位，不允许分割。事务的原⼦性确保动作要么全部完成，要么全不执行</p>
<p> <strong>一致性：</strong> 执⾏事务前后，数据保持⼀致，多个事务对同⼀个数据读取的结果是相同的；</p>
<p> <strong>隔离性：</strong> 并发访问数据库时，⼀个⽤户的事务不被其他事务所⼲扰，各并发事务之间数据库是独⽴的；</p>
<p> <strong>持久性：</strong> ⼀个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发⽣故障也不应该对其有任何影响。</p>
<p><strong>实现保证：</strong></p>
<p> MySQL的存储引擎InnoDB使用重做日志保证一致性与持久性，回滚日志保证原子性，使用各种锁来保证隔离性。</p>
<h4 id="2、事务隔离级别"><a href="#2、事务隔离级别" class="headerlink" title="2、事务隔离级别"></a><strong>2、事务隔离级别</strong></h4><p><strong>读未提交：</strong>最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p>
<p><strong>读已提交：</strong>允许读取并发事务已经提交的数据，可以阻⽌脏读，但是幻读或不可重复读仍有可能发⽣。</p>
<p><strong>可重复读：</strong>同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务⾃⼰所修改，可以阻⽌脏读和不可重复读，会有幻读。</p>
<p><strong>串行化：</strong>最⾼的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执⾏，这样事务之间就完全不可能产⽣⼲扰。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>并发问题</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交</td>
<td>可能会导致脏读、幻读或不可重复读</td>
</tr>
<tr>
<td>读已提交</td>
<td>可能会导致幻读或不可重复读</td>
</tr>
<tr>
<td>可重复读</td>
<td>可能会导致幻读</td>
</tr>
<tr>
<td>可串行化</td>
<td>不会产⽣⼲扰</td>
</tr>
</tbody></table>
<h4 id="3、默认隔离级别-RR"><a href="#3、默认隔离级别-RR" class="headerlink" title="3、默认隔离级别-RR"></a><strong>3、默认隔离级别-RR</strong></h4><p><strong>默认隔离级别：</strong>可重复读；</p>
<p> 同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务⾃⼰所修改；</p>
<p> 可重复读是有可能出现幻读的，如果要保证绝对的安全只能把隔离级别设置成SERIALIZABLE；这样所有事务都只能顺序执行，自然不会因为并发有什么影响了，但是性能会下降许多。</p>
<p> 第二种方式，使用MVCC解决<strong>快照读幻读问题</strong>（如简单select），读取的不是最新的数据。维护一个字段作为version，这样可以控制到每次只能有一个人更新一个版本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id from table_xx where id = ? and version = V</span><br><span class="line">update id from table_xx where id = ? and version = V+1</span><br></pre></td></tr></table></figure>



<p> 第三种方式，如果需要读最新的数据，可以通过GapLock+Next-KeyLock可以解决<strong>当前读幻读问题</strong>，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id from table_xx where id &gt; 100 for update;</span><br><span class="line">select id from table_xx where id &gt; 100 lock in share mode;</span><br></pre></td></tr></table></figure>

<h4 id="4、RR和RC使用场景"><a href="#4、RR和RC使用场景" class="headerlink" title="4、RR和RC使用场景"></a><strong>4、RR和RC使用场景</strong></h4><p> 事务隔离级别RC(read commit)和RR（repeatable read）两种事务隔离级别基于多版本并发控制MVCC(multi-version concurrency control）来实现。</p>
<table>
<thead>
<tr>
<th></th>
<th>RC</th>
<th>RR</th>
</tr>
</thead>
<tbody><tr>
<td>实现</td>
<td>多条查询语句会创建多个不同的ReadView</td>
<td>仅需要一个版本的ReadView</td>
</tr>
<tr>
<td>粒度</td>
<td>语句级读一致性</td>
<td>事务级读一致性</td>
</tr>
<tr>
<td>准确性</td>
<td>每次语句执行时间点的数据</td>
<td>第一条语句执行时间点的数据</td>
</tr>
</tbody></table>
<h4 id="5、行锁，表锁，意向锁（事务隔离时用到的）"><a href="#5、行锁，表锁，意向锁（事务隔离时用到的）" class="headerlink" title="5、行锁，表锁，意向锁（事务隔离时用到的）"></a><strong>5、行锁，表锁，意向锁</strong>（事务隔离时用到的）</h4><p><strong>InnoDB⽀持⾏级锁(row-level locking)和表级锁,默认为⾏级锁</strong></p>
<p> InnoDB按照不同的分类的锁：</p>
<p> 共享&#x2F;排它锁(Shared and Exclusive Locks)：行级别锁，</p>
<p> 意向锁(Intention Locks)：表级别锁</p>
<p> 间隙锁(Gap Locks)：锁定一个区间</p>
<p> 记录锁(Record Locks)：锁定一个行记录</p>
<p><strong>表级锁：（串行化）</strong></p>
<p> Mysql中锁定 粒度最大的一种锁，对当前操作的整张表加锁，实现简单 ，资源消耗也比较少，加锁快，不会出现死锁 。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。</p>
<p><strong>行级锁：（RR、RC）</strong></p>
<p> Mysql中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。 InnoDB支持的行级锁，包括如下几种：</p>
<p> <strong>记录锁（Record Lock）:</strong> 对索引项加锁，锁定<strong>符合条件的行</strong>。其他事务不能修改和删除加锁项；</p>
<p> <strong>间隙锁（Gap Lock）:</strong> 对索引项之间的“间隙”加锁，锁定<strong>记录的范围</strong>，不包含索引项本身，其他事务不能在锁范围内插入数据。</p>
<p> <strong>Next-key Lock：</strong> 锁定索引项本身和索引范围。即Record Lock和Gap Lock的结合。可解决幻读问题。</p>
<p>InnoDB 支持多粒度锁（multiple granularity locking），它允许行级锁与表级锁共存，而意向锁就是其中的一种表锁。</p>
<p><strong>共享锁</strong>（ shared lock, S ）锁允许持有锁读取行的事务。加锁时将自己和子节点全加S锁，父节点直到表头全加IS锁</p>
<p><strong>排他锁</strong>（ exclusive lock， X ）锁允许持有锁修改行的事务。 加锁时将自己和子节点全加X锁，父节点直到表头全加IX锁</p>
<p><strong>意向共享锁</strong>（intention shared lock, IS）：事务有意向对表中的某些行加<strong>共享锁</strong>（S锁）</p>
<p><strong>意向排他锁</strong>（intention exclusive lock, IX）：事务有意向对表中的某些行加<strong>排他锁</strong>（X锁）</p>
<table>
<thead>
<tr>
<th>互斥性</th>
<th>共享锁（S）</th>
<th>排它锁（X）</th>
<th>意向共享锁IS</th>
<th>意向排他锁IX</th>
</tr>
</thead>
<tbody><tr>
<td>共享锁（S）</td>
<td>✅</td>
<td>❌</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>排它锁（X）</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>意向共享锁IS</td>
<td>✅</td>
<td>❌</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>意向排他锁IX</td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
<td>✅</td>
</tr>
</tbody></table>
<h4 id="6、MVCC多版本并发控制"><a href="#6、MVCC多版本并发控制" class="headerlink" title="6、MVCC多版本并发控制"></a><strong>6、MVCC多版本并发控制</strong></h4><p> MVCC是一种多版本并发控制机制，通过事务的可见性看到自己预期的数据，能降低其系统开销.（RC和RR级别工作）</p>
<p> InnoDB的MVCC,是通过在每行记录后面保存系统版本号(可以理解为事务的ID)，每开始一个新的事务，系统版本号就会自动递增，事务开始时刻的系统版本号会作为事务的ID。这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的，防止幻读的产生。</p>
<p> 1.MVCC手段只适用于Msyql隔离级别中的读已提交（Read committed）和可重复读（Repeatable Read）.</p>
<p> 2.Read uncimmitted由于存在脏读，即能读到未提交事务的数据行，所以不适用MVCC.</p>
<p> 3.简单的select快照度不会加锁，删改及select for update等需要当前读的场景会加锁</p>
<p> 原因是MVCC的创建版本和删除版本只要在事务提交后才会产生。客观上，mysql使用的是乐观锁的一整实现方式，就是每行都有版本号，保存时根据版本号决定是否成功。Innodb的MVCC使用到的快照存储在Undo日志中，该日志通过回滚指针把一个数据行所有快照连接起来。</p>
<p><strong>版本链</strong></p>
<p>在InnoDB引擎表中，它的聚簇索引记录中有两个必要的隐藏列：</p>
<p><strong>trx_id</strong></p>
<p>这个id用来存储的每次对某条聚簇索引记录进行修改的时候的事务id。</p>
<p><strong>roll_pointer</strong></p>
<p>每次对哪条聚簇索引记录有修改的时候，都会把老版本写入undo日志中。这个roll_pointer就是存了一个指针，它指向这条聚簇索引记录的上一个版本的位置，通过它来获得上一个版本的记录信息。(注意插入操作的undo日志没有这个属性，因为它没有老版本)</p>
<p>每次修改都会在版本链中记录。<strong>SELECT可以去版本链中拿记录，这就实现了读-写，写-读的并发执行，</strong>提升了系统的性能。</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="1、Innodb和Myisam引擎"><a href="#1、Innodb和Myisam引擎" class="headerlink" title="1、Innodb和Myisam引擎"></a><strong>1、Innodb和Myisam引擎</strong></h4><p><strong>Myisam：</strong>支持表锁，适合读密集的场景，不支持外键，不支持事务，索引与数据在不同的文件</p>
<p><strong>Innodb：</strong>支持行、表锁，默认为行锁，适合并发场景，支持外键，支持事务，索引与数据同一文件</p>
<h4 id="2、哈希索引"><a href="#2、哈希索引" class="headerlink" title="2、哈希索引"></a><strong>2、哈希索引</strong></h4><p> 哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存执该值所在行数据的物理位置，因为使用散列算法，因此访问速度非常快，但是一个值只能对应一个hashCode，而且是散列的分布方式，<strong>因此哈希索引不支持范围查找和排序的功能</strong></p>
<h4 id="3、B-树索引"><a href="#3、B-树索引" class="headerlink" title="3、B+树索引"></a><strong>3、B+树索引</strong></h4><p><strong>优点：</strong></p>
<p> B+树的磁盘读写代价低，更少的查询次数，查询效率更加稳定，有利于对数据库的扫描</p>
<p> B+树是B树的升级版，B+树只有叶节点存放数据，其余节点用来索引。索引节点可以全部加入内存，增加查询效率，叶子节点可以做双向链表，从而<strong>提高范围查找的效率，增加的索引的范围</strong></p>
<p> 在大规模数据存储的时候，红黑树往往出现由于<strong>树的深度过大</strong>而造成磁盘IO读写过于频繁，进而导致效率低下的情况。所以，只要我们通过某种较好的树结构减少树的结构尽量减少树的高度，B树与B+树可以有多个子女，从几十到上千，可以降低树的高度。</p>
<p> <strong>磁盘预读原理</strong>：将一个节点的大小设为等于一个页，这样每个节点只需要一次I&#x2F;O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证<strong>一个节点物理上也存储在一个页里</strong>，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I&#x2F;O。</p>
<h4 id="4、创建索引"><a href="#4、创建索引" class="headerlink" title="4、创建索引"></a>4、创建索引</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE  [UNIQUE | FULLTEXT]  INDEX  索引名 ON  表名(字段名) [USING 索引方法]；</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">UNIQUE:可选。表示索引为唯一性索引。</span><br><span class="line">FULLTEXT:可选。表示索引为全文索引 加速大文本。</span><br><span class="line">NORMAL：可选。加速查询操作，包括精确匹配、范围查询和排序。</span><br><span class="line">SPATIAL：可选。专门用于处理地理空间数据，支持几何数据类型。</span><br><span class="line">INDEX和KEY:用于指定字段为索引，两者选择其中之一就可以了，作用是一样的。</span><br><span class="line">索引名:可选。给创建的索引取一个新名称。</span><br><span class="line">字段名1:指定索引对应的字段的名称，该字段必须是前面定义好的字段。</span><br><span class="line">注：索引方法默认使用B+TREE。</span><br></pre></td></tr></table></figure>



<h4 id="5、聚簇索引和非聚簇索引"><a href="#5、聚簇索引和非聚簇索引" class="headerlink" title="5、聚簇索引和非聚簇索引"></a><strong>5、聚簇索引和非聚簇索引</strong></h4><p> <strong>聚簇索引：</strong>将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据（存储的是表的主键）（<strong>主键索引</strong>）</p>
<p> <strong>非聚簇索引：</strong>将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置（<strong>辅助索引</strong>）</p>
<p>聚集索引和非聚集索引的区别：<br>1.聚集索引中的非叶子节点存储的是表的主键，非聚集索引的非叶子节点存储的是自己设置的索引字段对应的值(如果是联合索引，那就是联合索引的几个字段对应的值)<br>2.聚集索引的叶子节点，存储着当前表中每条记录的所有信息；非聚集索引的叶子节点，只存储当前记录对应的主键ID(也就是聚集索引的非叶子节点存储的值)</p>
<h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>在MySQL的InnoDB存储引擎中，聚簇索引是自动管理的，不需要显式创建。以下是几种情况：</p>
<ol>
<li><p><strong>使用主键创建聚簇索引</strong>：</p>
<ul>
<li>如果在表定义时创建了主键，那么该主键会自动成为聚簇索引。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE my_table (</span><br><span class="line">    id INT PRIMARY KEY,</span><br><span class="line">    name VARCHAR(50),</span><br><span class="line">    age INT</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>id</code>列是主键，因此会自动成为聚簇索引。</p>
</li>
<li><p><strong>没有主键但有唯一非空索引</strong>：</p>
<ul>
<li>如果表中没有主键，但有一个唯一非空索引，那么这个唯一索引将成为聚簇索引。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE my_table (</span><br><span class="line">    id INT NOT NULL,</span><br><span class="line">    name VARCHAR(50) UNIQUE NOT NULL,</span><br><span class="line">    age INT</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>name</code>列是唯一且非空的，因此会成为聚簇索引。</p>
</li>
<li><p><strong>没有主键和唯一非空索引</strong>：</p>
<ul>
<li>如果表中既没有主键，也没有唯一非空索引，InnoDB会自动创建一个隐藏的聚簇索引。</li>
</ul>
</li>
</ol>
<h4 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h4><p>非聚簇索引需要显式创建，可以在创建表时定义，也可以在表创建后添加。</p>
<ol>
<li><p><strong>在创建表时定义非聚簇索引</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE my_table (</span><br><span class="line">    id INT PRIMARY KEY,</span><br><span class="line">    name VARCHAR(50),</span><br><span class="line">    age INT,</span><br><span class="line">    INDEX (name)</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>name</code>列上的索引是一个非聚簇索引。</p>
</li>
<li><p><strong>在表创建后添加非聚簇索引</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_name ON my_table(name);</span><br></pre></td></tr></table></figure>

<p>这个命令在<code>my_table</code>表的<code>name</code>列上创建了一个非聚簇索引。</p>
</li>
</ol>
<h4 id="6、最左前缀问题"><a href="#6、最左前缀问题" class="headerlink" title="6、最左前缀问题"></a>6、最左前缀问题</h4><p> 最左前缀原则主要使用在联合索引中，联合索引的B+Tree是按照第一个关键字进行索引排列的。</p>
<p> 联合索引的底层是一颗B+树，只不过联合索引的B+树节点中存储的是键值。由于构建一棵B+树只能根据一个值来确定索引关系，所以数据库依赖联合索引最左的字段来构建。</p>
<p> 采用&gt;、&lt;等进行匹配都会导致后面的列无法走索引，因为通过以上方式匹配到的数据是不可知的。</p>
<p><strong>创建索引时选择性高的列放在前面，以提高索引的效率。</strong></p>
<h3 id="SQL查询"><a href="#SQL查询" class="headerlink" title="SQL查询"></a>SQL查询</h3><h4 id="1、SQL语句的执行过程"><a href="#1、SQL语句的执行过程" class="headerlink" title="1、SQL语句的执行过程"></a><strong>1、SQL语句的执行过程</strong></h4><p><strong>查询语句：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student  A where A.age=&#x27;18&#x27; and A.name=&#x27;张三&#x27;;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/5be2a1549f0d5ac83e11e42bdbd2d94f10da13bb82baf6e593ee3f023282ed62/687474703a2f2f73302e6c677374617469632e636f6d2f692f696d616765322f4d30312f38422f30462f43676f744f56313479534b414d786f6841414832564863417a6b453631322e706e67"><img src="https://camo.githubusercontent.com/5be2a1549f0d5ac83e11e42bdbd2d94f10da13bb82baf6e593ee3f023282ed62/687474703a2f2f73302e6c677374617469632e636f6d2f692f696d616765322f4d30312f38422f30462f43676f744f56313479534b414d786f6841414832564863417a6b453631322e706e67" alt="img"></a></p>
<p>结合上面的说明，我们分析下这个语句的执行流程：</p>
<p>①通过客户端&#x2F;服务器通信协议与 MySQL 建立连接。并查询是否有权限</p>
<p>②Mysql8.0之前开看是否开启缓存，开启了 Query Cache 且命中完全相同的 SQL 语句，则将查询结果直接返回给客户端；</p>
<p>③由解析器进行语法语义解析，并生成解析树。如查询是select、表名tb_student、条件是id&#x3D;’1’</p>
<p>④查询优化器生成执行计划。根据索引看看是否可以优化</p>
<p>⑤查询执行引擎执行 SQL 语句，根据存储引擎类型，得到查询结果。若开启了 Query Cache，则缓存，否则直接返回。</p>
<h4 id="2、回表查询和覆盖索引"><a href="#2、回表查询和覆盖索引" class="headerlink" title="2、回表查询和覆盖索引"></a><strong>2、回表查询和覆盖索引</strong></h4><p>解释：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/CPLASF_/article/details/108799381">https://blog.csdn.net/CPLASF_/article/details/108799381</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Courage129/p/14166775.html">https://www.cnblogs.com/Courage129/p/14166775.html</a></p>
<p><strong>普通索引</strong>（唯一索引+联合索引+全文索引）需要扫描两遍索引树</p>
<p>（1）先通过普通索引定位到主键值id&#x3D;5；</p>
<p>（2）在通过聚集索引定位到行记录；</p>
<p>这就是所谓的<strong>回表查询</strong>，先定位主键值，再定位行记录，它的性能较扫一遍索引树更低。</p>
<p><strong>覆盖索引</strong>：主键索引&#x3D;&#x3D;聚簇索引&#x3D;&#x3D;覆盖索引</p>
<p> 如果where条件的列和返回的数据在一个索引中，那么不需要回查表，那么就叫覆盖索引。</p>
<p><strong>实现覆盖索引</strong>：常见的方法是，将被查询的字段，建立到联合索引里去。</p>
<h4 id="3、Explain及优化"><a href="#3、Explain及优化" class="headerlink" title="3、Explain及优化"></a>3、Explain及优化</h4><p>参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8fab76bbf448">https://www.jianshu.com/p/8fab76bbf448</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from staff;</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-------+</span><br><span class="line">|  1 | SIMPLE      | staff | ALL  | NULL          | 索引  | NULL    | NULL |    2 | NULL  |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-------+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure>



<p><strong>索引优化：</strong></p>
<p> ①最左前缀索引：like只用于’string%’，语句中的&#x3D;和in会动态调整顺序</p>
<p> ②唯一索引：唯一键区分度在0.1以上</p>
<p> ③无法使用索引：!&#x3D; 、is null 、 or、&gt;&lt; 、（<strong>5.7以后根据数量自动判定）in 、not in</strong></p>
<p> ④联合索引：避免select * ，查询列使用覆盖索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT uid From user Where gid = 2 order by ctime asc limit 10</span><br><span class="line">ALTER TABLE user add index idx_gid_ctime_uid(gid,ctime,uid) #创建联合覆盖索引，避免回表查询</span><br></pre></td></tr></table></figure>



<p><strong>语句优化：</strong></p>
<p> ①CHAR vs. VARCHAR</p>
<p>​	<strong>CHAR</strong>：固定长度字符类型，查询效率较高，因为每个值占用的空间是固定的。适合存储定长字符串。</p>
<p>​	<strong>VARCHAR</strong>：可变长度字符类型，第一个字节记录数据长度（在MySQL 5.0及以下版本中，第一个或两个字节记录长度，取决于		最大长度）。存储可变长度的字符串更节省空间，但在查询时由于长度不固定，可能稍慢于CHAR。</p>
<p> ②应该针对Explain中Rows增加索引</p>
<p> ③group&#x2F;order by字段均会涉及索引</p>
<p> ④Limit中分页查询会随着start值增大而变缓慢，通过子查询+表连接解决</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mytbl <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">100000</span>,<span class="number">10</span>  改进后的<span class="keyword">SQL</span>语句如下：</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mytbl <span class="keyword">where</span> id <span class="operator">&gt;=</span> ( <span class="keyword">select</span> id <span class="keyword">from</span> mytbl <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">100000</span>,<span class="number">1</span> ) limit <span class="number">10</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mytbl <span class="keyword">inner</span> ori <span class="keyword">join</span> (<span class="keyword">select</span> id <span class="keyword">from</span> mytbl <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">100000</span>,<span class="number">10</span>) <span class="keyword">as</span> tmp <span class="keyword">on</span> tmp.id<span class="operator">=</span>ori.id;</span><br></pre></td></tr></table></figure>

<p> ⑤count会进行全表扫描，如果估算可以使用explain</p>
<p> ⑥delete删除表时会增加大量undo和redo日志， 确定删除可使用trancate</p>
<p>​	</p>
<p><strong>表结构优化：</strong></p>
<p> ①单库不超过200张表</p>
<p> ②单表不超过500w数据</p>
<p> ③单表不超过40列</p>
<p> ④单表索引不超过5个</p>
<p><strong>数据库范式</strong> ：</p>
<p> ①第一范式（1NF）列不可分割</p>
<p> ②第二范式（2NF）属性完全依赖于主键 [ 消除部分子函数依赖 ]</p>
<p> ③第三范式（3NF）属性不依赖于其它非主属性 [ 消除传递依赖 ]</p>
<p>数据库范式（Normal Forms）是数据库设计中的重要概念，通过规范化规则确保数据库结构的合理性和有效性。以下是关于数据库第一范式（1NF）、第二范式（2NF）和第三范式（3NF）的详细解释：</p>
<h5 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h5><p><strong>定义</strong>：表中的每一列都是原子的，即每一个列值都是不可再分的基本数据项。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>每一列只能包含一个值，不能有重复的列。</li>
<li>表中的每一个字段必须是单一值，不允许有表或数组类型的字段。</li>
</ul>
<p><strong>示例</strong>：</p>
<p>不符合第一范式的表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plaintext复制代码| StudentID | Name       | Subjects        |</span><br><span class="line">|-----------|------------|-----------------|</span><br><span class="line">| 1         | Alice      | Math, Science   |</span><br><span class="line">| 2         | Bob        | Math, History   |</span><br></pre></td></tr></table></figure>

<p>符合第一范式的表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plaintext复制代码| StudentID | Name       | Subject   |</span><br><span class="line">|-----------|------------|-----------|</span><br><span class="line">| 1         | Alice      | Math      |</span><br><span class="line">| 1         | Alice      | Science   |</span><br><span class="line">| 2         | Bob        | Math      |</span><br><span class="line">| 2         | Bob        | History   |</span><br></pre></td></tr></table></figure>

<h5 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h5><p><strong>定义</strong>：在满足第一范式的基础上，表中的每一个非主键列必须完全依赖于主键，不能依赖于主键的一部分。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>必须已经满足1NF。</li>
<li>所有非主键列都完全依赖于主键，消除部分依赖。</li>
</ul>
<p><strong>示例</strong>：</p>
<p>不符合第二范式的表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plaintext复制代码| StudentID | CourseID | StudentName | CourseName |</span><br><span class="line">|-----------|----------|-------------|------------|</span><br><span class="line">| 1         | 101      | Alice       | Math       |</span><br><span class="line">| 2         | 102      | Bob         | History    |</span><br></pre></td></tr></table></figure>

<p>符合第二范式的表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">plaintext复制代码Students</span><br><span class="line">| StudentID | StudentName |</span><br><span class="line">|-----------|-------------|</span><br><span class="line">| 1         | Alice       |</span><br><span class="line">| 2         | Bob         |</span><br><span class="line"></span><br><span class="line">Courses</span><br><span class="line">| CourseID | CourseName |</span><br><span class="line">|----------|------------|</span><br><span class="line">| 101      | Math       |</span><br><span class="line">| 102      | History    |</span><br><span class="line"></span><br><span class="line">Enrollments</span><br><span class="line">| StudentID | CourseID |</span><br><span class="line">|-----------|----------|</span><br><span class="line">| 1         | 101      |</span><br><span class="line">| 2         | 102      |</span><br></pre></td></tr></table></figure>

<h5 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h5><p><strong>定义</strong>：在满足第二范式的基础上，表中的每一个非主键列必须直接依赖于主键，而不是通过其他非主键列传递依赖于主键。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>必须已经满足2NF。</li>
<li>消除传递依赖，即非主键列之间不应该有依赖关系，所有非主键列都应该直接依赖于主键。</li>
</ul>
<p><strong>示例</strong>：</p>
<p>不符合第三范式的表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plaintext复制代码| StudentID | StudentName | Advisor | AdvisorOffice |</span><br><span class="line">|-----------|-------------|---------|---------------|</span><br><span class="line">| 1         | Alice       | Dr. Smith | Room 101     |</span><br><span class="line">| 2         | Bob         | Dr. Jones | Room 102     |</span><br></pre></td></tr></table></figure>

<p>符合第三范式的表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">plaintext复制代码Students</span><br><span class="line">| StudentID | StudentName | AdvisorID |</span><br><span class="line">|-----------|-------------|-----------|</span><br><span class="line">| 1         | Alice       | 201       |</span><br><span class="line">| 2         | Bob         | 202       |</span><br><span class="line"></span><br><span class="line">Advisors</span><br><span class="line">| AdvisorID | AdvisorName | AdvisorOffice |</span><br><span class="line">|-----------|-------------|---------------|</span><br><span class="line">| 201       | Dr. Smith   | Room 101      |</span><br><span class="line">| 202       | Dr. Jones   | Room 102      |</span><br></pre></td></tr></table></figure>

<p>通过以上三个范式的规范化，可以避免数据冗余，提高数据的一致性和完整性。然而，在实际应用中，有时为了性能考虑，可能会适当地进行反规范化。了解和运用这些范式能够帮助设计出更高效、易维护的数据库结构。</p>
<p><strong>配置优化：</strong></p>
<p> 配置连接数、禁用Swap、增加内存、升级SSD硬盘</p>
<h4 id="4、JOIN查询"><a href="#4、JOIN查询" class="headerlink" title="4、JOIN查询"></a>4、JOIN查询</h4><p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/9ce7c502faf2ab3da4869e86c90b69fb9ef9d3d41d07e0847c4a642199eeaf56/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3237362f3738302f323736373830373538392d356331323235383661323363345f61727469636c6578"><img src="https://camo.githubusercontent.com/9ce7c502faf2ab3da4869e86c90b69fb9ef9d3d41d07e0847c4a642199eeaf56/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3237362f3738302f323736373830373538392d356331323235383661323363345f61727469636c6578" alt="img"></a></p>
<p><strong>left join(左联接)</strong> 返回包括左表中的所有记录和右表中关联字段相等的记录（返回左表中的所有行，无论右表中是否有匹配的行。如果右表没有匹配的行，右表的对应列将返回 <code>NULL</code>。）</p>
<p><strong>right join(右联接)</strong> 返回包括右表中的所有记录和左表中关联字段相等的记录（返回右表中的所有行，无论左表中是否有匹配的行。如果左表没有匹配的行，左表的对应列将返回 <code>NULL</code>。）</p>
<p><strong>inner join(等值连接)</strong> 只返回两个表中关联字段相等的行</p>
<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a><strong>集群</strong></h3><h4 id="1、主从复制过程"><a href="#1、主从复制过程" class="headerlink" title="1、主从复制过程"></a>1、主从复制过程</h4><p><strong>MySQl主从复制：</strong></p>
<ul>
<li><strong>原理</strong>：将主服务器的binlog日志复制到从服务器上执行一遍，达到主从数据的一致状态。</li>
<li><strong>过程</strong>：从库开启一个I&#x2F;O线程，向主库请求Binlog日志。主节点开启一个binlog dump线程，检查自己的二进制日志，并发送给从节点；从库将接收到的数据保存到中继日志（Relay log）中，另外开启一个SQL线程，把Relay中的操作在自身机器上执行一遍</li>
<li>优点<ul>
<li>作为备用数据库，并且不影响业务</li>
<li>可做读写分离，一个写库，一个或多个读库，在不同的服务器上，充分发挥服务器和数据库的性能，但要保证数据的一致性</li>
</ul>
</li>
</ul>
<p><strong>binlog记录格式：</strong>statement、row、mixed</p>
<p> 基于语句statement的复制、基于行row的复制、基于语句和行（mix）的复制。其中基于row的复制方式更能保证主从库数据的一致性，但日志量较大，在设置时考虑磁盘的空间问题</p>
<h4 id="2、数据一致性问题及解决方案"><a href="#2、数据一致性问题及解决方案" class="headerlink" title="2、数据一致性问题及解决方案"></a>2、数据一致性问题及解决方案</h4><p>“主从复制有延时”，这个延时期间读取从库，可能读到不一致的数据。</p>
<p><strong>缓存记录写key法：</strong></p>
<p> 在cache里记录哪些记录发生过的写请求，来路由读主库还是读从库</p>
<p><strong>异步复制：</strong></p>
<p> 在异步复制中，主库执行完操作后，写入binlog日志后，就返回客户端，这一动作就结束了，并不会验证从库有没有收到，完不完整，所以这样可能<strong>会造成数据的不一致</strong>。</p>
<p><strong>半同步复制：</strong></p>
<p> 当主库每提交一个事务后，不会立即返回，而是等待其中一个从库接收到Binlog并成功写入Relay-log中才返回客户端，通过一份在主库的Binlog，另一份在其中一个从库的Relay-log，可以保证了数据的安全性和一致性。</p>
<p><strong>全同步复制：</strong></p>
<p> 指当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。因为需要等待所有从库执行完该事务才能返回，所以全同步复制的<strong>性能必然会收到严重的影响</strong>。</p>
<h4 id="3、集群架构"><a href="#3、集群架构" class="headerlink" title="3、集群架构"></a>3、集群架构</h4><p><strong>Keepalived + VIP + MySQL 主从&#x2F;双主</strong></p>
<p> 当写节点 Master db1 出现故障时，由 MMM Monitor 或 Keepalived 触发切换脚本，将 VIP 漂移到可用的 Master db2 上。当出现网络抖动或网络分区时，MMM Monitor 会误判，严重时来回切换写 VIP 导致集群双写，当数据复制延迟时，应用程序会出现数据错乱或数据冲突的故障。有效避免单点失效的架构就是<strong>采用共享存储</strong>，单点故障切换可以通过<strong>分布式哨兵系统监控</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/c5ba81924cc27fec84a1b232d67053d3bbad3569607c8162fbb8338acb0856e0/687474703a2f2f73302e6c677374617469632e636f6d2f692f696d616765322f4d30312f38392f34382f43676f42356c31324b7547414c662d634141477548566d4d6b48733734332e706e67"><img src="https://camo.githubusercontent.com/c5ba81924cc27fec84a1b232d67053d3bbad3569607c8162fbb8338acb0856e0/687474703a2f2f73302e6c677374617469632e636f6d2f692f696d616765322f4d30312f38392f34382f43676f42356c31324b7547414c662d634141477548566d4d6b48733734332e706e67" alt="img"></a></p>
<p><strong>架构选型：</strong>MMM 集群 -&gt; MHA集群 -&gt; MHA+Arksentinel。</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/8debfd1e74e7b81fec83c5f736263c63be82db1b90ef843ff77cd149f3a75eaf/687474703a2f2f73302e6c677374617469632e636f6d2f692f696d616765322f4d30312f38392f36382f43676f744f5631324b754b41655f484f4141426c2d7752415461303737322e706e67"><img src="https://camo.githubusercontent.com/8debfd1e74e7b81fec83c5f736263c63be82db1b90ef843ff77cd149f3a75eaf/687474703a2f2f73302e6c677374617469632e636f6d2f692f696d616765322f4d30312f38392f36382f43676f744f5631324b754b41655f484f4141426c2d7752415461303737322e706e67" alt="img"></a></p>
<h4 id="4、故障转移和恢复"><a href="#4、故障转移和恢复" class="headerlink" title="4、故障转移和恢复"></a>4、故障转移和恢复</h4><p><strong>转移方式及恢复方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 虚拟IP或DNS服务 （Keepalived +VIP/DNS  和 MMM 架构）</span><br></pre></td></tr></table></figure>

<p> 问题：在虚拟 IP 运维过程中，刷新ARP过程中有时会出现一个 VIP 绑定在多台服务器同时提供连接的问题。这也是为什么要避免使用 Keepalived+VIP 和 MMM 架构的原因之一，因为它处理不了这类问题而导致集群多点写入。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. 提升备库为主库（MHA、QMHA）</span><br></pre></td></tr></table></figure>

<p> 尝试将原 Master 设置 read_only 为 on，避免集群多点写入。借助 binlog server 保留 Master 的 Binlog；当出现数据延迟时，再提升 Slave 为新 Master 之前需要进行数据补齐，否则会丢失数据。</p>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><h4 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h4><h5 id="如何进行分库分表"><a href="#如何进行分库分表" class="headerlink" title="如何进行分库分表"></a>如何进行分库分表</h5><blockquote>
<p><strong>分表</strong>用户id进行分表，每个表控制在300万数据。</p>
<p><strong>分库</strong>根据业务场景和地域分库，每个库并发不超过2000</p>
</blockquote>
<p><strong>Sharding-jdbc</strong> 这种 client 层方案的<strong>优点在于不用部署，运维成本低，不需要代理层的二次转发请求，性能很高</strong>，但是各个系统都需要<strong>耦合</strong> Sharding-jdbc 的依赖，升级比较麻烦</p>
<p><strong>Mycat</strong> 这种 proxy 层方案的<strong>缺点在于需要部署</strong>，自己运维一套中间件，运维成本高，但是<strong>好处在于对于各个项目是透明的</strong>，如果遇到升级之类的都是自己中间件那里搞就行了</p>
<p><strong>水平拆分</strong>：一个表放到多个库，分担高并发，加快查询速度</p>
<ul>
<li><strong>id</strong>保证业务在关联多张表时可以在同一库上操作</li>
<li><strong>range</strong>方便扩容和数据统计</li>
<li><strong>hash</strong>可以使得数据更加平均</li>
</ul>
<p><strong>垂直拆分</strong>：一个表拆成多个表，可以将一些冷数据拆分到冗余库中</p>
<blockquote>
<p>不是写瓶颈优先进行分表</p>
</blockquote>
<ul>
<li>分库数据间的数据无法再通过数据库直接查询了。会产生深分页的问题</li>
<li>分库越多，出现问题的可能性越大，维护成本也变得更高。</li>
<li>分库后无法保障跨库间事务，只能借助其他中间件实现最终一致性。</li>
</ul>
<p>分库首先需考虑满足业务最核心的场景：</p>
<p>1、订单数据按<strong>用户</strong>分库，可以<strong>提升用户的全流程体验</strong></p>
<p>2、超级客户导致<strong>数据倾斜</strong>可以使用最细粒度唯一标识进行hash拆分</p>
<p>3、按照最细粒度如订单号拆分以后，数据库就无法进行单库排重了</p>
<p>三个问题：</p>
<ul>
<li><p>富查询：采用分库分表之后，如何满足跨越分库的查询？<strong>使用ES</strong>的宽表</p>
<p>借助<strong>分库网关+分库业务</strong>虽然能够实现<strong>多维度查询的能力</strong>，但整体上性能不佳且对正常的写入请求有一定的影响。业界应对<strong>多维度实时查询</strong>的最常见方式便是借助 <strong>ElasticSearch</strong></p>
</li>
<li><p>数据倾斜：数据分库基础上再进行分表</p>
</li>
<li><p>分布式事务：跨多库的修改及多个微服务间的写操作导致的分布式事务问题？</p>
</li>
<li><p>深分页问题：按游标查询，或者叫每次查询都带上上一次查询经过排序后的最大 ID</p>
</li>
</ul>
<h3 id="查看当前线程操作"><a href="#查看当前线程操作" class="headerlink" title="查看当前线程操作"></a>查看当前线程操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">法一</span><br><span class="line"><span class="keyword">SHOW</span> PROCESSLIST;</span><br><span class="line">法二</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.PROCESSLIST;</span><br></pre></td></tr></table></figure>

<p><strong>完整查询</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">FULL</span> PROCESSLIST;</span><br></pre></td></tr></table></figure>

<p><strong>终止查询：</strong></p>
<ul>
<li><p>仅终止查询但不终止连接：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KILL QUERY Id;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>终止线程：</strong></p>
<ul>
<li><p>终止整个线程，包括连接：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KILL Id;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="表级锁和行级锁了解吗？有什么区别？"><a href="#表级锁和行级锁了解吗？有什么区别？" class="headerlink" title="表级锁和行级锁了解吗？有什么区别？"></a>表级锁和行级锁了解吗？有什么区别？</h3><ol>
<li>表级锁：粒度大，消耗资源少，加锁快，不会出现死锁，针对非索引字段，但是触发锁冲突概率高且并发下效率低。innodb和myisam都支持。</li>
<li>行级锁：粒度小，消耗资源大，加锁慢，会出现死锁，针对索引字段，但是并发下效率高，innodb支持</li>
</ol>
<h3 id="行级锁的使用有什么注意事项？"><a href="#行级锁的使用有什么注意事项？" class="headerlink" title="行级锁的使用有什么注意事项？"></a>行级锁的使用有什么注意事项？</h3><p>只针对索引字段生效，所以当update，delete时where子句没有命中索引的话会失效而会使用表级锁。</p>
<h3 id="InnDB有那些行级锁"><a href="#InnDB有那些行级锁" class="headerlink" title="InnDB有那些行级锁"></a>InnDB有那些行级锁</h3><ol>
<li>记录锁（record lock）：只锁住当前记录</li>
<li>间隙锁（gap lock）：锁住一个范围，不包括当前记录</li>
<li>临键锁 (next-key lock)：Record Lock+Gap Lock。锁住一个范围，包括当前记录。主要是为了解决幻读问题。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li>
</ol>
<p>在InnoDB默认的隔离级别（不可重复读）下，会有幻读的问题。因此当执行update，delete语句时，如果where子句不是命中<strong>唯一索引</strong>的话，会使用next-key lock方式。防止其他事务修改该记录，能保证当前事务执行时不会产生幻读问题。</p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20240722232804342.png" alt="image-20240722232804342"></p>
<h3 id="共享锁和排他锁呢？"><a href="#共享锁和排他锁呢？" class="headerlink" title="共享锁和排他锁呢？"></a>共享锁和排他锁呢？</h3><p><strong>不论是表级锁还是行级锁</strong>，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类</p>
<ul>
<li>共享锁：读锁S锁，事务在读取记录时会获取共享锁，允许多个事务同时获取（锁兼容）</li>
<li>排他锁：写锁X锁。事务写记录时获取，不允许事务同时获取（锁不兼容）</li>
</ul>
<p>排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">S 锁</th>
<th align="left">X 锁</th>
</tr>
</thead>
<tbody><tr>
<td align="left">S 锁</td>
<td align="left">不冲突</td>
<td align="left">冲突</td>
</tr>
<tr>
<td align="left">X 锁</td>
<td align="left">冲突</td>
<td align="left">冲突</td>
</tr>
</tbody></table>
<p>由于 MVCC（多版本并发控制） 的存在，对于一般的 <code>SELECT</code> 语句，InnoDB 不会加任何锁。不过， 你可以通过以下语句显式加共享锁或排他锁。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 共享锁 可以在 MySQL <span class="number">5.7</span> 和 MySQL <span class="number">8.0</span> 中使用</span><br><span class="line"><span class="keyword">SELECT</span> ... LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"># 共享锁 可以在 MySQL <span class="number">8.0</span> 中使用</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> SHARE;</span><br><span class="line"># 排他锁</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<h3 id="意向锁有什么作用"><a href="#意向锁有什么作用" class="headerlink" title="意向锁有什么作用?"></a>意向锁有什么作用?</h3><p>在并发下，如果有事务想要获取表级锁需要去判断该表是否有行级锁（事务一想要加表级锁并获取排他锁（写），而表中已经有事务二对一些行加了行级锁并获取了排他锁，这样事务一就会阻塞了）。需要一行行排查，效率底下。为了实现多粒度锁机制，所以有了意向锁，用来协调表锁和行锁。</p>
<p>意向锁是表锁：</p>
<ul>
<li>意向共享锁（IS）：当事务想对一些行加共享锁时，会对表加意向共享锁</li>
<li>意向排他锁（IX）：当事务想对一些行加排他锁时，会对表加意向排他锁</li>
</ul>
<p>意向共享锁和意向排他锁两两互相兼容</p>
<p>意向锁之间是互相兼容的。（不同事务锁住不同行就有会多个IS或者IX）</p>
<table>
<thead>
<tr>
<th></th>
<th>IS 锁</th>
<th>IX 锁</th>
</tr>
</thead>
<tbody><tr>
<td>IS 锁</td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr>
<td>IX 锁</td>
<td>兼容</td>
<td>兼容</td>
</tr>
</tbody></table>
<p>意向锁和共享锁和排它锁互斥（表级别的共享锁排他锁）</p>
<table>
<thead>
<tr>
<th>IS 锁</th>
<th>IX 锁</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>S 锁</td>
<td>兼容</td>
<td>互斥</td>
</tr>
<tr>
<td>X 锁</td>
<td>互斥</td>
<td>互斥</td>
</tr>
</tbody></table>
<h3 id="多个人同时往表里插数据，数据库表主键是自增，能正常执行吗？"><a href="#多个人同时往表里插数据，数据库表主键是自增，能正常执行吗？" class="headerlink" title="多个人同时往表里插数据，数据库表主键是自增，能正常执行吗？"></a>多个人同时往表里插数据，数据库表主键是自增，能正常执行吗？</h3><p>可以的，在多用户并发插入数据的情况下，MySQL InnoDB使用自增锁（auto-increment lock）来确保自增主键的唯一性。自增锁有两种模式：</p>
<p><strong>传统模式（Traditional Mode）</strong>：</p>
<ul>
<li>自增锁是在每次插入新行时获取，并在插入操作完成后立即释放。这确保了自增列值的连续性和唯一性。传统模式下，所有并发插入都会被串行化，以确保自增值的正确性。</li>
</ul>
<p><strong>互斥锁模式（Interleaved Mode）</strong>：</p>
<ul>
<li>自MySQL 5.1.22起，引入了互斥锁模式。它使用轻量级的互斥锁（mutex），允许多个事务同时分配自增值，而不需要完全串行化。这提高了并发插入的性能。互斥锁模式下，自增值可能不连续，但仍然是唯一的。</li>
</ul>
<p>	  </p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>当
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://1008610.xyz/2022/07/01/mysql/" title="MySQL基础">http://1008610.xyz/2022/07/01/mysql/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/mysql/" rel="tag"># mysql</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/06/01/JAVA/" rel="prev" title="Java基础">
      <i class="fa fa-chevron-left"></i> Java基础
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/08/01/JVM/" rel="next" title="JVM基础">
      JVM基础 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-livere">livere</a></li>
            <li class="tab"><a href="#comment-utterances">utterances</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane livere" id="comment-livere">
              
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC82MDA4Ni8zNjU1Mg=="></div>
  </div>
  
            </div>
            <div class="tab-pane utterances" id="comment-utterances">
              <div class="comments" id="utterances-container"></div>
            </div>
        </div>
      </div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E7%AF%87"><span class="nav-number">1.</span> <span class="nav-text">MySQL篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#WhyMysql%EF%BC%9F"><span class="nav-number">1.0.1.</span> <span class="nav-text">WhyMysql？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%B7%E9%87%8FAerospike"><span class="nav-number">1.0.1.1.</span> <span class="nav-text">海量Aerospike</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E8%B0%B1Neo4j"><span class="nav-number">1.0.1.2.</span> <span class="nav-text">图谱Neo4j</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E6%A1%A3MongoDB"><span class="nav-number">1.0.1.3.</span> <span class="nav-text">文档MongoDB</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL-8-0-%E7%89%88%E6%9C%AC"><span class="nav-number">1.0.1.4.</span> <span class="nav-text">MySQL 8.0 版本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%91%E5%AD%98%E5%82%A8"><span class="nav-number">1.0.1.5.</span> <span class="nav-text">云存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FastDFS"><span class="nav-number">1.0.1.6.</span> <span class="nav-text">FastDFS</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.0.2.</span> <span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%BA%8B%E5%8A%A14%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">1.0.2.1.</span> <span class="nav-text">1、事务4大特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">1.0.2.2.</span> <span class="nav-text">2、事务隔离级别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E9%BB%98%E8%AE%A4%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB-RR"><span class="nav-number">1.0.2.3.</span> <span class="nav-text">3、默认隔离级别-RR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81RR%E5%92%8CRC%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.0.2.4.</span> <span class="nav-text">4、RR和RC使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E8%A1%8C%E9%94%81%EF%BC%8C%E8%A1%A8%E9%94%81%EF%BC%8C%E6%84%8F%E5%90%91%E9%94%81%EF%BC%88%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E6%97%B6%E7%94%A8%E5%88%B0%E7%9A%84%EF%BC%89"><span class="nav-number">1.0.2.5.</span> <span class="nav-text">5、行锁，表锁，意向锁（事务隔离时用到的）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81MVCC%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="nav-number">1.0.2.6.</span> <span class="nav-text">6、MVCC多版本并发控制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95"><span class="nav-number">1.0.3.</span> <span class="nav-text">索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81Innodb%E5%92%8CMyisam%E5%BC%95%E6%93%8E"><span class="nav-number">1.0.3.1.</span> <span class="nav-text">1、Innodb和Myisam引擎</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95"><span class="nav-number">1.0.3.2.</span> <span class="nav-text">2、哈希索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81B-%E6%A0%91%E7%B4%A2%E5%BC%95"><span class="nav-number">1.0.3.3.</span> <span class="nav-text">3、B+树索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="nav-number">1.0.3.4.</span> <span class="nav-text">4、创建索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="nav-number">1.0.3.5.</span> <span class="nav-text">5、聚簇索引和非聚簇索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="nav-number">1.0.3.6.</span> <span class="nav-text">聚簇索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="nav-number">1.0.3.7.</span> <span class="nav-text">非聚簇索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E9%97%AE%E9%A2%98"><span class="nav-number">1.0.3.8.</span> <span class="nav-text">6、最左前缀问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.0.4.</span> <span class="nav-text">SQL查询</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81SQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">1.0.4.1.</span> <span class="nav-text">1、SQL语句的执行过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%92%8C%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="nav-number">1.0.4.2.</span> <span class="nav-text">2、回表查询和覆盖索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81Explain%E5%8F%8A%E4%BC%98%E5%8C%96"><span class="nav-number">1.0.4.3.</span> <span class="nav-text">3、Explain及优化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F%EF%BC%881NF%EF%BC%89"><span class="nav-number">1.0.4.3.1.</span> <span class="nav-text">第一范式（1NF）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F%EF%BC%882NF%EF%BC%89"><span class="nav-number">1.0.4.3.2.</span> <span class="nav-text">第二范式（2NF）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F%EF%BC%883NF%EF%BC%89"><span class="nav-number">1.0.4.3.3.</span> <span class="nav-text">第三范式（3NF）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81JOIN%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.0.4.4.</span> <span class="nav-text">4、JOIN查询</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4"><span class="nav-number">1.0.5.</span> <span class="nav-text">集群</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B"><span class="nav-number">1.0.5.1.</span> <span class="nav-text">1、主从复制过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.0.5.2.</span> <span class="nav-text">2、数据一致性问题及解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84"><span class="nav-number">1.0.5.3.</span> <span class="nav-text">3、集群架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E5%92%8C%E6%81%A2%E5%A4%8D"><span class="nav-number">1.0.5.4.</span> <span class="nav-text">4、故障转移和恢复</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">1.0.6.</span> <span class="nav-text">面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="nav-number">1.0.6.1.</span> <span class="nav-text">分库分表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="nav-number">1.0.6.1.1.</span> <span class="nav-text">如何进行分库分表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C"><span class="nav-number">1.0.7.</span> <span class="nav-text">查看当前线程操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E7%BA%A7%E9%94%81%E5%92%8C%E8%A1%8C%E7%BA%A7%E9%94%81%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.0.8.</span> <span class="nav-text">表级锁和行级锁了解吗？有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9F"><span class="nav-number">1.0.9.</span> <span class="nav-text">行级锁的使用有什么注意事项？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnDB%E6%9C%89%E9%82%A3%E4%BA%9B%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="nav-number">1.0.10.</span> <span class="nav-text">InnDB有那些行级锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E6%8E%92%E4%BB%96%E9%94%81%E5%91%A2%EF%BC%9F"><span class="nav-number">1.0.11.</span> <span class="nav-text">共享锁和排他锁呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%84%8F%E5%90%91%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="nav-number">1.0.12.</span> <span class="nav-text">意向锁有什么作用?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA%E4%BA%BA%E5%90%8C%E6%97%B6%E5%BE%80%E8%A1%A8%E9%87%8C%E6%8F%92%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E4%B8%BB%E9%94%AE%E6%98%AF%E8%87%AA%E5%A2%9E%EF%BC%8C%E8%83%BD%E6%AD%A3%E5%B8%B8%E6%89%A7%E8%A1%8C%E5%90%97%EF%BC%9F"><span class="nav-number">1.0.13.</span> <span class="nav-text">多个人同时往表里插数据，数据库表主键是自增，能正常执行吗？</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="当"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">当</p>
  <div class="site-description" itemprop="description">live my life</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/bobbyfined" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;bobbyfined" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://baidu.com/" title="https:&#x2F;&#x2F;baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
    </ul>
  </div>

      </div>
      <!--网易云插件-->
      <!--
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 
        src="//music.163.com/outchain/player?type=2&id=2135473788&auto=1&height=66">
      </iframe>
      -->

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2024-08 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">当</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">119k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:48</span>
</div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

<script>
NexT.utils.loadComments(document.querySelector('#utterances-container'), () => {
    // if (typeof parcelRequire === 'function') { return; }
    var js = document.createElement('script');
    js.type = 'text/javascript';
    js.src = 'https://utteranc.es/client.js';
    js.async = true;
    js.crossorigin = 'anonymous';
    js.setAttribute('repo', 'bobbyfined/boke-comments');
    js.setAttribute('issue-term', 'pathname');
    js.setAttribute('theme', 'github-light');
    document.getElementById('utterances-container').appendChild(js);
});
</script>
  
  
    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas>
    <script src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
    <script src="/js/cursor/explosion.min.js"></script>
  



</body>
</html>
