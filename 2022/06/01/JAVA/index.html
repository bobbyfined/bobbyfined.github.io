<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java基础 | 活页本</title><meta name="author" content="当"><meta name="copyright" content="当"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java基础">
<meta property="og:type" content="website">
<meta property="og:title" content="Java基础">
<meta property="og:url" content="http://1008610.xyz/2022/06/01/JAVA/index.html">
<meta property="og:site_name" content="活页本">
<meta property="og:description" content="Java基础">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://1008610.xyz/img/butterfly-icon.png">
<meta property="article:published_time" content="2022-06-01T13:14:36.000Z">
<meta property="article:modified_time" content="2025-02-07T15:03:56.180Z">
<meta property="article:author" content="当">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://1008610.xyz/img/butterfly-icon.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://1008610.xyz/2022/06/01/JAVA/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础',
  isHighlightShrink: false,
  isToc: false,
  pageType: 'title'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="page" id="body-wrap"><header class="not-home-page" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">活页本</span></a></span><div id="menus"></div></nav><div id="page-site-info"><h1 id="site-title">Java基础</h1></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><span id="more"></span>

<h2 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h2><p><strong>封装，继承，多态</strong></p>
<ul>
<li><strong>封装</strong>：将数据和基于数据的操作抽象化成一个对象并对其属性进行私有化，同时提供一些能被外界访问属性的方法；</li>
<li><strong>继承</strong>：子类扩展新的功能，并复用父类的属性和功能，单继承，多实现、</li>
<li><strong>多态</strong>：一个父类可以有多个子类（对同一方法进行多次重写），一个接口可以有多个实现，一个类可以实现多个接口（对接口进行不同的实现）</li>
</ul>
<h2 id="java与C-区别（都是面向对象）"><a href="#java与C-区别（都是面向对象）" class="headerlink" title="java与C++区别（都是面向对象）"></a>java与C++区别（都是面向对象）</h2><p>C++: 多继承，有指针概念可以手动管理内存</p>
<p>java：单继承但是有多实现，由JVM自动管理内存</p>
<h2 id="多态实现原理"><a href="#多态实现原理" class="headerlink" title="多态实现原理"></a>多态实现原理</h2><p>动态绑定，即在运行时才把方法调用与方法实现关联起来。</p>
<p><strong>静态绑定</strong>：编译时就绑定，比如重载。<br><strong>动态绑定</strong>：运行时绑定，比如重写，实现。</p>
<h2 id="static和final关键字"><a href="#static和final关键字" class="headerlink" title="static和final关键字"></a>static和final关键字</h2><ul>
<li><strong>static</strong>：修饰属性，方法（只会在堆中创建一份共享，随着类的加载而加载）</li>
<li><strong>final</strong>：修饰变量（修饰基础类型就不可被修改，修饰引用类型就不可被指向另一个对象），方法（锁定方法防止被子类重写，private方法隐式设置了final），类（不能被继承且所有方法被指定为final）</li>
</ul>
<h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><p><strong>抽象类</strong>：abstract修饰的类，即包含抽象方法的类。（有抽象方法的类一定是抽象类，但是抽象类不是一定要有抽象方法）；只能被继承（单继承）所以不能被final修饰；不能被实例化（因为可能有没提供完整的实现的方法）</p>
<p><strong>接口</strong>：interface修饰，属于抽象类型的类。。可以被多实现。不可以被实例化（有没提供完整的实现的方法）</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><h4 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a><strong>相同点：</strong></h4><ol>
<li>都不能被实例化</li>
<li>都可以定义抽象方法且子类必须重写</li>
</ol>
<h4 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a><strong>不同点：</strong></h4><ol>
<li>抽象类可以有普通方法，接口只能有抽象方法（默认是public abstract修饰，在java8之后，能存在被default和static修饰的存在方法体的方法）</li>
<li>抽象类有构造方法（可以初始化对象状态），接口没有</li>
<li>抽象类只能被单继承，接口可以被多实现</li>
<li>抽象类可以有不同修饰的成员变量，接口默认都是public static final 修饰</li>
</ol>
<h3 id="适合场景"><a href="#适合场景" class="headerlink" title="适合场景"></a><strong>适合场景</strong></h3><p><strong>抽象类</strong>：</p>
<pre><code>1. 需要有基础功能并且基础功能会经常改变，那就使用抽象类，改变抽象类的基础方法就能让所有子类同时改变，达到解耦的目的。（如果是接口就需要改变每一个实现类中的方法）
1. 拥有一些方法（但不再乎其如何实现）并且想让它们中的一些有默认实现，还想拥有实例变量，需要构造方法。
</code></pre>
<p><strong>接口</strong>：</p>
<ol>
<li>需要多实现的场景（更多需要从业务出发，每个接口涉及不同业务，但是实现类需要涉及两个业务）</li>
<li>需要解耦更加彻底的场景。根据不同条件获取不同实现的场景，用接口可以实现解耦（调用类只需要注入接口不要关心具体要用那个实现类）</li>
</ol>
<h2 id="泛型与泛型擦除"><a href="#泛型与泛型擦除" class="headerlink" title="泛型与泛型擦除"></a>泛型与泛型擦除</h2><p>泛型： 参数化类型，将所需要的类型参数化，用<T>来声明一个类型参数。可以用于类、接口、方法的创建</p>
<p>泛型擦除：java泛型是伪泛型，虽然使用泛型的时候加上类型参数（比如ArrayList<Integer> list &#x3D; new ArrayList<Integer>();）但是编译生成字节码的时候会类型擦除（实际上变成了List）。而由泛型附加的类型信息对 JVM 来说是不可见的。因此说是伪泛型。可以通过反射添加其它类型元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">list.add(1);  //这样调用 add 方法只能存储整形，因为泛型类型的实例为 Integer</span><br><span class="line"></span><br><span class="line">//使用反射想Integer类型中加入String的记录</span><br><span class="line">list.getClass().getMethod(&quot;add&quot;, Object.class).invoke(list, &quot;asd&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p><strong>概念</strong>：在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且都能够调用它的任意一个方法；</p>
<p><strong>如何得到Class的实例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.类名.class(就是一份字节码)</span><br><span class="line">2.Class.forName(String className);根据一个类的全限定名来构建Class对象</span><br><span class="line">3.每一个对象多有getClass()方法:obj.getClass();返回对象的真实类型</span><br></pre></td></tr></table></figure>

<p><strong>适合场景：</strong></p>
<ol>
<li><strong>自定义注解</strong>：对被注解对象的操作需要用反射来执行</li>
<li><strong>动态代理</strong>：AOP中拦截方法使用动态代理就需要反射</li>
<li><strong>开发通用框架</strong></li>
</ol>
<h2 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h2><p><strong>Throwable</strong>是超类，往下分为<strong>Error</strong>和<strong>Exception</strong><br>一般来讲，程序无法捕获的异常就是Error，如JVM内部错误<br>Exception是由程序产生的，分为运行时异常（空指针，数组下标越界等）和编译时异常（语法错误等）</p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20240510220456126.png" alt="image-20240510220456126"></p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="ArrayList和LinkedList"><a href="#ArrayList和LinkedList" class="headerlink" title="ArrayList和LinkedList"></a>ArrayList和LinkedList</h3><p>​	<strong>ArrayList：</strong></p>
<p>​	底层为数组（一段连续的内存），支持对元素的快速访问，适合随机访问，不合适插入和删除（移动元素代价高）。默认初始大小为10（初始化时容量为0，当有第一个数据进来才会初始化空间为10），扩容机制是扩大到当前的1.5倍，然后移动到新数组，移动方法：Array.copyof()。</p>
<p>​	<strong>LinkedList：</strong></p>
<p>​	底层为链表（不需要连续的内存），适合数据插入和删除。可以当作堆栈，队列使用（出栈入栈对应插入删除）</p>
<p><strong>均为线程不安全</strong></p>
<h4 id="实现线程安全："><a href="#实现线程安全：" class="headerlink" title="实现线程安全："></a>实现线程安全：</h4><ol>
<li>使用原生的Vector，但是效率很低。底层通过synchronizedList</li>
<li>使用<strong>CopyOnWriteArrayList</strong>，<strong>写时加锁</strong>，使用了一种叫写时复制的方法；读操作是可以不用加锁的，推荐使用</li>
</ol>
<h4 id="fail-fast"><a href="#fail-fast" class="headerlink" title="fail-fast"></a><strong>fail-fast</strong></h4><p>快速失败机制：</p>
<ul>
<li><p>在迭代器遍历元素的过程中，如果集合的结构（modCount）被改变的话，就会抛出异常ConcurrentModificationException，防止继续遍历。这就是所谓的快速失败机制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 10; i &lt; 100; i++)&#123;</span><br><span class="line">        map.put(i, i);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    for(int i = 0; i &lt; 20; i++)&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line">    int temp = 0;</span><br><span class="line">    while(it.hasNext())&#123;</span><br><span class="line">        if(temp == 3)&#123;</span><br><span class="line">            temp++;</span><br><span class="line">            list.remove(3);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            temp++;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上诉代码会抛出异常，修改成以下代码就不会,不能直接使用集合的 <code>remove</code> 方法来删除元素，而应该使用 <code>Iterator</code> 的 <code>remove</code> 方法，这样可以避免 <code>ConcurrentModificationException</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 使用 Iterator 遍历并删除元素</span><br><span class="line">        Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line">        int temp = 0;</span><br><span class="line">        while (it.hasNext()) &#123;</span><br><span class="line">            if (temp == 3) &#123;</span><br><span class="line">                temp++;</span><br><span class="line">                it.next(); // 移动到下一个元素，因为 remove 需要在 next() 之后调用</span><br><span class="line">                it.remove(); // 使用 Iterator 的 remove 方法</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                temp++;</span><br><span class="line">                System.out.println(it.next());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="fail-safe"><a href="#fail-safe" class="headerlink" title="fail-safe"></a><strong>fail-safe</strong></h4><p>安全失败机制：</p>
<ul>
<li>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。由于在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发ConcurrentModificationException。</li>
<li><strong>缺点</strong>：基于拷贝内容的优点是避免了ConcurrentModificationException，但同样地，迭代器并不能访问到<strong>修改后</strong>的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</li>
<li>适用场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</li>
</ul>
<h3 id="HashMap详解（JDK-1-8）"><a href="#HashMap详解（JDK-1-8）" class="headerlink" title="HashMap详解（JDK 1.8）"></a>HashMap详解（JDK 1.8）</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904111817637901">https://juejin.cn/post/6844904111817637901</a></p>
<h4 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h4><p>​	底层数据结构采用数组+链表+红黑树。通过散列映射来存储键值对数据。</p>
<h4 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h4><p>​	HashMap 是使用哈希表来存储数据的。哈希表为了解决冲突，一般有两种方案：<strong>开放地址法</strong> 和 <strong>链地址法</strong>。HashMap 采用的便是 <strong>链地址法</strong>，即在数组的每个索引处都是一个链表结构，这样就可以有效解决 hash 冲突。</p>
<h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认的初始容量为 16 （PS：aka 应该是 as know as）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大容量（容量不够时需要扩容）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>; <span class="comment">//2的30次方</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认的负载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表长度为 8 的时候会转为红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 长度为 6 的时候会从红黑树转为链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有桶内数据量大于 64 的时候才会允许转红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>初始容量是 16，可以扩容，但是扩容之后的容量，也是 2 的幂次方也就是一倍。另外， <strong>MIN_TREEIFY_CAPACITY</strong>，虽然说当链表长度大于 8 的时候，链表会转为红黑树，但是也是需要满足桶内存储的数据量大于上述这个参数的值，否则不仅不会转红黑树，反而会进行扩容操作。</p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20240512232213041.png" alt="image-20240512232213041"></p>
<h4 id="重要参数"><a href="#重要参数" class="headerlink" title="重要参数"></a>重要参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map 中存储的数据量，即 key-value 键值对的数量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap 内部结构发生变化的次数，即新增、删除数据的时候都会记录，</span></span><br><span class="line"><span class="comment">// 注意：修改某个 key 的值，并不会改变这个 modCount</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重点，代表最多能容纳的数据量（初始为16 * 0.75 = 12）</span></span><br><span class="line"><span class="comment">// 即最多能容纳的 key-value 键值对的数量</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负载因子，默认为 0.75</span></span><br><span class="line"><span class="comment">// 注意，这个值是可以大于 1 的</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>threshold</strong> 代表最多能容纳的 Node 数量，一般 <code>threshold = 数组长度（初始为16） * loadFactor</code>，也就是说要想 HashMap 能够存储更多的数据（即获得较大的 threshold），有两种方案，一种是扩容（即增大数组长度 ），另一种便是增大负载因子。</p>
<h4 id="自动扩容原理"><a href="#自动扩容原理" class="headerlink" title="自动扩容原理"></a>自动扩容原理</h4><p>​	<strong>初始化为空数组，第-次put 时才实例。</strong>当数据容量size达到threshold 阈值时会触发扩容机制。调用resize()，将<strong>数组长度</strong>扩大到原来的2倍。</p>
<h5 id="threshold阈值怎么计算"><a href="#threshold阈值怎么计算" class="headerlink" title="threshold阈值怎么计算"></a>threshold阈值怎么计算</h5><p>​	threshold &#x3D; 数组长度（初始为16） * loadFactor（负载因子）</p>
<h5 id="数组怎么扩容"><a href="#数组怎么扩容" class="headerlink" title="数组怎么扩容"></a>数组怎么扩容</h5><pre><code> 1. 获取旧数组，旧数组长度，旧数组阈值
 2. 如果旧数组长度 &gt; 0
  	1.  旧数组长度 &gt;=最大值，就将阈值调为Integer.MAX_VALUE（2的31次方-1），数组长度不变；
  	2. 数组长度变为原来的2倍，阈值 = 新数组长度 * 负载因子0.75
 3. 如果旧数组长度 = 0，但是旧阈值 &gt; 0，正常是带参初始化hashmap，将旧阈值作为数组长度
 4. 如果旧数组长度 = 0 ，旧阈值 = 0，就是无参初始化hashmap，将默认初始容量 `DEFAULT_INITIAL_CAPACITY（16）`和默认负载因子 `DEFAULT_LOAD_FACTOR（0.75）`计算出新数组长度 newCap 和新阈值 newThr。
 5. 将旧数组元素复制到新数组，一部分下标索引不变，一部分变为（原索引+旧数据长度）（索引不是指链表位置）
</code></pre>
<h4 id="添加元素时怎么确定存放的底层数组（桶）的索引下标？"><a href="#添加元素时怎么确定存放的底层数组（桶）的索引下标？" class="headerlink" title="添加元素时怎么确定存放的底层数组（桶）的索引下标？"></a>添加元素时怎么确定存放的底层数组（桶）的索引下标？</h4><p>​	通过这个与运算 <code>(n - 1) &amp; hash</code>，其中变量 n 为数组的长度，变量 hash 就是通过 <code>hash()</code> 方法计算后的结果</p>
<h4 id="简单介绍一下-hash-原理？"><a href="#简单介绍一下-hash-原理？" class="headerlink" title="简单介绍一下 hash()原理？"></a>简单介绍一下 <code>hash()</code>原理？</h4><p>​	HashMap的<code>hash()</code>就是将key对象的hashCode值进行处理（降低hash冲突的可能），得到最终的哈希值（hash）</p>
<h4 id="JDK1-7与JDK1-8中HashMap的区别"><a href="#JDK1-7与JDK1-8中HashMap的区别" class="headerlink" title="JDK1.7与JDK1.8中HashMap的区别"></a>JDK1.7与JDK1.8中HashMap的区别</h4><ol>
<li>旧数组长度jdk1.8计算索引方式不同，扩容时计算新索引下标只需要（hash &amp; 旧数组长度）即可，结果为0则新索引&#x3D;原索引n，结果为旧数组长度则新索引&#x3D;原索引n + 旧数组长度。jdk1.7扩容时需要一直（n-1）&amp;hash</li>
<li>1.8的链表引入了红黑树结构，当链表长度大于8且桶数组数据量大于64就变成红黑树，小于6则从红黑树退化为链表，。1.7则是数组+链表。</li>
<li>1.8扩容采用尾插法，1.7用头插法。尾插法能保证节点顺序和之前保持一致。</li>
</ol>
<h4 id="为什么1-8改用红黑树"><a href="#为什么1-8改用红黑树" class="headerlink" title="为什么1.8改用红黑树"></a>为什么1.8改用红黑树</h4><p>​	当hash冲突过多时，链表过长，此时查询效率低下，大于8改为红黑树后查询方式性能得到了很好的提升，从原来的是O(n)到O(logn)。</p>
<h4 id="Hashmap-链表转红黑树条件"><a href="#Hashmap-链表转红黑树条件" class="headerlink" title="Hashmap 链表转红黑树条件"></a>Hashmap 链表转红黑树条件</h4><pre><code>1. 链表长度大于8
1. 数组长度大于64
</code></pre>
<h4 id="HashMap允许空键空值么"><a href="#HashMap允许空键空值么" class="headerlink" title="HashMap允许空键空值么"></a>HashMap允许空键空值么</h4><p>​	HashMap最多只允许一个键为Null(多条会覆盖)，但允许多个值为Null。hash()当key为null为返回0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h4><ol>
<li>两个线程同时计算索引时，可能会得出同一个索引位置，当A获取链表头节点后时间片用完，B获取链表头节点插入，此时A再插入数据就会造成B的数组被覆盖的问题。</li>
<li>（jdk1.7时采用、头插法）两个线程同时触发resize()，同时修改链表结构会产生一个循环链表。此时get会死循环</li>
</ol>
<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>​	解决线程安全问题可以通过<strong>ConcurrentHashMap</strong> 和 <strong>Hashtable</strong>来实现线程安全；</p>
<p>​	HashTable是原始API类，通过synchronize同步修饰，效率低下；</p>
<p>​	ConcurrentHashMap通过分段锁实现，效率比HashTable要好；</p>
<h5 id="数据结构：-1"><a href="#数据结构：-1" class="headerlink" title="数据结构："></a>数据结构：</h5><p>​	和HashMap一样采用数组 + 链表 + 红黑树实现。扩容机制也一样</p>
<h5 id="与1-7区别"><a href="#与1-7区别" class="headerlink" title="与1.7区别"></a>与1.7区别</h5><p>​	jdk1.7的concurrentHashMap使用数组 + segment（段）+分段锁实现，其内部分为一个个段（Segment）数组，Segment 通过继承 ReentrantLock（可重入锁） 来进行加锁。每次锁一个段降低锁的粒度保证线程在段内操作的安全性。但是这样每次确定索引就需要两次定位：</p>
<ol>
<li>hash值 &amp; （段数组长度 - 1），确定所属段</li>
<li>hash值 &amp; （内部数组长度 - 1），确定所在桶</li>
</ol>
<p>​	因此jdk1.8中优化了结构，取消分段锁，使用cas操作（compare and swap）和synchronied关键字实现优化。粒度直接到桶数组元素级别，锁住链表。</p>
<h5 id="不允许key和value为null"><a href="#不允许key和value为null" class="headerlink" title="不允许key和value为null"></a>不允许key和value为null</h5><p>​	容易引起歧义，因为无法确认本身就是null还是被另一个线程修改的key-value</p>
<h5 id="如何保证线程的安全性？"><a href="#如何保证线程的安全性？" class="headerlink" title="如何保证线程的安全性？"></a>如何保证线程的安全性？</h5><p>​	采用大量的分而治之的思想来降低锁的粒度，提升并发性能。使用大量的cas操作保证安全性，而不是和 HashTable 一样，不论什么方法，直接简单粗暴的使用 synchronized关键字来实现。</p>
<p>​	cas：比较交换，通过拿一个旧值（期望值）和旧地址存的值作比较，如果相等就用新值设置并返回true，否则返回false证明已经被另一个线程修改了</p>
<h5 id="多并发下怎么实现扩容"><a href="#多并发下怎么实现扩容" class="headerlink" title="多并发下怎么实现扩容"></a>多并发下怎么实现扩容</h5><p>​	采用分而治之的思想，分段进行扩容，即每个线程负责一段，默认最小是 16。也就是说如果 ConcurrentHashMap 中只有 16 个槽位，那么就只会有一个线程参与扩容。如果大于 16 则根据当前 CPU 数来进行分配，最大参与扩容线程数不会超过 CPU 数。<br>扩容后迁移数据，和hashmap类似，但是会用synchronized对当前节点加锁</p>
<h3 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a><strong>序列化和反序列化</strong></h3><p>​	<strong>序列化：</strong>将java对象转化为字节序列的过程。持久化，用于存储和传输</p>
<p>​	<strong>反序列化：</strong>将字节序列转化为java对象的过程。</p>
<h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a><strong>优点：</strong></h5><p> a、实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上（通常存放在文件里）Redis的RDB</p>
<p> b、利用序列化实现远程通信，即在网络上传送对象的字节序列。 Google的protoBuf</p>
<h5 id="反序列化失败的场景："><a href="#反序列化失败的场景：" class="headerlink" title="反序列化失败的场景："></a><strong>反序列化失败的场景：</strong></h5><p> 序列化ID：serialVersionUID不一致的时候，导致反序列化失败（serialVersionUID是JRE根据类的内部细节自动生成，当修改对象属性或方法，serialVersionUID也会变化）</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a><strong>String</strong></h3><p>String 使用<strong>数组</strong>存储内容，数组使用 <strong>final</strong> 修饰，因此 String 定义的字符串的值也是<strong>不可变的</strong>，线程安全</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">操作效率</th>
<th align="left">线程安全</th>
</tr>
</thead>
<tbody><tr>
<td align="left">String</td>
<td align="left">低</td>
<td align="left">安全（final）</td>
</tr>
<tr>
<td align="left">StringBuffer</td>
<td align="left">中</td>
<td align="left">安全（synchronized）</td>
</tr>
<tr>
<td align="left">StringBuilder</td>
<td align="left">高</td>
<td align="left">非安全</td>
</tr>
</tbody></table>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ol>
<li><p>饿汉式（立即加载）</p>
<p>饿汉式单例模式在类加载时就创建实例，线程安全，但如果实例初始化过程复杂且不一定会用到，可能会浪费资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonEager</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonEager</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 饿汉式在类加载时创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SingletonEager</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonEager</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供公共静态方法获取实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonEager <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>懒汉式 （延迟加载）</p>
<p>线程不安全懒汉式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonLazy</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonLazy</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 懒汉式在需要时创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonLazy instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供公共静态方法获取实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonLazy <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">SingletonLazy</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>线程安全的懒汉式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;   <span class="comment">//禁止指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>) &#123; <span class="comment">//减少加锁的损耗</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="literal">null</span>) <span class="comment">//确认是否初始化完成</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用双重<strong>双重检查锁定</strong>:</p>
<ul>
<li><strong>第一次检查</strong>：在同步块外检查 <code>instance</code> 是否为 <code>null</code>，目的是减少不必要的同步，提升性能。</li>
<li><strong>同步块</strong>：如果第一次检查发现 <code>instance</code> 为 <code>null</code>，进入同步块，确保只有一个线程能够执行此块代码。</li>
<li><strong>第二次检查</strong>：在同步块内再次检查 <code>instance</code> 是否为 <code>null</code>，因为可能有多个线程在第一次检查时都发现 <code>instance</code> 为 <code>null</code>，如果没有第二次检查，那么多个线程可能会创建多个实例。</li>
<li><strong>实例化</strong>：只有在确认 <code>instance</code> 为 <code>null</code> 的情况下，才会创建新的实例。</li>
</ul>
<p><strong>优化，使用静态内部类实现懒汉式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonLazy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonLazy</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 懒汉式在需要时创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonLazyHelper</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SingletonLazy</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonLazy</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供公共静态方法获取实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonLazy <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonLazyHelper.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ol>
<li><strong>私有构造函数</strong>：<code>private Singleton()</code> 确保外部无法实例化该类。</li>
<li><strong>静态内部类</strong>：<code>SingletonHolder</code> 是一个私有的静态内部类，它只在 <code>Singleton.getInstance()</code> 被调用时才会被加载和初始化。</li>
<li><strong>静态初始化器</strong>：<code>private static final Singleton INSTANCE = new Singleton();</code> 由 JVM 保证在类加载时线程安全。</li>
<li><strong>公共静态方法</strong>：<code>public static Singleton getInstance()</code> 通过调用 <code>SingletonHolder.INSTANCE</code> 返回单例实例。</li>
</ol>
<p>这种方式利用了 JVM 类加载机制的线程安全特性，不需要显式的同步机制，同时实现了懒加载，确保了单例实例只有在第一次使用时才会被创建。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><strong>延迟加载</strong>：单例实例在第一次使用时才被创建。</li>
<li><strong>线程安全</strong>：静态内部类的加载和初始化是由 JVM 保证的，天然是线程安全的。</li>
<li><strong>实现简单</strong>：不需要显式的同步代码，代码简洁明了。</li>
</ul>
</li>
</ol>
<h1 id="Spring篇"><a href="#Spring篇" class="headerlink" title="Spring篇"></a>Spring篇</h1><h3 id="设计思想-Beans"><a href="#设计思想-Beans" class="headerlink" title="设计思想&amp;Beans"></a>设计思想&amp;Beans</h3><h4 id="1、IOC-控制反转"><a href="#1、IOC-控制反转" class="headerlink" title="1、IOC 控制反转"></a><strong>1、IOC 控制反转</strong></h4><p> IoC（Inverse of Control:控制反转）是⼀种设计思想，就是将原本在程序中⼿动创建对象的控制权，交由Spring框架来管理。 IoC 在其他语⾔中也有应⽤，并⾮ Spring 特有。</p>
<p> IoC 容器是 Spring⽤来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注⼊。这样可以很⼤程度上简化应⽤的开发，把应⽤从复杂的依赖关系中解放出来。 IoC 容器就像是⼀个⼯⼚⼀样，当我们需要创建⼀个对象的时候，只需要配置好配置⽂件&#x2F;注解即可，完全不⽤考虑对象是如何被创建出来的。</p>
<p><strong>DI 依赖注入</strong></p>
<p> DI:（Dependancy Injection：依赖注入)站在容器的角度，将对象创建依赖的其他对象注入到对象中。</p>
<h4 id="2、AOP-动态代理"><a href="#2、AOP-动态代理" class="headerlink" title="2、AOP 动态代理"></a><strong>2、AOP 动态代理</strong></h4><p> AOP(Aspect-Oriented Programming:⾯向切⾯编程)能够将那些与业务⽆关，却为业务模块所共同调⽤的逻辑或责任（例如事务处理、⽇志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p>
<p> Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接⼝，那么Spring AOP会使⽤JDKProxy，去创建代理对象，<strong>⽽对于没有实现接⼝的对象，就⽆法使⽤ JDK Proxy 去进⾏代理了</strong>，这时候Spring AOP会使⽤基于asm框架字节流的Cglib动态代理 ，这时候Spring AOP会使⽤ Cglib ⽣成⼀个被代理对象的⼦类来作为代理。</p>
<h4 id="3、Bean生命周期"><a href="#3、Bean生命周期" class="headerlink" title="3、Bean生命周期"></a><strong>3、Bean生命周期</strong></h4><p><strong>单例对象：</strong> singleton</p>
<p>总结：单例对象的生命周期和容器相同</p>
<p><strong>多例对象：</strong> prototype</p>
<p>出生：使用对象时spring框架为我们创建</p>
<p>活着：对象只要是在使用过程中就一直活着</p>
<p>死亡：当对象长时间不用且没有其它对象引用时，由java的垃圾回收机制回收</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/ff500845fb259b45f67c7d6fe787850907bedb69b49cb8cf236880c59ce77d83/68747470733a2f2f73302e6c677374617469632e636f6d2f692f696d616765332f4d30312f38392f30432f43677132786c365776487141646d743441414247416e32655369493633312e706e67"><img src="https://camo.githubusercontent.com/ff500845fb259b45f67c7d6fe787850907bedb69b49cb8cf236880c59ce77d83/68747470733a2f2f73302e6c677374617469632e636f6d2f692f696d616765332f4d30312f38392f30432f43677132786c365776487141646d743441414247416e32655369493633312e706e67" alt="img"></a></p>
<p>IOC容器初始化加载Bean流程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">  // 第一步:刷新前的预处理 </span><br><span class="line">  prepareRefresh();</span><br><span class="line">  //第二步: 获取BeanFactory并注册到 BeanDefitionRegistry</span><br><span class="line">  ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">  // 第三步:加载BeanFactory的预准备工作(BeanFactory进行一些设置，比如context的类加载器等)</span><br><span class="line">  prepareBeanFactory(beanFactory);</span><br><span class="line">  try &#123;</span><br><span class="line">    // 第四步:完成BeanFactory准备工作后的前置处理工作 </span><br><span class="line">    postProcessBeanFactory(beanFactory);</span><br><span class="line">    // 第五步:实例化BeanFactoryPostProcessor接口的Bean </span><br><span class="line">    invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">    // 第六步:注册BeanPostProcessor后置处理器，在创建bean的后执行 </span><br><span class="line">    registerBeanPostProcessors(beanFactory);</span><br><span class="line">    // 第七步:初始化MessageSource组件(做国际化功能;消息绑定，消息解析); </span><br><span class="line">    initMessageSource();</span><br><span class="line">    // 第八步:注册初始化事件派发器 </span><br><span class="line">    initApplicationEventMulticaster();</span><br><span class="line">    // 第九步:子类重写这个方法，在容器刷新的时候可以自定义逻辑 </span><br><span class="line">    onRefresh();</span><br><span class="line">    // 第十步:注册应用的监听器。就是注册实现了ApplicationListener接口的监听器</span><br><span class="line">    registerListeners();</span><br><span class="line">    //第十一步:初始化所有剩下的非懒加载的单例bean 初始化创建非懒加载方式的单例Bean实例(未设置属性)</span><br><span class="line">    finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">    //第十二步: 完成context的刷新。主要是调用LifecycleProcessor的onRefresh()方法，完成创建</span><br><span class="line">    finishRefresh();</span><br><span class="line">	&#125;</span><br><span class="line">  ……</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<p>总结：</p>
<p><strong>四个阶段</strong></p>
<ul>
<li>实例化 Instantiation</li>
<li>属性赋值 Populate</li>
<li>初始化 Initialization</li>
<li>销毁 Destruction</li>
</ul>
<p><strong>多个扩展点</strong></p>
<ul>
<li>影响多个Bean<ul>
<li>BeanPostProcessor</li>
<li>InstantiationAwareBeanPostProcessor</li>
</ul>
</li>
<li>影响单个Bean<ul>
<li>Aware</li>
</ul>
</li>
</ul>
<p><strong>完整流程</strong></p>
<ol>
<li>实例化一个Bean－－也就是我们常说的<strong>new</strong>；</li>
<li>按照Spring上下文对实例化的Bean进行配置－－<strong>也就是IOC注入</strong>；</li>
<li>如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String)方法，也就是根据就是Spring配置文件中<strong>Bean的id和name进行传递</strong></li>
<li>如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现setBeanFactory(BeanFactory)也就是Spring配置文件配置的<strong>Spring工厂自身进行传递</strong>；</li>
<li>如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，和4传递的信息一样但是因为ApplicationContext是BeanFactory的子接口，所以<strong>更加灵活</strong></li>
<li>如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessBeforeInitialization()方法，BeanPostProcessor经常被用作是Bean内容的更改，由于这个是在Bean初始化结束时调用那个的方法，也可以被应用于<strong>内存或缓存技</strong>术</li>
<li>如果Bean在Spring配置文件中配置了init-method属性会自动调用其配置的初始化方法。</li>
<li>如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessAfterInitialization()，<strong>打印日志或者三级缓存技术里面的bean升级</strong></li>
<li>以上工作完成以后就可以应用这个Bean了，那这个Bean是一个Singleton的，所以一般情况下我们调用同一个id的Bean会是在内容地址相同的实例，当然在Spring配置文件中也可以配置非Singleton，这里我们不做赘述。</li>
<li>当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，或者根据spring配置的destroy-method属性，调用实现的destroy()方法</li>
</ol>
<h4 id="4、Bean作用域"><a href="#4、Bean作用域" class="headerlink" title="4、Bean作用域"></a><strong>4</strong>、Bean作用域</h4><table>
<thead>
<tr>
<th>名称</th>
<th>作用域</th>
</tr>
</thead>
<tbody><tr>
<td><strong>singleton</strong></td>
<td><strong>单例对象，默认值的作用域</strong></td>
</tr>
<tr>
<td><strong>prototype</strong></td>
<td><strong>每次获取都会创建⼀个新的 bean 实例</strong></td>
</tr>
<tr>
<td>request</td>
<td>每⼀次HTTP请求都会产⽣⼀个新的bean，该bean仅在当前HTTP request内有效。</td>
</tr>
<tr>
<td>session</td>
<td>在一次 HTTP session 中，容器将返回同一个实例</td>
</tr>
<tr>
<td>global-session</td>
<td>将对象存入到web项目集群的session域中,若不存在集群,则global session相当于session</td>
</tr>
</tbody></table>
<p>默认作用域是singleton，多个线程访问同一个bean时会存在线程不安全问题</p>
<p><strong>保障线程安全方法：</strong></p>
<ol>
<li>在Bean对象中尽量避免定义可变的成员变量（不太现实）。</li>
<li>在类中定义⼀个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中</li>
</ol>
<p><strong>ThreadLocal</strong>：</p>
<p> 每个线程中都有一个自己的ThreadLocalMap类对象，可以将线程自己的对象保持到其中，各管各的，线程可以正确的访问到自己的对象。</p>
<p> 将一个共用的ThreadLocal静态实例作为key，将不同对象的引用保存到不同线程的ThreadLocalMap中，然后<strong>在线程执行的各处通过这个静态ThreadLocal实例的get()方法取得自己线程保存的那个对象</strong>，避免了将这个对象作为参数传递的麻烦。</p>
<h4 id="5、循环依赖"><a href="#5、循环依赖" class="headerlink" title="5、循环依赖"></a>5、循环依赖</h4><p> 循环依赖其实就是循环引用，也就是两个或者两个以上的 Bean 互相持有对方，最终形成闭环。比如A 依赖于B，B又依赖于A</p>
<p>Spring中循环依赖场景有:</p>
<ul>
<li><p>prototype 原型 bean循环依赖</p>
</li>
<li><p>构造器的循环依赖（构造器注入）</p>
</li>
<li><p>Field 属性的循环依赖（set注入）</p>
<p>其中，构造器的循环依赖问题无法解决，在解决属性循环依赖时，可以使用懒加载，spring采用的是提前暴露对象的方法。</p>
</li>
</ul>
<p><strong>懒加载@Lazy解决循环依赖问题</strong></p>
<p> Spring 启动的时候会把所有bean信息(包括XML和注解)解析转化成Spring能够识别的BeanDefinition并存到Hashmap里供下面的初始化时用，然后对每个 BeanDefinition 进行处理。普通 Bean 的初始化是在容器启动初始化阶段执行的，而被lazy-init&#x3D;true修饰的 bean 则是在从容器里第一次进行<strong>context.getBean() 时进行触发</strong>。</p>
<p><strong>三级缓存解决循环依赖问题</strong></p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/de2991ecc66213f6d747a23957a07acf037eb3f0f4f0398e1cd1445a6e479fcf/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676c763769767275326c6a333139383071636e31332e6a7067"><img src="https://camo.githubusercontent.com/de2991ecc66213f6d747a23957a07acf037eb3f0f4f0398e1cd1445a6e479fcf/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676c763769767275326c6a333139383071636e31332e6a7067" alt="循环依赖问题"></a></p>
<ol>
<li>Spring容器初始化ClassA通过构造器初始化对象后提前暴露到Spring容器中的singletonFactorys（三级缓存中）。</li>
<li>ClassA调用setClassB方法，Spring首先尝试从容器中获取ClassB，此时ClassB不存在Spring 容器中。</li>
<li>Spring容器初始化ClassB，ClasssB首先将自己暴露在三级缓存中，然后从Spring容器一级、二级、三级缓存中一次中获取ClassA 。</li>
<li>获取到ClassA后将自己实例化放入单例池中，实例 ClassA通过Spring容器获取到ClassB，完成了自己对象初始化操作。</li>
<li>这样ClassA和ClassB都完成了对象初始化操作，从而解决了循环依赖问题。</li>
</ol>
<h5 id="Spring-框架通过-“三级缓存”-机制来解决单例-Bean-的循环依赖问题。三级缓存主要涉及以下三个缓存："><a href="#Spring-框架通过-“三级缓存”-机制来解决单例-Bean-的循环依赖问题。三级缓存主要涉及以下三个缓存：" class="headerlink" title="Spring 框架通过 “三级缓存” 机制来解决单例 Bean 的循环依赖问题。三级缓存主要涉及以下三个缓存："></a>Spring 框架通过 “三级缓存” 机制来解决单例 Bean 的循环依赖问题。三级缓存主要涉及以下三个缓存：</h5><ol>
<li><strong>一级缓存</strong>（singletonObjects）：存储已经完全初始化的单例 Bean。</li>
<li><strong>二级缓存</strong>（earlySingletonObjects）：存储提前暴露的早期单例 Bean，未完成依赖注入但已经实例化。</li>
<li><strong>三级缓存</strong>（singletonFactories）：存储能够创建 Bean 的工厂对象，用于创建 Bean 的代理对象或提前曝光 Bean 的实例。</li>
</ol>
<p>三级缓存解决循环依赖问题的工作机制</p>
<ol>
<li><strong>Bean 实例化</strong>：<ul>
<li>Spring 在创建 Bean 的过程中，首先会实例化该 Bean（即调用构造函数创建 Bean 对象，但未进行依赖注入）。</li>
</ul>
</li>
<li><strong>将 Bean 的工厂对象加入三级缓存</strong>：<ul>
<li>Spring 会将创建 Bean 的工厂对象放入三级缓存（singletonFactories）。</li>
</ul>
</li>
<li><strong>依赖注入</strong>：<ul>
<li>当需要注入依赖时，Spring 会从缓存中获取依赖的 Bean。如果依赖的 Bean 已经在一级缓存中，则直接使用；如果在二级缓存中，也直接使用；如果在三级缓存中，Spring 会通过工厂对象获取 Bean 的早期引用，并将其移动到二级缓存中以供其他 Bean 使用。</li>
</ul>
</li>
<li><strong>完成依赖注入和初始化</strong>：<ul>
<li>一旦依赖注入完成，Spring 会将完全初始化的 Bean 移动到一级缓存中，同时从二级缓存和三级缓存中移除。</li>
</ul>
</li>
</ol>
<p>代码示例</p>
<p>为了更好地理解三级缓存的工作机制，以下是一个简化的代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">java复制代码import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.context.annotation.Scope;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">@Scope(&quot;singleton&quot;)</span><br><span class="line">public class A &#123;</span><br><span class="line">    private final B b;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public A(B b) &#123;</span><br><span class="line">        this.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">@Scope(&quot;singleton&quot;)</span><br><span class="line">public class B &#123;</span><br><span class="line">    private final A a;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public B(A a) &#123;</span><br><span class="line">        this.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，类 <code>A</code> 依赖于类 <code>B</code>，而类 <code>B</code> 也依赖于类 <code>A</code>，形成了循环依赖。</p>
<p>三级缓存的详细工作过程</p>
<ol>
<li><strong>实例化 Bean A</strong>：<ul>
<li>Spring 创建 Bean A 的实例，并将 Bean A 的工厂对象放入三级缓存。</li>
</ul>
</li>
<li><strong>实例化 Bean B</strong>：<ul>
<li>在创建 Bean B 的过程中，发现需要注入 Bean A。</li>
<li>Spring 从三级缓存中获取 Bean A 的工厂对象，通过工厂对象获取 Bean A 的早期引用（即尚未完成依赖注入的实例），并将其放入二级缓存。</li>
</ul>
</li>
<li><strong>完成 Bean B 的实例化和依赖注入</strong>：<ul>
<li>Spring 完成 Bean B 的实例化和依赖注入，将完全初始化的 Bean B 放入一级缓存。</li>
</ul>
</li>
<li><strong>完成 Bean A 的依赖注入</strong>：<ul>
<li>Spring 使用从二级缓存中获取的 Bean B 完成 Bean A 的依赖注入，并将完全初始化的 Bean A 移动到一级缓存。</li>
</ul>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过三级缓存机制，Spring 能够在 Bean 的创建过程中提前暴露一个创建中的 Bean，从而解决单例 Bean 的循环依赖问题。这种机制确保了依赖注入的顺利进行，同时避免了死循环或堆栈溢出错误。然而，这种机制仅适用于单例作用域的 Bean，对于原型作用域的 Bean，Spring 无法使用这种机制来解决循环依赖问题。</p>
<h3 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h3><h4 id="1、-SpringBoot"><a href="#1、-SpringBoot" class="headerlink" title="1、@SpringBoot"></a>1、@SpringBoot</h4><p> <strong>声明bean的注解</strong></p>
<p> <strong>@Component</strong> 通⽤的注解，可标注任意类为 Spring 组件</p>
<p> <strong>@Service</strong> 在业务逻辑层使用（service层）</p>
<p> <strong>@Repository</strong> 在数据访问层使用（dao层）</p>
<p> <strong>@Controller</strong> 在展现层使用，控制器的声明（controller层）</p>
<p> <strong>注入bean的注解</strong></p>
<p> <strong>@Autowired</strong>：默认按照类型来装配注入，**@Qualifier**：可以改成名称</p>
<p> <strong>@Resource</strong>：默认按照名称来装配注入，JDK的注解，新版本已经弃用</p>
<p><strong>@Autowired注解原理</strong></p>
<p> @Autowired的使用简化了我们的开发，</p>
<p> 实现 AutowiredAnnotationBeanPostProcessor 类，该类实现了 Spring 框架的一些扩展接口。 实现 BeanFactoryAware 接口使其内部持有了 BeanFactory（可轻松的获取需要依赖的的 Bean）。 实现 MergedBeanDefinitionPostProcessor 接口，实例化Bean 前获取到 里面的 @Autowired 信息并缓存下来； 实现 postProcessPropertyValues 接口， 实例化Bean 后从缓存取出注解信息，通过反射将依赖对象设置到 Bean 属性里面。</p>
<p><strong>@SpringBootApplication</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class JpaApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(JpaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>@SpringBootApplication</strong>注解等同于下面三个注解：</p>
<ul>
<li><strong>@SpringBootConfiguration：</strong> 底层是<strong>Configuration</strong>注解，说白了就是支持<strong>JavaConfig</strong>的方式来进行配置</li>
<li><strong>@EnableAutoConfiguration：开启自动配置</strong>功能</li>
<li><strong>@ComponentScan：就是扫描</strong>注解，默认是扫描<strong>当前类下</strong>的package</li>
</ul>
<p><strong>其中<code>@EnableAutoConfiguration</code>是关键(启用自动配置)，内部实际上就去加载<code>META-INF/spring.factories</code>文件的信息，然后筛选出以<code>EnableAutoConfiguration</code>为key的数据，加载到IOC容器中，实现自动配置功能！</strong></p>
<p>它主要加载了@SpringBootApplication注解主配置类，这个@SpringBootApplication注解主配置类里边最主要的功能就是SpringBoot开启了一个@EnableAutoConfiguration注解的自动配置功能。</p>
<p><strong>@EnableAutoConfiguration作用：</strong></p>
<p>它主要利用了一个</p>
<p>EnableAutoConfigurationImportSelector选择器给Spring容器中来导入一些组件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Import(EnableAutoConfigurationImportSelector.class)</span><br><span class="line">public @interface EnableAutoConfiguration </span><br></pre></td></tr></table></figure>



<h4 id="2、-SpringMVC"><a href="#2、-SpringMVC" class="headerlink" title="2、@SpringMVC"></a><strong>2、@SpringMVC</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Controller 声明该类为SpringMVC中的Controller</span><br><span class="line">@RequestMapping 用于映射Web请求</span><br><span class="line">@ResponseBody 支持将返回值放在response内，而不是一个页面，通常用户返回json数据</span><br><span class="line">@RequestBody 允许request的参数在request体中，而不是在直接连接在地址后面。</span><br><span class="line">@PathVariable 用于接收路径参数</span><br><span class="line">@RequestMapping(&quot;/hello/&#123;name&#125;&quot;)申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。</span><br></pre></td></tr></table></figure>



<p><strong>SpringMVC原理</strong></p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/d9b573af7586c35692c03cf192231b9518ddd4a92bc805da05032edab42d4916/68747470733a2f2f696d672d626c6f672e6373646e2e6e65742f32303138313032323232343035383631373f77617465726d61726b2f322f746578742f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c3246335957746c5832787861413d3d2f666f6e742f3561364c354c32542f666f6e7473697a652f3430302f66696c6c2f49304a42516b46434d413d3d2f646973736f6c76652f3730"><img src="https://camo.githubusercontent.com/d9b573af7586c35692c03cf192231b9518ddd4a92bc805da05032edab42d4916/68747470733a2f2f696d672d626c6f672e6373646e2e6e65742f32303138313032323232343035383631373f77617465726d61726b2f322f746578742f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c3246335957746c5832787861413d3d2f666f6e742f3561364c354c32542f666f6e7473697a652f3430302f66696c6c2f49304a42516b46434d413d3d2f646973736f6c76652f3730" alt="img"></a></p>
<ol>
<li>客户端（浏览器）发送请求，直接请求到 DispatcherServlet 。</li>
<li>DispatcherServlet 根据请求信息调⽤ HandlerMapping ，解析请求对应的 Handler 。</li>
<li>解析到对应的 Handler （也就是 Controller 控制器）后，开始由HandlerAdapter 适配器处理。</li>
<li>HandlerAdapter 会根据 Handler 来调⽤真正的处理器开处理请求，并处理相应的业务逻辑。</li>
<li>处理器处理完业务后，会返回⼀个 ModelAndView 对象， Model 是返回的数据对象</li>
<li>ViewResolver 会根据逻辑 View 查找实际的 View 。</li>
<li>DispaterServlet 把返回的 Model 传给 View （视图渲染）。</li>
<li>把 View 返回给请求者（浏览器）</li>
</ol>
<h4 id="3、-SpringMybatis"><a href="#3、-SpringMybatis" class="headerlink" title="3、@SpringMybatis"></a>3、@SpringMybatis</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Insert ： 插入sql ,和xml insert sql语法完全一样</span><br><span class="line">@Select ： 查询sql, 和xml select sql语法完全一样</span><br><span class="line">@Update ： 更新sql, 和xml update sql语法完全一样</span><br><span class="line">@Delete ： 删除sql, 和xml delete sql语法完全一样</span><br><span class="line">@Param ： 入参</span><br><span class="line">@Results ： 设置结果集合@Result ： 结果</span><br><span class="line">@ResultMap ： 引用结果集合</span><br><span class="line">@SelectKey ： 获取最新插入id </span><br></pre></td></tr></table></figure>



<p><strong>mybatis如何防止sql注入？</strong></p>
<p> 简单的说就是#{}是经过预编译的，是安全的，**$<strong>{}是未经过预编译的，仅仅是取变量的值，是非安全的，存在SQL注入。在编写mybatis的映射语句时，尽量采用</strong>“#{xxx}”<strong>这样的格式。如果需要实现动态传入表名、列名，还需要做如下修改：添加属性</strong>statementType&#x3D;”STATEMENT”<strong>，同时sql里的属有变量取值都改成</strong>${xxxx}**</p>
<p><strong>Mybatis和Hibernate的区别</strong></p>
<p><strong>Hibernate 框架：</strong></p>
<p> <strong>Hibernate</strong>是一个开放源代码的对象关系映射框架,它对JDBC进行了非常轻量级的对象封装,建立对象与数据库表的映射。是一个全自动的、完全面向对象的持久层框架。</p>
<p><strong>Mybatis框架：</strong></p>
<p> <strong>Mybatis</strong>是一个开源对象关系映射框架，原名：ibatis,2010年由谷歌接管以后更名。是一个半自动化的持久层框架。</p>
<p><strong>区别：</strong></p>
<p><strong>开发方面</strong></p>
<p> 在项目开发过程当中，就速度而言：</p>
<p> hibernate开发中，sql语句已经被封装，直接可以使用，加快系统开发；</p>
<p> Mybatis 属于半自动化，sql需要手工完成，稍微繁琐；</p>
<p> 但是，凡事都不是绝对的，如果对于庞大复杂的系统项目来说，复杂语句较多，hibernate 就不是好方案。</p>
<p><strong>sql优化方面</strong></p>
<p> Hibernate 自动生成sql,有些语句较为繁琐，会多消耗一些性能；</p>
<p> Mybatis 手动编写sql，可以避免不需要的查询，提高系统性能；</p>
<p><strong>对象管理比对</strong></p>
<p> Hibernate 是完整的对象-关系映射的框架，开发工程中，无需过多关注底层实现，只要去管理对象即可；</p>
<p> Mybatis 需要自行管理映射关系；</p>
<h4 id="4、-Transactional"><a href="#4、-Transactional" class="headerlink" title="4、@Transactional"></a>4、@Transactional</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@EnableTransactionManagement </span><br><span class="line">@Transactional</span><br></pre></td></tr></table></figure>



<p>注意事项：</p>
<p> ①事务函数中不要处理耗时任务，会导致长期占有数据库连接。</p>
<p> ②事务函数中不要处理无关业务，防止产生异常导致事务回滚。</p>
<p><strong>事务传播属性</strong></p>
<p><strong>1) REQUIRED（默认属性）</strong> 如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。</p>
<ol>
<li>MANDATORY 支持当前事务，如果当前没有事务，就抛出异常。</li>
<li>NEVER 以非事务方式执行，如果当前存在事务，则抛出异常。</li>
<li>NOT_SUPPORTED 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li>
<li>REQUIRES_NEW 新建事务，如果当前存在事务，把当前事务挂起。</li>
<li>SUPPORTS 支持当前事务，如果当前没有事务，就以非事务方式执行。</li>
</ol>
<p><strong>7) NESTED</strong> （<strong>局部回滚</strong>） 支持当前事务，新增Savepoint点，与当前事务同步提交或回滚。 <strong>嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。</strong></p>
<h3 id="Spring源码阅读"><a href="#Spring源码阅读" class="headerlink" title="Spring源码阅读"></a>Spring源码阅读</h3><h4 id="1、Spring中的设计模式"><a href="#1、Spring中的设计模式" class="headerlink" title="1、Spring中的设计模式"></a><strong>1、Spring中的设计模式</strong></h4><p>参考：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485303&idx=1&sn=9e4626a1e3f001f9b0d84a6fa0cff04a&chksm=cea248bcf9d5c1aaf48b67cc52bac74eb29d6037848d6cf213b0e5466f2d1fda970db700ba41&token=255050878&lang=zh_CN%23rd">spring中的设计模式</a></p>
<p><strong>单例设计模式 :</strong> Spring 中的 Bean 默认都是单例的。</p>
<p><strong>⼯⼚设计模式 :</strong> Spring使⽤⼯⼚模式通过 BeanFactory 、 ApplicationContext 创建bean 对象。</p>
<p><strong>代理设计模式 :</strong> Spring AOP 功能的实现。</p>
<p><strong>观察者模式：</strong> Spring 事件驱动模型就是观察者模式很经典的⼀个应⽤。</p>
<p><strong>适配器模式：</strong>Spring AOP 的增强或通知(Advice)使⽤到了适配器模式、spring MVC 中也是⽤到了适配器模式适配 Controller 。</p>
<h1 id="Springboot"><a href="#Springboot" class="headerlink" title="Springboot"></a>Springboot</h1><p>自动装配原理：</p>
<p>​	基于spring框架的IOC（控制反转）和DI（依赖注入）机制，通过自动配置机制来简化Spring应用的配置过程。主要是通过核心注解@SpringbootApplication，可以看作<code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 注解的集合。其中最主要的是@EnableAutoConfiguration。@EnableAutoConfiguration实际是通过 <code>AutoConfigurationImportSelector</code>类（加载自动装配类），将符合条件的bean进行装配。</p>
<h2 id="自动配置的执行过程"><a href="#自动配置的执行过程" class="headerlink" title="自动配置的执行过程"></a>自动配置的执行过程</h2><p><strong>启动阶段</strong>：应用启动时，Spring Boot会扫描<code>META-INF/spring.factories</code>文件，找到所有自动配置类。</p>
<p><strong>加载阶段</strong>：使用<code>SpringFactoriesLoader</code>加载这些配置类。</p>
<p><strong>条件判断</strong>：对于每个自动配置类，Spring Boot会根据<code>@Conditional</code>注解的条件进行判断，如果满足条件，则装配相应的Bean。</p>
<p><strong>注入阶段</strong>：根据DI机制，将满足条件的Bean注入到Spring上下文中。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://1008610.xyz">当</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://1008610.xyz/2022/06/01/JAVA/">http://1008610.xyz/2022/06/01/JAVA/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://1008610.xyz" target="_blank">活页本</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav id="pagination"><div class="pagination"></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2023/02/15/Mockito%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" title="Mockito单元测试"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-15</div><div class="info-item-2">Mockito单元测试</div></div><div class="info-2"><div class="info-item-1">Mockito单元测试  使用Mockito可以mock对象，定义对象中代码逻辑的执行结果，mock对象对逻辑执行也只是做记录而不会真正执行，使用spy创建spy对象的话则会执行真实的代码逻辑，如果打桩就会返回定义的结果，不打桩就返回真实执行的返回结果。 一、apiorg.mockito.Mockito是mockito提供的核心api，提供了大量的静态方法，用于帮助我们来mock对象，验证行为等等，然后需要注意的是，很多方法都被封装在了MockitoCore类里面  mock：构建一个我们需要的对象；可以mock具体的对象，也可以mock接口。  spy：构建监控对象  verify：验证某种行为  when：当执行什么操作的时候，一般配合thenXXX...</div></div></div></a><a class="pagination-related" href="/2023/02/01/java%20spi/" title="java spi"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-01</div><div class="info-item-2">java spi</div></div><div class="info-2"><div class="info-item-1">java spi  SPI组成 spi机制由三个组件形成，分别是service(公开的接口或者抽象类)， service Provider（接口的实现类），ServiceLoader（核心组件，负责在运行时加载并发现实现类） 运行流程  application调用serviceLoader加载实现类， 最终application拿到的是service接口，不关心具体的实现 java spi在JDBC中的应用： 出现前： 1Class.forName(&quot;驱动名&quot;);  出现后，直接添加依赖即可！  java...</div></div></div></a><a class="pagination-related" href="/2024/09/21/%E4%BD%BF%E7%94%A8idea%20%E6%8A%8A%E4%B8%80%E4%B8%AAgit%E5%88%86%E6%94%AF%E7%9A%84%E9%83%A8%E5%88%86%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95%E5%90%88%E5%B9%B6%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AAgit%E5%88%86%E6%94%AF%E4%B8%8A/" title="使用idea 把一个git分支的部分提交记录合并到另一个git分支上"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-21</div><div class="info-item-2">使用idea 把一个git分支的部分提交记录合并到另一个git分支上</div></div><div class="info-2"><div class="info-item-1">使用idea 把一个git分支的部分提交记录合并到另一个git分支上  希望将cloud-dev分支的某个提交记录提交到cloud-master-test合并分支 切换至cloud-master-test合并分支 log on 选择要合并的分支，并选择 use me查看分支提交 选择合并的提交记录单击cherry-pick </div></div></div></a><a class="pagination-related" href="/2023/02/01/%E5%B7%A5%E7%A8%8B%E8%BE%93%E5%87%BA%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%EF%BC%8C%E5%85%A8%E5%B1%80%E5%90%84%E7%A7%8D%E9%85%8D%E7%BD%AEUTF-8%E5%90%8E%E4%BE%9D%E6%97%A7%E6%B2%A1%E4%BD%9C%E7%94%A8/" title="工程输出中文乱码，全局各种配置UTF-8后依旧没作用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-01</div><div class="info-item-2">工程输出中文乱码，全局各种配置UTF-8后依旧没作用</div></div><div class="info-2"><div class="info-item-1">工程输出中文乱码，全局各种配置UTF-8后依旧没作用  旧开发的坑 首先检查工程之前的编码，以前的开发没注意创建一些文件时会直接默认成GBK编码，打开项目，idea编译器会提示为GBK编码，中文显示乱码，一开始就设置项目为GBK才能看到中文显示，而现在开发大部分默认设置成UTF-8， 所以新建文件都是UTF-8，编译走了UTF-8后执行就会显示成中文乱码，暴力解决思路，把涉及到的文件删除新建，或者整个工程重新新建，一开始就默认成了UTF-8就能解决一切  因为文件编码与全局编码设置不一样，重新建一个文件覆盖这个同名文件即可，可能是之前开发建文件时的全局编码设置为gbk导致，然后现在开发设置的全局编码普遍为utf-8，所以编译执行后中文就会乱码 ############################################# 常规解决 解决方案一、****项目设置pom文件编译的编码格式为utf-8 在maven项目的pom.xml文件设置编译插件及项目编码UTF-8，具体如下图所示 12345678910111213141516171819&lt;build&gt; ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">当</div><div class="author-info-description">live my life</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/13/%E4%BD%BF%E7%94%A8ollama%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAdeepseek/" title="使用ollama本地搭建deepseek">使用ollama本地搭建deepseek</a><time datetime="2025-02-13T06:32:22.000Z" title="发表于 2025-02-13 14:32:22">2025-02-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/08/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/" title="在Cursor中开发Java项目 -- 开发环境常用插件">在Cursor中开发Java项目 -- 开发环境常用插件</a><time datetime="2025-02-08T12:35:22.000Z" title="发表于 2025-02-08 20:35:22">2025-02-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/08/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/" title="在Cursor中开发Java项目 -- 开发环境常用插件">在Cursor中开发Java项目 -- 开发环境常用插件</a><time datetime="2025-02-08T12:32:22.000Z" title="发表于 2025-02-08 20:32:22">2025-02-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/18/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="多线程">多线程</a><time datetime="2024-12-18T12:14:36.000Z" title="发表于 2024-12-18 20:14:36">2024-12-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/01/ansible-playbook/" title="ansible-playbook">ansible-playbook</a><time datetime="2024-12-01T13:14:36.000Z" title="发表于 2024-12-01 21:14:36">2024-12-01</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            <a class="card-more-btn" href="/categories/" title="查看更多">
      <i class="fas fa-angle-right"></i></a>
          </div>
          <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/AI/"><span class="card-category-list-name">AI</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/GIT/"><span class="card-category-list-name">GIT</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Linux/"><span class="card-category-list-name">Linux</span><span class="card-category-list-count">3</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Redis/"><span class="card-category-list-name">Redis</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/ansible/"><span class="card-category-list-name">ansible</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/cursor/"><span class="card-category-list-name">cursor</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/java/"><span class="card-category-list-name">java</span><span class="card-category-list-count">16</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="card-category-list-name">操作系统</span><span class="card-category-list-count">1</span></a></li>
          </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/%E6%A1%86%E6%9E%B6/" style="font-size: 1.4em; color: #99a5b6">框架</a> <a href="/tags/ansbile/" style="font-size: 1.1em; color: #999">ansbile</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BD%BF%E7%94%A8/" style="font-size: 1.1em; color: #999">工具类使用</a> <a href="/tags/java/" style="font-size: 1.5em; color: #99a9bf">java</a> <a href="/tags/Linux/" style="font-size: 1.3em; color: #99a1ac">Linux</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 1.1em; color: #999">多线程</a> <a href="/tags/mysql/" style="font-size: 1.3em; color: #99a1ac">mysql</a> <a href="/tags/deepseek/" style="font-size: 1.1em; color: #999">deepseek</a> <a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 1.1em; color: #999">基础</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 1.1em; color: #999">操作系统</a> <a href="/tags/mybatis/" style="font-size: 1.2em; color: #999da3">mybatis</a> <a href="/tags/GIT/" style="font-size: 1.3em; color: #99a1ac">GIT</a> <a href="/tags/ansible/" style="font-size: 1.1em; color: #999">ansible</a> <a href="/tags/jvm/" style="font-size: 1.1em; color: #999">jvm</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 1.1em; color: #999">设计模式</a> <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 1.1em; color: #999">面试题</a> <a href="/tags/cursor/" style="font-size: 1.2em; color: #999da3">cursor</a> <a href="/tags/redis/" style="font-size: 1.1em; color: #999">redis</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 1.1em; color: #999">网络</a></div></div><div class="card-widget card-archives">
    <div class="item-headline">
      <i class="fas fa-archive"></i>
      <span>归档</span>
      <a class="card-more-btn" href="/archives/"
            title="查看更多">
            <i class="fas fa-angle-right"></i>
          </a>
    </div>
  
    <ul class="card-archive-list">
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/02/">
            <span class="card-archive-list-date">
              二月 2025
            </span>
            <span class="card-archive-list-count">3</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2024/12/">
            <span class="card-archive-list-date">
              十二月 2024
            </span>
            <span class="card-archive-list-count">2</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2024/10/">
            <span class="card-archive-list-date">
              十月 2024
            </span>
            <span class="card-archive-list-count">1</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2024/09/">
            <span class="card-archive-list-date">
              九月 2024
            </span>
            <span class="card-archive-list-count">2</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2024/08/">
            <span class="card-archive-list-date">
              八月 2024
            </span>
            <span class="card-archive-list-count">2</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2024/06/">
            <span class="card-archive-list-date">
              六月 2024
            </span>
            <span class="card-archive-list-count">1</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2024/05/">
            <span class="card-archive-list-date">
              五月 2024
            </span>
            <span class="card-archive-list-count">1</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2023/12/">
            <span class="card-archive-list-date">
              十二月 2023
            </span>
            <span class="card-archive-list-count">1</span>
          </a>
        </li>
      
    </ul>
  </div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站信息</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">34</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总浏览量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2025-02-14T07:02:24.223Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By 当</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>