<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/title-boke.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/title-boke.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"1008610.xyz","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Java基础">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础">
<meta property="og:url" content="http://1008610.xyz/2022/06/01/JAVA/index.html">
<meta property="og:site_name" content="活页本">
<meta property="og:description" content="Java基础">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20240510220456126.png">
<meta property="og:image" content="c:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20240512232213041.png">
<meta property="og:image" content="https://camo.githubusercontent.com/ff500845fb259b45f67c7d6fe787850907bedb69b49cb8cf236880c59ce77d83/68747470733a2f2f73302e6c677374617469632e636f6d2f692f696d616765332f4d30312f38392f30432f43677132786c365776487141646d743441414247416e32655369493633312e706e67">
<meta property="og:image" content="https://camo.githubusercontent.com/de2991ecc66213f6d747a23957a07acf037eb3f0f4f0398e1cd1445a6e479fcf/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676c763769767275326c6a333139383071636e31332e6a7067">
<meta property="og:image" content="https://camo.githubusercontent.com/d9b573af7586c35692c03cf192231b9518ddd4a92bc805da05032edab42d4916/68747470733a2f2f696d672d626c6f672e6373646e2e6e65742f32303138313032323232343035383631373f77617465726d61726b2f322f746578742f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c3246335957746c5832787861413d3d2f666f6e742f3561364c354c32542f666f6e7473697a652f3430302f66696c6c2f49304a42516b46434d413d3d2f646973736f6c76652f3730">
<meta property="article:published_time" content="2022-06-01T13:14:36.000Z">
<meta property="article:modified_time" content="2025-02-07T15:03:56.180Z">
<meta property="article:author" content="当">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20240510220456126.png">

<link rel="canonical" href="http://1008610.xyz/2022/06/01/JAVA/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java基础 | 活页本</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">活页本</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://1008610.xyz/2022/06/01/JAVA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="当">
      <meta itemprop="description" content="live my life">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="活页本">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java基础
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-01 21:14:36" itemprop="dateCreated datePublished" datetime="2022-06-01T21:14:36+08:00">2022-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-07 23:03:56" itemprop="dateModified" datetime="2025-02-07T23:03:56+08:00">2025-02-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>17 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><span id="more"></span>

<h2 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h2><p><strong>封装，继承，多态</strong></p>
<ul>
<li><strong>封装</strong>：将数据和基于数据的操作抽象化成一个对象并对其属性进行私有化，同时提供一些能被外界访问属性的方法；</li>
<li><strong>继承</strong>：子类扩展新的功能，并复用父类的属性和功能，单继承，多实现、</li>
<li><strong>多态</strong>：一个父类可以有多个子类（对同一方法进行多次重写），一个接口可以有多个实现，一个类可以实现多个接口（对接口进行不同的实现）</li>
</ul>
<h2 id="java与C-区别（都是面向对象）"><a href="#java与C-区别（都是面向对象）" class="headerlink" title="java与C++区别（都是面向对象）"></a>java与C++区别（都是面向对象）</h2><p>C++: 多继承，有指针概念可以手动管理内存</p>
<p>java：单继承但是有多实现，由JVM自动管理内存</p>
<h2 id="多态实现原理"><a href="#多态实现原理" class="headerlink" title="多态实现原理"></a>多态实现原理</h2><p>动态绑定，即在运行时才把方法调用与方法实现关联起来。</p>
<p><strong>静态绑定</strong>：编译时就绑定，比如重载。<br><strong>动态绑定</strong>：运行时绑定，比如重写，实现。</p>
<h2 id="static和final关键字"><a href="#static和final关键字" class="headerlink" title="static和final关键字"></a>static和final关键字</h2><ul>
<li><strong>static</strong>：修饰属性，方法（只会在堆中创建一份共享，随着类的加载而加载）</li>
<li><strong>final</strong>：修饰变量（修饰基础类型就不可被修改，修饰引用类型就不可被指向另一个对象），方法（锁定方法防止被子类重写，private方法隐式设置了final），类（不能被继承且所有方法被指定为final）</li>
</ul>
<h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><p><strong>抽象类</strong>：abstract修饰的类，即包含抽象方法的类。（有抽象方法的类一定是抽象类，但是抽象类不是一定要有抽象方法）；只能被继承（单继承）所以不能被final修饰；不能被实例化（因为可能有没提供完整的实现的方法）</p>
<p><strong>接口</strong>：interface修饰，属于抽象类型的类。。可以被多实现。不可以被实例化（有没提供完整的实现的方法）</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><h4 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a><strong>相同点：</strong></h4><ol>
<li>都不能被实例化</li>
<li>都可以定义抽象方法且子类必须重写</li>
</ol>
<h4 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a><strong>不同点：</strong></h4><ol>
<li>抽象类可以有普通方法，接口只能有抽象方法（默认是public abstract修饰，在java8之后，能存在被default和static修饰的存在方法体的方法）</li>
<li>抽象类有构造方法（可以初始化对象状态），接口没有</li>
<li>抽象类只能被单继承，接口可以被多实现</li>
<li>抽象类可以有不同修饰的成员变量，接口默认都是public static final 修饰</li>
</ol>
<h3 id="适合场景"><a href="#适合场景" class="headerlink" title="适合场景"></a><strong>适合场景</strong></h3><p><strong>抽象类</strong>：</p>
<pre><code>1. 需要有基础功能并且基础功能会经常改变，那就使用抽象类，改变抽象类的基础方法就能让所有子类同时改变，达到解耦的目的。（如果是接口就需要改变每一个实现类中的方法）
1. 拥有一些方法（但不再乎其如何实现）并且想让它们中的一些有默认实现，还想拥有实例变量，需要构造方法。
</code></pre>
<p><strong>接口</strong>：</p>
<ol>
<li>需要多实现的场景（更多需要从业务出发，每个接口涉及不同业务，但是实现类需要涉及两个业务）</li>
<li>需要解耦更加彻底的场景。根据不同条件获取不同实现的场景，用接口可以实现解耦（调用类只需要注入接口不要关心具体要用那个实现类）</li>
</ol>
<h2 id="泛型与泛型擦除"><a href="#泛型与泛型擦除" class="headerlink" title="泛型与泛型擦除"></a>泛型与泛型擦除</h2><p>泛型： 参数化类型，将所需要的类型参数化，用<T>来声明一个类型参数。可以用于类、接口、方法的创建</p>
<p>泛型擦除：java泛型是伪泛型，虽然使用泛型的时候加上类型参数（比如ArrayList<Integer> list &#x3D; new ArrayList<Integer>();）但是编译生成字节码的时候会类型擦除（实际上变成了List）。而由泛型附加的类型信息对 JVM 来说是不可见的。因此说是伪泛型。可以通过反射添加其它类型元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">list.add(1);  //这样调用 add 方法只能存储整形，因为泛型类型的实例为 Integer</span><br><span class="line"></span><br><span class="line">//使用反射想Integer类型中加入String的记录</span><br><span class="line">list.getClass().getMethod(&quot;add&quot;, Object.class).invoke(list, &quot;asd&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p><strong>概念</strong>：在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且都能够调用它的任意一个方法；</p>
<p><strong>如何得到Class的实例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.类名.class(就是一份字节码)</span><br><span class="line">2.Class.forName(String className);根据一个类的全限定名来构建Class对象</span><br><span class="line">3.每一个对象多有getClass()方法:obj.getClass();返回对象的真实类型</span><br></pre></td></tr></table></figure>

<p><strong>适合场景：</strong></p>
<ol>
<li><strong>自定义注解</strong>：对被注解对象的操作需要用反射来执行</li>
<li><strong>动态代理</strong>：AOP中拦截方法使用动态代理就需要反射</li>
<li><strong>开发通用框架</strong></li>
</ol>
<h2 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h2><p><strong>Throwable</strong>是超类，往下分为<strong>Error</strong>和<strong>Exception</strong><br>一般来讲，程序无法捕获的异常就是Error，如JVM内部错误<br>Exception是由程序产生的，分为运行时异常（空指针，数组下标越界等）和编译时异常（语法错误等）</p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20240510220456126.png" alt="image-20240510220456126"></p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="ArrayList和LinkedList"><a href="#ArrayList和LinkedList" class="headerlink" title="ArrayList和LinkedList"></a>ArrayList和LinkedList</h3><p>​	<strong>ArrayList：</strong></p>
<p>​	底层为数组（一段连续的内存），支持对元素的快速访问，适合随机访问，不合适插入和删除（移动元素代价高）。默认初始大小为10（初始化时容量为0，当有第一个数据进来才会初始化空间为10），扩容机制是扩大到当前的1.5倍，然后移动到新数组，移动方法：Array.copyof()。</p>
<p>​	<strong>LinkedList：</strong></p>
<p>​	底层为链表（不需要连续的内存），适合数据插入和删除。可以当作堆栈，队列使用（出栈入栈对应插入删除）</p>
<p><strong>均为线程不安全</strong></p>
<h4 id="实现线程安全："><a href="#实现线程安全：" class="headerlink" title="实现线程安全："></a>实现线程安全：</h4><ol>
<li>使用原生的Vector，但是效率很低。底层通过synchronizedList</li>
<li>使用<strong>CopyOnWriteArrayList</strong>，<strong>写时加锁</strong>，使用了一种叫写时复制的方法；读操作是可以不用加锁的，推荐使用</li>
</ol>
<h4 id="fail-fast"><a href="#fail-fast" class="headerlink" title="fail-fast"></a><strong>fail-fast</strong></h4><p>快速失败机制：</p>
<ul>
<li><p>在迭代器遍历元素的过程中，如果集合的结构（modCount）被改变的话，就会抛出异常ConcurrentModificationException，防止继续遍历。这就是所谓的快速失败机制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 10; i &lt; 100; i++)&#123;</span><br><span class="line">        map.put(i, i);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    for(int i = 0; i &lt; 20; i++)&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line">    int temp = 0;</span><br><span class="line">    while(it.hasNext())&#123;</span><br><span class="line">        if(temp == 3)&#123;</span><br><span class="line">            temp++;</span><br><span class="line">            list.remove(3);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            temp++;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上诉代码会抛出异常，修改成以下代码就不会,不能直接使用集合的 <code>remove</code> 方法来删除元素，而应该使用 <code>Iterator</code> 的 <code>remove</code> 方法，这样可以避免 <code>ConcurrentModificationException</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 使用 Iterator 遍历并删除元素</span><br><span class="line">        Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line">        int temp = 0;</span><br><span class="line">        while (it.hasNext()) &#123;</span><br><span class="line">            if (temp == 3) &#123;</span><br><span class="line">                temp++;</span><br><span class="line">                it.next(); // 移动到下一个元素，因为 remove 需要在 next() 之后调用</span><br><span class="line">                it.remove(); // 使用 Iterator 的 remove 方法</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                temp++;</span><br><span class="line">                System.out.println(it.next());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="fail-safe"><a href="#fail-safe" class="headerlink" title="fail-safe"></a><strong>fail-safe</strong></h4><p>安全失败机制：</p>
<ul>
<li>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。由于在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发ConcurrentModificationException。</li>
<li><strong>缺点</strong>：基于拷贝内容的优点是避免了ConcurrentModificationException，但同样地，迭代器并不能访问到<strong>修改后</strong>的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</li>
<li>适用场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</li>
</ul>
<h3 id="HashMap详解（JDK-1-8）"><a href="#HashMap详解（JDK-1-8）" class="headerlink" title="HashMap详解（JDK 1.8）"></a>HashMap详解（JDK 1.8）</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904111817637901">https://juejin.cn/post/6844904111817637901</a></p>
<h4 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h4><p>​	底层数据结构采用数组+链表+红黑树。通过散列映射来存储键值对数据。</p>
<h4 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h4><p>​	HashMap 是使用哈希表来存储数据的。哈希表为了解决冲突，一般有两种方案：<strong>开放地址法</strong> 和 <strong>链地址法</strong>。HashMap 采用的便是 <strong>链地址法</strong>，即在数组的每个索引处都是一个链表结构，这样就可以有效解决 hash 冲突。</p>
<h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认的初始容量为 16 （PS：aka 应该是 as know as）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大容量（容量不够时需要扩容）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>; <span class="comment">//2的30次方</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认的负载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表长度为 8 的时候会转为红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 长度为 6 的时候会从红黑树转为链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有桶内数据量大于 64 的时候才会允许转红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>初始容量是 16，可以扩容，但是扩容之后的容量，也是 2 的幂次方也就是一倍。另外， <strong>MIN_TREEIFY_CAPACITY</strong>，虽然说当链表长度大于 8 的时候，链表会转为红黑树，但是也是需要满足桶内存储的数据量大于上述这个参数的值，否则不仅不会转红黑树，反而会进行扩容操作。</p>
<p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20240512232213041.png" alt="image-20240512232213041"></p>
<h4 id="重要参数"><a href="#重要参数" class="headerlink" title="重要参数"></a>重要参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map 中存储的数据量，即 key-value 键值对的数量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap 内部结构发生变化的次数，即新增、删除数据的时候都会记录，</span></span><br><span class="line"><span class="comment">// 注意：修改某个 key 的值，并不会改变这个 modCount</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重点，代表最多能容纳的数据量（初始为16 * 0.75 = 12）</span></span><br><span class="line"><span class="comment">// 即最多能容纳的 key-value 键值对的数量</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负载因子，默认为 0.75</span></span><br><span class="line"><span class="comment">// 注意，这个值是可以大于 1 的</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>threshold</strong> 代表最多能容纳的 Node 数量，一般 <code>threshold = 数组长度（初始为16） * loadFactor</code>，也就是说要想 HashMap 能够存储更多的数据（即获得较大的 threshold），有两种方案，一种是扩容（即增大数组长度 ），另一种便是增大负载因子。</p>
<h4 id="自动扩容原理"><a href="#自动扩容原理" class="headerlink" title="自动扩容原理"></a>自动扩容原理</h4><p>​	<strong>初始化为空数组，第-次put 时才实例。</strong>当数据容量size达到threshold 阈值时会触发扩容机制。调用resize()，将<strong>数组长度</strong>扩大到原来的2倍。</p>
<h5 id="threshold阈值怎么计算"><a href="#threshold阈值怎么计算" class="headerlink" title="threshold阈值怎么计算"></a>threshold阈值怎么计算</h5><p>​	threshold &#x3D; 数组长度（初始为16） * loadFactor（负载因子）</p>
<h5 id="数组怎么扩容"><a href="#数组怎么扩容" class="headerlink" title="数组怎么扩容"></a>数组怎么扩容</h5><pre><code> 1. 获取旧数组，旧数组长度，旧数组阈值
 2. 如果旧数组长度 &gt; 0
  	1.  旧数组长度 &gt;=最大值，就将阈值调为Integer.MAX_VALUE（2的31次方-1），数组长度不变；
  	2. 数组长度变为原来的2倍，阈值 = 新数组长度 * 负载因子0.75
 3. 如果旧数组长度 = 0，但是旧阈值 &gt; 0，正常是带参初始化hashmap，将旧阈值作为数组长度
 4. 如果旧数组长度 = 0 ，旧阈值 = 0，就是无参初始化hashmap，将默认初始容量 `DEFAULT_INITIAL_CAPACITY（16）`和默认负载因子 `DEFAULT_LOAD_FACTOR（0.75）`计算出新数组长度 newCap 和新阈值 newThr。
 5. 将旧数组元素复制到新数组，一部分下标索引不变，一部分变为（原索引+旧数据长度）（索引不是指链表位置）
</code></pre>
<h4 id="添加元素时怎么确定存放的底层数组（桶）的索引下标？"><a href="#添加元素时怎么确定存放的底层数组（桶）的索引下标？" class="headerlink" title="添加元素时怎么确定存放的底层数组（桶）的索引下标？"></a>添加元素时怎么确定存放的底层数组（桶）的索引下标？</h4><p>​	通过这个与运算 <code>(n - 1) &amp; hash</code>，其中变量 n 为数组的长度，变量 hash 就是通过 <code>hash()</code> 方法计算后的结果</p>
<h4 id="简单介绍一下-hash-原理？"><a href="#简单介绍一下-hash-原理？" class="headerlink" title="简单介绍一下 hash()原理？"></a>简单介绍一下 <code>hash()</code>原理？</h4><p>​	HashMap的<code>hash()</code>就是将key对象的hashCode值进行处理（降低hash冲突的可能），得到最终的哈希值（hash）</p>
<h4 id="JDK1-7与JDK1-8中HashMap的区别"><a href="#JDK1-7与JDK1-8中HashMap的区别" class="headerlink" title="JDK1.7与JDK1.8中HashMap的区别"></a>JDK1.7与JDK1.8中HashMap的区别</h4><ol>
<li>旧数组长度jdk1.8计算索引方式不同，扩容时计算新索引下标只需要（hash &amp; 旧数组长度）即可，结果为0则新索引&#x3D;原索引n，结果为旧数组长度则新索引&#x3D;原索引n + 旧数组长度。jdk1.7扩容时需要一直（n-1）&amp;hash</li>
<li>1.8的链表引入了红黑树结构，当链表长度大于8且桶数组数据量大于64就变成红黑树，小于6则从红黑树退化为链表，。1.7则是数组+链表。</li>
<li>1.8扩容采用尾插法，1.7用头插法。尾插法能保证节点顺序和之前保持一致。</li>
</ol>
<h4 id="为什么1-8改用红黑树"><a href="#为什么1-8改用红黑树" class="headerlink" title="为什么1.8改用红黑树"></a>为什么1.8改用红黑树</h4><p>​	当hash冲突过多时，链表过长，此时查询效率低下，大于8改为红黑树后查询方式性能得到了很好的提升，从原来的是O(n)到O(logn)。</p>
<h4 id="Hashmap-链表转红黑树条件"><a href="#Hashmap-链表转红黑树条件" class="headerlink" title="Hashmap 链表转红黑树条件"></a>Hashmap 链表转红黑树条件</h4><pre><code>1. 链表长度大于8
1. 数组长度大于64
</code></pre>
<h4 id="HashMap允许空键空值么"><a href="#HashMap允许空键空值么" class="headerlink" title="HashMap允许空键空值么"></a>HashMap允许空键空值么</h4><p>​	HashMap最多只允许一个键为Null(多条会覆盖)，但允许多个值为Null。hash()当key为null为返回0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h4><ol>
<li>两个线程同时计算索引时，可能会得出同一个索引位置，当A获取链表头节点后时间片用完，B获取链表头节点插入，此时A再插入数据就会造成B的数组被覆盖的问题。</li>
<li>（jdk1.7时采用、头插法）两个线程同时触发resize()，同时修改链表结构会产生一个循环链表。此时get会死循环</li>
</ol>
<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>​	解决线程安全问题可以通过<strong>ConcurrentHashMap</strong> 和 <strong>Hashtable</strong>来实现线程安全；</p>
<p>​	HashTable是原始API类，通过synchronize同步修饰，效率低下；</p>
<p>​	ConcurrentHashMap通过分段锁实现，效率比HashTable要好；</p>
<h5 id="数据结构：-1"><a href="#数据结构：-1" class="headerlink" title="数据结构："></a>数据结构：</h5><p>​	和HashMap一样采用数组 + 链表 + 红黑树实现。扩容机制也一样</p>
<h5 id="与1-7区别"><a href="#与1-7区别" class="headerlink" title="与1.7区别"></a>与1.7区别</h5><p>​	jdk1.7的concurrentHashMap使用数组 + segment（段）+分段锁实现，其内部分为一个个段（Segment）数组，Segment 通过继承 ReentrantLock（可重入锁） 来进行加锁。每次锁一个段降低锁的粒度保证线程在段内操作的安全性。但是这样每次确定索引就需要两次定位：</p>
<ol>
<li>hash值 &amp; （段数组长度 - 1），确定所属段</li>
<li>hash值 &amp; （内部数组长度 - 1），确定所在桶</li>
</ol>
<p>​	因此jdk1.8中优化了结构，取消分段锁，使用cas操作（compare and swap）和synchronied关键字实现优化。粒度直接到桶数组元素级别，锁住链表。</p>
<h5 id="不允许key和value为null"><a href="#不允许key和value为null" class="headerlink" title="不允许key和value为null"></a>不允许key和value为null</h5><p>​	容易引起歧义，因为无法确认本身就是null还是被另一个线程修改的key-value</p>
<h5 id="如何保证线程的安全性？"><a href="#如何保证线程的安全性？" class="headerlink" title="如何保证线程的安全性？"></a>如何保证线程的安全性？</h5><p>​	采用大量的分而治之的思想来降低锁的粒度，提升并发性能。使用大量的cas操作保证安全性，而不是和 HashTable 一样，不论什么方法，直接简单粗暴的使用 synchronized关键字来实现。</p>
<p>​	cas：比较交换，通过拿一个旧值（期望值）和旧地址存的值作比较，如果相等就用新值设置并返回true，否则返回false证明已经被另一个线程修改了</p>
<h5 id="多并发下怎么实现扩容"><a href="#多并发下怎么实现扩容" class="headerlink" title="多并发下怎么实现扩容"></a>多并发下怎么实现扩容</h5><p>​	采用分而治之的思想，分段进行扩容，即每个线程负责一段，默认最小是 16。也就是说如果 ConcurrentHashMap 中只有 16 个槽位，那么就只会有一个线程参与扩容。如果大于 16 则根据当前 CPU 数来进行分配，最大参与扩容线程数不会超过 CPU 数。<br>扩容后迁移数据，和hashmap类似，但是会用synchronized对当前节点加锁</p>
<h3 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a><strong>序列化和反序列化</strong></h3><p>​	<strong>序列化：</strong>将java对象转化为字节序列的过程。持久化，用于存储和传输</p>
<p>​	<strong>反序列化：</strong>将字节序列转化为java对象的过程。</p>
<h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a><strong>优点：</strong></h5><p> a、实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上（通常存放在文件里）Redis的RDB</p>
<p> b、利用序列化实现远程通信，即在网络上传送对象的字节序列。 Google的protoBuf</p>
<h5 id="反序列化失败的场景："><a href="#反序列化失败的场景：" class="headerlink" title="反序列化失败的场景："></a><strong>反序列化失败的场景：</strong></h5><p> 序列化ID：serialVersionUID不一致的时候，导致反序列化失败（serialVersionUID是JRE根据类的内部细节自动生成，当修改对象属性或方法，serialVersionUID也会变化）</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a><strong>String</strong></h3><p>String 使用<strong>数组</strong>存储内容，数组使用 <strong>final</strong> 修饰，因此 String 定义的字符串的值也是<strong>不可变的</strong>，线程安全</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">操作效率</th>
<th align="left">线程安全</th>
</tr>
</thead>
<tbody><tr>
<td align="left">String</td>
<td align="left">低</td>
<td align="left">安全（final）</td>
</tr>
<tr>
<td align="left">StringBuffer</td>
<td align="left">中</td>
<td align="left">安全（synchronized）</td>
</tr>
<tr>
<td align="left">StringBuilder</td>
<td align="left">高</td>
<td align="left">非安全</td>
</tr>
</tbody></table>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ol>
<li><p>饿汉式（立即加载）</p>
<p>饿汉式单例模式在类加载时就创建实例，线程安全，但如果实例初始化过程复杂且不一定会用到，可能会浪费资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonEager</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonEager</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 饿汉式在类加载时创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SingletonEager</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonEager</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供公共静态方法获取实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonEager <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>懒汉式 （延迟加载）</p>
<p>线程不安全懒汉式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonLazy</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonLazy</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 懒汉式在需要时创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonLazy instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供公共静态方法获取实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonLazy <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">SingletonLazy</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>线程安全的懒汉式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;   <span class="comment">//禁止指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>) &#123; <span class="comment">//减少加锁的损耗</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="literal">null</span>) <span class="comment">//确认是否初始化完成</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用双重<strong>双重检查锁定</strong>:</p>
<ul>
<li><strong>第一次检查</strong>：在同步块外检查 <code>instance</code> 是否为 <code>null</code>，目的是减少不必要的同步，提升性能。</li>
<li><strong>同步块</strong>：如果第一次检查发现 <code>instance</code> 为 <code>null</code>，进入同步块，确保只有一个线程能够执行此块代码。</li>
<li><strong>第二次检查</strong>：在同步块内再次检查 <code>instance</code> 是否为 <code>null</code>，因为可能有多个线程在第一次检查时都发现 <code>instance</code> 为 <code>null</code>，如果没有第二次检查，那么多个线程可能会创建多个实例。</li>
<li><strong>实例化</strong>：只有在确认 <code>instance</code> 为 <code>null</code> 的情况下，才会创建新的实例。</li>
</ul>
<p><strong>优化，使用静态内部类实现懒汉式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonLazy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonLazy</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 懒汉式在需要时创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonLazyHelper</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SingletonLazy</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonLazy</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供公共静态方法获取实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonLazy <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonLazyHelper.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ol>
<li><strong>私有构造函数</strong>：<code>private Singleton()</code> 确保外部无法实例化该类。</li>
<li><strong>静态内部类</strong>：<code>SingletonHolder</code> 是一个私有的静态内部类，它只在 <code>Singleton.getInstance()</code> 被调用时才会被加载和初始化。</li>
<li><strong>静态初始化器</strong>：<code>private static final Singleton INSTANCE = new Singleton();</code> 由 JVM 保证在类加载时线程安全。</li>
<li><strong>公共静态方法</strong>：<code>public static Singleton getInstance()</code> 通过调用 <code>SingletonHolder.INSTANCE</code> 返回单例实例。</li>
</ol>
<p>这种方式利用了 JVM 类加载机制的线程安全特性，不需要显式的同步机制，同时实现了懒加载，确保了单例实例只有在第一次使用时才会被创建。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><strong>延迟加载</strong>：单例实例在第一次使用时才被创建。</li>
<li><strong>线程安全</strong>：静态内部类的加载和初始化是由 JVM 保证的，天然是线程安全的。</li>
<li><strong>实现简单</strong>：不需要显式的同步代码，代码简洁明了。</li>
</ul>
</li>
</ol>
<h1 id="Spring篇"><a href="#Spring篇" class="headerlink" title="Spring篇"></a>Spring篇</h1><h3 id="设计思想-Beans"><a href="#设计思想-Beans" class="headerlink" title="设计思想&amp;Beans"></a>设计思想&amp;Beans</h3><h4 id="1、IOC-控制反转"><a href="#1、IOC-控制反转" class="headerlink" title="1、IOC 控制反转"></a><strong>1、IOC 控制反转</strong></h4><p> IoC（Inverse of Control:控制反转）是⼀种设计思想，就是将原本在程序中⼿动创建对象的控制权，交由Spring框架来管理。 IoC 在其他语⾔中也有应⽤，并⾮ Spring 特有。</p>
<p> IoC 容器是 Spring⽤来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注⼊。这样可以很⼤程度上简化应⽤的开发，把应⽤从复杂的依赖关系中解放出来。 IoC 容器就像是⼀个⼯⼚⼀样，当我们需要创建⼀个对象的时候，只需要配置好配置⽂件&#x2F;注解即可，完全不⽤考虑对象是如何被创建出来的。</p>
<p><strong>DI 依赖注入</strong></p>
<p> DI:（Dependancy Injection：依赖注入)站在容器的角度，将对象创建依赖的其他对象注入到对象中。</p>
<h4 id="2、AOP-动态代理"><a href="#2、AOP-动态代理" class="headerlink" title="2、AOP 动态代理"></a><strong>2、AOP 动态代理</strong></h4><p> AOP(Aspect-Oriented Programming:⾯向切⾯编程)能够将那些与业务⽆关，却为业务模块所共同调⽤的逻辑或责任（例如事务处理、⽇志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p>
<p> Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接⼝，那么Spring AOP会使⽤JDKProxy，去创建代理对象，<strong>⽽对于没有实现接⼝的对象，就⽆法使⽤ JDK Proxy 去进⾏代理了</strong>，这时候Spring AOP会使⽤基于asm框架字节流的Cglib动态代理 ，这时候Spring AOP会使⽤ Cglib ⽣成⼀个被代理对象的⼦类来作为代理。</p>
<h4 id="3、Bean生命周期"><a href="#3、Bean生命周期" class="headerlink" title="3、Bean生命周期"></a><strong>3、Bean生命周期</strong></h4><p><strong>单例对象：</strong> singleton</p>
<p>总结：单例对象的生命周期和容器相同</p>
<p><strong>多例对象：</strong> prototype</p>
<p>出生：使用对象时spring框架为我们创建</p>
<p>活着：对象只要是在使用过程中就一直活着</p>
<p>死亡：当对象长时间不用且没有其它对象引用时，由java的垃圾回收机制回收</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/ff500845fb259b45f67c7d6fe787850907bedb69b49cb8cf236880c59ce77d83/68747470733a2f2f73302e6c677374617469632e636f6d2f692f696d616765332f4d30312f38392f30432f43677132786c365776487141646d743441414247416e32655369493633312e706e67"><img src="https://camo.githubusercontent.com/ff500845fb259b45f67c7d6fe787850907bedb69b49cb8cf236880c59ce77d83/68747470733a2f2f73302e6c677374617469632e636f6d2f692f696d616765332f4d30312f38392f30432f43677132786c365776487141646d743441414247416e32655369493633312e706e67" alt="img"></a></p>
<p>IOC容器初始化加载Bean流程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">  // 第一步:刷新前的预处理 </span><br><span class="line">  prepareRefresh();</span><br><span class="line">  //第二步: 获取BeanFactory并注册到 BeanDefitionRegistry</span><br><span class="line">  ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">  // 第三步:加载BeanFactory的预准备工作(BeanFactory进行一些设置，比如context的类加载器等)</span><br><span class="line">  prepareBeanFactory(beanFactory);</span><br><span class="line">  try &#123;</span><br><span class="line">    // 第四步:完成BeanFactory准备工作后的前置处理工作 </span><br><span class="line">    postProcessBeanFactory(beanFactory);</span><br><span class="line">    // 第五步:实例化BeanFactoryPostProcessor接口的Bean </span><br><span class="line">    invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">    // 第六步:注册BeanPostProcessor后置处理器，在创建bean的后执行 </span><br><span class="line">    registerBeanPostProcessors(beanFactory);</span><br><span class="line">    // 第七步:初始化MessageSource组件(做国际化功能;消息绑定，消息解析); </span><br><span class="line">    initMessageSource();</span><br><span class="line">    // 第八步:注册初始化事件派发器 </span><br><span class="line">    initApplicationEventMulticaster();</span><br><span class="line">    // 第九步:子类重写这个方法，在容器刷新的时候可以自定义逻辑 </span><br><span class="line">    onRefresh();</span><br><span class="line">    // 第十步:注册应用的监听器。就是注册实现了ApplicationListener接口的监听器</span><br><span class="line">    registerListeners();</span><br><span class="line">    //第十一步:初始化所有剩下的非懒加载的单例bean 初始化创建非懒加载方式的单例Bean实例(未设置属性)</span><br><span class="line">    finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">    //第十二步: 完成context的刷新。主要是调用LifecycleProcessor的onRefresh()方法，完成创建</span><br><span class="line">    finishRefresh();</span><br><span class="line">	&#125;</span><br><span class="line">  ……</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<p>总结：</p>
<p><strong>四个阶段</strong></p>
<ul>
<li>实例化 Instantiation</li>
<li>属性赋值 Populate</li>
<li>初始化 Initialization</li>
<li>销毁 Destruction</li>
</ul>
<p><strong>多个扩展点</strong></p>
<ul>
<li>影响多个Bean<ul>
<li>BeanPostProcessor</li>
<li>InstantiationAwareBeanPostProcessor</li>
</ul>
</li>
<li>影响单个Bean<ul>
<li>Aware</li>
</ul>
</li>
</ul>
<p><strong>完整流程</strong></p>
<ol>
<li>实例化一个Bean－－也就是我们常说的<strong>new</strong>；</li>
<li>按照Spring上下文对实例化的Bean进行配置－－<strong>也就是IOC注入</strong>；</li>
<li>如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String)方法，也就是根据就是Spring配置文件中<strong>Bean的id和name进行传递</strong></li>
<li>如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现setBeanFactory(BeanFactory)也就是Spring配置文件配置的<strong>Spring工厂自身进行传递</strong>；</li>
<li>如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，和4传递的信息一样但是因为ApplicationContext是BeanFactory的子接口，所以<strong>更加灵活</strong></li>
<li>如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessBeforeInitialization()方法，BeanPostProcessor经常被用作是Bean内容的更改，由于这个是在Bean初始化结束时调用那个的方法，也可以被应用于<strong>内存或缓存技</strong>术</li>
<li>如果Bean在Spring配置文件中配置了init-method属性会自动调用其配置的初始化方法。</li>
<li>如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessAfterInitialization()，<strong>打印日志或者三级缓存技术里面的bean升级</strong></li>
<li>以上工作完成以后就可以应用这个Bean了，那这个Bean是一个Singleton的，所以一般情况下我们调用同一个id的Bean会是在内容地址相同的实例，当然在Spring配置文件中也可以配置非Singleton，这里我们不做赘述。</li>
<li>当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，或者根据spring配置的destroy-method属性，调用实现的destroy()方法</li>
</ol>
<h4 id="4、Bean作用域"><a href="#4、Bean作用域" class="headerlink" title="4、Bean作用域"></a><strong>4</strong>、Bean作用域</h4><table>
<thead>
<tr>
<th>名称</th>
<th>作用域</th>
</tr>
</thead>
<tbody><tr>
<td><strong>singleton</strong></td>
<td><strong>单例对象，默认值的作用域</strong></td>
</tr>
<tr>
<td><strong>prototype</strong></td>
<td><strong>每次获取都会创建⼀个新的 bean 实例</strong></td>
</tr>
<tr>
<td>request</td>
<td>每⼀次HTTP请求都会产⽣⼀个新的bean，该bean仅在当前HTTP request内有效。</td>
</tr>
<tr>
<td>session</td>
<td>在一次 HTTP session 中，容器将返回同一个实例</td>
</tr>
<tr>
<td>global-session</td>
<td>将对象存入到web项目集群的session域中,若不存在集群,则global session相当于session</td>
</tr>
</tbody></table>
<p>默认作用域是singleton，多个线程访问同一个bean时会存在线程不安全问题</p>
<p><strong>保障线程安全方法：</strong></p>
<ol>
<li>在Bean对象中尽量避免定义可变的成员变量（不太现实）。</li>
<li>在类中定义⼀个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中</li>
</ol>
<p><strong>ThreadLocal</strong>：</p>
<p> 每个线程中都有一个自己的ThreadLocalMap类对象，可以将线程自己的对象保持到其中，各管各的，线程可以正确的访问到自己的对象。</p>
<p> 将一个共用的ThreadLocal静态实例作为key，将不同对象的引用保存到不同线程的ThreadLocalMap中，然后<strong>在线程执行的各处通过这个静态ThreadLocal实例的get()方法取得自己线程保存的那个对象</strong>，避免了将这个对象作为参数传递的麻烦。</p>
<h4 id="5、循环依赖"><a href="#5、循环依赖" class="headerlink" title="5、循环依赖"></a>5、循环依赖</h4><p> 循环依赖其实就是循环引用，也就是两个或者两个以上的 Bean 互相持有对方，最终形成闭环。比如A 依赖于B，B又依赖于A</p>
<p>Spring中循环依赖场景有:</p>
<ul>
<li><p>prototype 原型 bean循环依赖</p>
</li>
<li><p>构造器的循环依赖（构造器注入）</p>
</li>
<li><p>Field 属性的循环依赖（set注入）</p>
<p>其中，构造器的循环依赖问题无法解决，在解决属性循环依赖时，可以使用懒加载，spring采用的是提前暴露对象的方法。</p>
</li>
</ul>
<p><strong>懒加载@Lazy解决循环依赖问题</strong></p>
<p> Spring 启动的时候会把所有bean信息(包括XML和注解)解析转化成Spring能够识别的BeanDefinition并存到Hashmap里供下面的初始化时用，然后对每个 BeanDefinition 进行处理。普通 Bean 的初始化是在容器启动初始化阶段执行的，而被lazy-init&#x3D;true修饰的 bean 则是在从容器里第一次进行<strong>context.getBean() 时进行触发</strong>。</p>
<p><strong>三级缓存解决循环依赖问题</strong></p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/de2991ecc66213f6d747a23957a07acf037eb3f0f4f0398e1cd1445a6e479fcf/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676c763769767275326c6a333139383071636e31332e6a7067"><img src="https://camo.githubusercontent.com/de2991ecc66213f6d747a23957a07acf037eb3f0f4f0398e1cd1445a6e479fcf/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676c763769767275326c6a333139383071636e31332e6a7067" alt="循环依赖问题"></a></p>
<ol>
<li>Spring容器初始化ClassA通过构造器初始化对象后提前暴露到Spring容器中的singletonFactorys（三级缓存中）。</li>
<li>ClassA调用setClassB方法，Spring首先尝试从容器中获取ClassB，此时ClassB不存在Spring 容器中。</li>
<li>Spring容器初始化ClassB，ClasssB首先将自己暴露在三级缓存中，然后从Spring容器一级、二级、三级缓存中一次中获取ClassA 。</li>
<li>获取到ClassA后将自己实例化放入单例池中，实例 ClassA通过Spring容器获取到ClassB，完成了自己对象初始化操作。</li>
<li>这样ClassA和ClassB都完成了对象初始化操作，从而解决了循环依赖问题。</li>
</ol>
<h5 id="Spring-框架通过-“三级缓存”-机制来解决单例-Bean-的循环依赖问题。三级缓存主要涉及以下三个缓存："><a href="#Spring-框架通过-“三级缓存”-机制来解决单例-Bean-的循环依赖问题。三级缓存主要涉及以下三个缓存：" class="headerlink" title="Spring 框架通过 “三级缓存” 机制来解决单例 Bean 的循环依赖问题。三级缓存主要涉及以下三个缓存："></a>Spring 框架通过 “三级缓存” 机制来解决单例 Bean 的循环依赖问题。三级缓存主要涉及以下三个缓存：</h5><ol>
<li><strong>一级缓存</strong>（singletonObjects）：存储已经完全初始化的单例 Bean。</li>
<li><strong>二级缓存</strong>（earlySingletonObjects）：存储提前暴露的早期单例 Bean，未完成依赖注入但已经实例化。</li>
<li><strong>三级缓存</strong>（singletonFactories）：存储能够创建 Bean 的工厂对象，用于创建 Bean 的代理对象或提前曝光 Bean 的实例。</li>
</ol>
<p>三级缓存解决循环依赖问题的工作机制</p>
<ol>
<li><strong>Bean 实例化</strong>：<ul>
<li>Spring 在创建 Bean 的过程中，首先会实例化该 Bean（即调用构造函数创建 Bean 对象，但未进行依赖注入）。</li>
</ul>
</li>
<li><strong>将 Bean 的工厂对象加入三级缓存</strong>：<ul>
<li>Spring 会将创建 Bean 的工厂对象放入三级缓存（singletonFactories）。</li>
</ul>
</li>
<li><strong>依赖注入</strong>：<ul>
<li>当需要注入依赖时，Spring 会从缓存中获取依赖的 Bean。如果依赖的 Bean 已经在一级缓存中，则直接使用；如果在二级缓存中，也直接使用；如果在三级缓存中，Spring 会通过工厂对象获取 Bean 的早期引用，并将其移动到二级缓存中以供其他 Bean 使用。</li>
</ul>
</li>
<li><strong>完成依赖注入和初始化</strong>：<ul>
<li>一旦依赖注入完成，Spring 会将完全初始化的 Bean 移动到一级缓存中，同时从二级缓存和三级缓存中移除。</li>
</ul>
</li>
</ol>
<p>代码示例</p>
<p>为了更好地理解三级缓存的工作机制，以下是一个简化的代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">java复制代码import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.context.annotation.Scope;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">@Scope(&quot;singleton&quot;)</span><br><span class="line">public class A &#123;</span><br><span class="line">    private final B b;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public A(B b) &#123;</span><br><span class="line">        this.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">@Scope(&quot;singleton&quot;)</span><br><span class="line">public class B &#123;</span><br><span class="line">    private final A a;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public B(A a) &#123;</span><br><span class="line">        this.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，类 <code>A</code> 依赖于类 <code>B</code>，而类 <code>B</code> 也依赖于类 <code>A</code>，形成了循环依赖。</p>
<p>三级缓存的详细工作过程</p>
<ol>
<li><strong>实例化 Bean A</strong>：<ul>
<li>Spring 创建 Bean A 的实例，并将 Bean A 的工厂对象放入三级缓存。</li>
</ul>
</li>
<li><strong>实例化 Bean B</strong>：<ul>
<li>在创建 Bean B 的过程中，发现需要注入 Bean A。</li>
<li>Spring 从三级缓存中获取 Bean A 的工厂对象，通过工厂对象获取 Bean A 的早期引用（即尚未完成依赖注入的实例），并将其放入二级缓存。</li>
</ul>
</li>
<li><strong>完成 Bean B 的实例化和依赖注入</strong>：<ul>
<li>Spring 完成 Bean B 的实例化和依赖注入，将完全初始化的 Bean B 放入一级缓存。</li>
</ul>
</li>
<li><strong>完成 Bean A 的依赖注入</strong>：<ul>
<li>Spring 使用从二级缓存中获取的 Bean B 完成 Bean A 的依赖注入，并将完全初始化的 Bean A 移动到一级缓存。</li>
</ul>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过三级缓存机制，Spring 能够在 Bean 的创建过程中提前暴露一个创建中的 Bean，从而解决单例 Bean 的循环依赖问题。这种机制确保了依赖注入的顺利进行，同时避免了死循环或堆栈溢出错误。然而，这种机制仅适用于单例作用域的 Bean，对于原型作用域的 Bean，Spring 无法使用这种机制来解决循环依赖问题。</p>
<h3 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h3><h4 id="1、-SpringBoot"><a href="#1、-SpringBoot" class="headerlink" title="1、@SpringBoot"></a>1、@SpringBoot</h4><p> <strong>声明bean的注解</strong></p>
<p> <strong>@Component</strong> 通⽤的注解，可标注任意类为 Spring 组件</p>
<p> <strong>@Service</strong> 在业务逻辑层使用（service层）</p>
<p> <strong>@Repository</strong> 在数据访问层使用（dao层）</p>
<p> <strong>@Controller</strong> 在展现层使用，控制器的声明（controller层）</p>
<p> <strong>注入bean的注解</strong></p>
<p> <strong>@Autowired</strong>：默认按照类型来装配注入，**@Qualifier**：可以改成名称</p>
<p> <strong>@Resource</strong>：默认按照名称来装配注入，JDK的注解，新版本已经弃用</p>
<p><strong>@Autowired注解原理</strong></p>
<p> @Autowired的使用简化了我们的开发，</p>
<p> 实现 AutowiredAnnotationBeanPostProcessor 类，该类实现了 Spring 框架的一些扩展接口。 实现 BeanFactoryAware 接口使其内部持有了 BeanFactory（可轻松的获取需要依赖的的 Bean）。 实现 MergedBeanDefinitionPostProcessor 接口，实例化Bean 前获取到 里面的 @Autowired 信息并缓存下来； 实现 postProcessPropertyValues 接口， 实例化Bean 后从缓存取出注解信息，通过反射将依赖对象设置到 Bean 属性里面。</p>
<p><strong>@SpringBootApplication</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class JpaApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(JpaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>@SpringBootApplication</strong>注解等同于下面三个注解：</p>
<ul>
<li><strong>@SpringBootConfiguration：</strong> 底层是<strong>Configuration</strong>注解，说白了就是支持<strong>JavaConfig</strong>的方式来进行配置</li>
<li><strong>@EnableAutoConfiguration：开启自动配置</strong>功能</li>
<li><strong>@ComponentScan：就是扫描</strong>注解，默认是扫描<strong>当前类下</strong>的package</li>
</ul>
<p><strong>其中<code>@EnableAutoConfiguration</code>是关键(启用自动配置)，内部实际上就去加载<code>META-INF/spring.factories</code>文件的信息，然后筛选出以<code>EnableAutoConfiguration</code>为key的数据，加载到IOC容器中，实现自动配置功能！</strong></p>
<p>它主要加载了@SpringBootApplication注解主配置类，这个@SpringBootApplication注解主配置类里边最主要的功能就是SpringBoot开启了一个@EnableAutoConfiguration注解的自动配置功能。</p>
<p><strong>@EnableAutoConfiguration作用：</strong></p>
<p>它主要利用了一个</p>
<p>EnableAutoConfigurationImportSelector选择器给Spring容器中来导入一些组件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Import(EnableAutoConfigurationImportSelector.class)</span><br><span class="line">public @interface EnableAutoConfiguration </span><br></pre></td></tr></table></figure>



<h4 id="2、-SpringMVC"><a href="#2、-SpringMVC" class="headerlink" title="2、@SpringMVC"></a><strong>2、@SpringMVC</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Controller 声明该类为SpringMVC中的Controller</span><br><span class="line">@RequestMapping 用于映射Web请求</span><br><span class="line">@ResponseBody 支持将返回值放在response内，而不是一个页面，通常用户返回json数据</span><br><span class="line">@RequestBody 允许request的参数在request体中，而不是在直接连接在地址后面。</span><br><span class="line">@PathVariable 用于接收路径参数</span><br><span class="line">@RequestMapping(&quot;/hello/&#123;name&#125;&quot;)申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。</span><br></pre></td></tr></table></figure>



<p><strong>SpringMVC原理</strong></p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/d9b573af7586c35692c03cf192231b9518ddd4a92bc805da05032edab42d4916/68747470733a2f2f696d672d626c6f672e6373646e2e6e65742f32303138313032323232343035383631373f77617465726d61726b2f322f746578742f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c3246335957746c5832787861413d3d2f666f6e742f3561364c354c32542f666f6e7473697a652f3430302f66696c6c2f49304a42516b46434d413d3d2f646973736f6c76652f3730"><img src="https://camo.githubusercontent.com/d9b573af7586c35692c03cf192231b9518ddd4a92bc805da05032edab42d4916/68747470733a2f2f696d672d626c6f672e6373646e2e6e65742f32303138313032323232343035383631373f77617465726d61726b2f322f746578742f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c3246335957746c5832787861413d3d2f666f6e742f3561364c354c32542f666f6e7473697a652f3430302f66696c6c2f49304a42516b46434d413d3d2f646973736f6c76652f3730" alt="img"></a></p>
<ol>
<li>客户端（浏览器）发送请求，直接请求到 DispatcherServlet 。</li>
<li>DispatcherServlet 根据请求信息调⽤ HandlerMapping ，解析请求对应的 Handler 。</li>
<li>解析到对应的 Handler （也就是 Controller 控制器）后，开始由HandlerAdapter 适配器处理。</li>
<li>HandlerAdapter 会根据 Handler 来调⽤真正的处理器开处理请求，并处理相应的业务逻辑。</li>
<li>处理器处理完业务后，会返回⼀个 ModelAndView 对象， Model 是返回的数据对象</li>
<li>ViewResolver 会根据逻辑 View 查找实际的 View 。</li>
<li>DispaterServlet 把返回的 Model 传给 View （视图渲染）。</li>
<li>把 View 返回给请求者（浏览器）</li>
</ol>
<h4 id="3、-SpringMybatis"><a href="#3、-SpringMybatis" class="headerlink" title="3、@SpringMybatis"></a>3、@SpringMybatis</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Insert ： 插入sql ,和xml insert sql语法完全一样</span><br><span class="line">@Select ： 查询sql, 和xml select sql语法完全一样</span><br><span class="line">@Update ： 更新sql, 和xml update sql语法完全一样</span><br><span class="line">@Delete ： 删除sql, 和xml delete sql语法完全一样</span><br><span class="line">@Param ： 入参</span><br><span class="line">@Results ： 设置结果集合@Result ： 结果</span><br><span class="line">@ResultMap ： 引用结果集合</span><br><span class="line">@SelectKey ： 获取最新插入id </span><br></pre></td></tr></table></figure>



<p><strong>mybatis如何防止sql注入？</strong></p>
<p> 简单的说就是#{}是经过预编译的，是安全的，**$<strong>{}是未经过预编译的，仅仅是取变量的值，是非安全的，存在SQL注入。在编写mybatis的映射语句时，尽量采用</strong>“#{xxx}”<strong>这样的格式。如果需要实现动态传入表名、列名，还需要做如下修改：添加属性</strong>statementType&#x3D;”STATEMENT”<strong>，同时sql里的属有变量取值都改成</strong>${xxxx}**</p>
<p><strong>Mybatis和Hibernate的区别</strong></p>
<p><strong>Hibernate 框架：</strong></p>
<p> <strong>Hibernate</strong>是一个开放源代码的对象关系映射框架,它对JDBC进行了非常轻量级的对象封装,建立对象与数据库表的映射。是一个全自动的、完全面向对象的持久层框架。</p>
<p><strong>Mybatis框架：</strong></p>
<p> <strong>Mybatis</strong>是一个开源对象关系映射框架，原名：ibatis,2010年由谷歌接管以后更名。是一个半自动化的持久层框架。</p>
<p><strong>区别：</strong></p>
<p><strong>开发方面</strong></p>
<p> 在项目开发过程当中，就速度而言：</p>
<p> hibernate开发中，sql语句已经被封装，直接可以使用，加快系统开发；</p>
<p> Mybatis 属于半自动化，sql需要手工完成，稍微繁琐；</p>
<p> 但是，凡事都不是绝对的，如果对于庞大复杂的系统项目来说，复杂语句较多，hibernate 就不是好方案。</p>
<p><strong>sql优化方面</strong></p>
<p> Hibernate 自动生成sql,有些语句较为繁琐，会多消耗一些性能；</p>
<p> Mybatis 手动编写sql，可以避免不需要的查询，提高系统性能；</p>
<p><strong>对象管理比对</strong></p>
<p> Hibernate 是完整的对象-关系映射的框架，开发工程中，无需过多关注底层实现，只要去管理对象即可；</p>
<p> Mybatis 需要自行管理映射关系；</p>
<h4 id="4、-Transactional"><a href="#4、-Transactional" class="headerlink" title="4、@Transactional"></a>4、@Transactional</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@EnableTransactionManagement </span><br><span class="line">@Transactional</span><br></pre></td></tr></table></figure>



<p>注意事项：</p>
<p> ①事务函数中不要处理耗时任务，会导致长期占有数据库连接。</p>
<p> ②事务函数中不要处理无关业务，防止产生异常导致事务回滚。</p>
<p><strong>事务传播属性</strong></p>
<p><strong>1) REQUIRED（默认属性）</strong> 如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。</p>
<ol>
<li>MANDATORY 支持当前事务，如果当前没有事务，就抛出异常。</li>
<li>NEVER 以非事务方式执行，如果当前存在事务，则抛出异常。</li>
<li>NOT_SUPPORTED 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li>
<li>REQUIRES_NEW 新建事务，如果当前存在事务，把当前事务挂起。</li>
<li>SUPPORTS 支持当前事务，如果当前没有事务，就以非事务方式执行。</li>
</ol>
<p><strong>7) NESTED</strong> （<strong>局部回滚</strong>） 支持当前事务，新增Savepoint点，与当前事务同步提交或回滚。 <strong>嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。</strong></p>
<h3 id="Spring源码阅读"><a href="#Spring源码阅读" class="headerlink" title="Spring源码阅读"></a>Spring源码阅读</h3><h4 id="1、Spring中的设计模式"><a href="#1、Spring中的设计模式" class="headerlink" title="1、Spring中的设计模式"></a><strong>1、Spring中的设计模式</strong></h4><p>参考：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485303&idx=1&sn=9e4626a1e3f001f9b0d84a6fa0cff04a&chksm=cea248bcf9d5c1aaf48b67cc52bac74eb29d6037848d6cf213b0e5466f2d1fda970db700ba41&token=255050878&lang=zh_CN%23rd">spring中的设计模式</a></p>
<p><strong>单例设计模式 :</strong> Spring 中的 Bean 默认都是单例的。</p>
<p><strong>⼯⼚设计模式 :</strong> Spring使⽤⼯⼚模式通过 BeanFactory 、 ApplicationContext 创建bean 对象。</p>
<p><strong>代理设计模式 :</strong> Spring AOP 功能的实现。</p>
<p><strong>观察者模式：</strong> Spring 事件驱动模型就是观察者模式很经典的⼀个应⽤。</p>
<p><strong>适配器模式：</strong>Spring AOP 的增强或通知(Advice)使⽤到了适配器模式、spring MVC 中也是⽤到了适配器模式适配 Controller 。</p>
<h1 id="Springboot"><a href="#Springboot" class="headerlink" title="Springboot"></a>Springboot</h1><p>自动装配原理：</p>
<p>​	基于spring框架的IOC（控制反转）和DI（依赖注入）机制，通过自动配置机制来简化Spring应用的配置过程。主要是通过核心注解@SpringbootApplication，可以看作<code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 注解的集合。其中最主要的是@EnableAutoConfiguration。@EnableAutoConfiguration实际是通过 <code>AutoConfigurationImportSelector</code>类（加载自动装配类），将符合条件的bean进行装配。</p>
<h2 id="自动配置的执行过程"><a href="#自动配置的执行过程" class="headerlink" title="自动配置的执行过程"></a>自动配置的执行过程</h2><p><strong>启动阶段</strong>：应用启动时，Spring Boot会扫描<code>META-INF/spring.factories</code>文件，找到所有自动配置类。</p>
<p><strong>加载阶段</strong>：使用<code>SpringFactoriesLoader</code>加载这些配置类。</p>
<p><strong>条件判断</strong>：对于每个自动配置类，Spring Boot会根据<code>@Conditional</code>注解的条件进行判断，如果满足条件，则装配相应的Bean。</p>
<p><strong>注入阶段</strong>：根据DI机制，将满足条件的Bean注入到Spring上下文中。</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>当
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://1008610.xyz/2022/06/01/JAVA/" title="Java基础">http://1008610.xyz/2022/06/01/JAVA/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/05/%E4%BD%BF%E7%94%A8fastdfs%E4%B8%8A%E4%BC%A0%E8%A7%86%E9%A2%91%E5%B9%B6%E4%BD%BF%E7%94%A8FFmpegFrameGrabberFrameGrabber%E5%9C%A8%E4%B8%8A%E4%BC%A0%E8%A7%86%E9%A2%91%E6%97%B6%E6%88%AA%E5%9B%BE%E4%BD%9C%E4%B8%BA%E5%B0%81%E9%9D%A2/" rel="prev" title="SpringCloud-Nacos：服务注册+配置中心">
      <i class="fa fa-chevron-left"></i> SpringCloud-Nacos：服务注册+配置中心
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/07/01/mysql/" rel="next" title="MySQL基础">
      MySQL基础 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-livere">livere</a></li>
            <li class="tab"><a href="#comment-utterances">utterances</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane livere" id="comment-livere">
              
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC82MDA4Ni8zNjU1Mg=="></div>
  </div>
  
            </div>
            <div class="tab-pane utterances" id="comment-utterances">
              <div class="comments" id="utterances-container"></div>
            </div>
        </div>
      </div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">Java基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">1.1.</span> <span class="nav-text">面向对象三大特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java%E4%B8%8EC-%E5%8C%BA%E5%88%AB%EF%BC%88%E9%83%BD%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89"><span class="nav-number">1.2.</span> <span class="nav-text">java与C++区别（都是面向对象）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.3.</span> <span class="nav-text">多态实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static%E5%92%8Cfinal%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.4.</span> <span class="nav-text">static和final关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.5.</span> <span class="nav-text">抽象类和接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB"><span class="nav-number">1.5.1.</span> <span class="nav-text">区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%90%8C%E7%82%B9%EF%BC%9A"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">相同点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%82%B9%EF%BC%9A"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">不同点：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E5%90%88%E5%9C%BA%E6%99%AF"><span class="nav-number">1.5.2.</span> <span class="nav-text">适合场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E4%B8%8E%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="nav-number">1.6.</span> <span class="nav-text">泛型与泛型擦除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number">1.7.</span> <span class="nav-text">反射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB"><span class="nav-number">1.8.</span> <span class="nav-text">异常体系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.9.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList%E5%92%8CLinkedList"><span class="nav-number">1.9.1.</span> <span class="nav-text">ArrayList和LinkedList</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9A"><span class="nav-number">1.9.1.1.</span> <span class="nav-text">实现线程安全：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fail-fast"><span class="nav-number">1.9.1.2.</span> <span class="nav-text">fail-fast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fail-safe"><span class="nav-number">1.9.1.3.</span> <span class="nav-text">fail-safe</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap%E8%AF%A6%E8%A7%A3%EF%BC%88JDK-1-8%EF%BC%89"><span class="nav-number">1.9.2.</span> <span class="nav-text">HashMap详解（JDK 1.8）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="nav-number">1.9.2.1.</span> <span class="nav-text">数据结构：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95"><span class="nav-number">1.9.2.2.</span> <span class="nav-text">链地址法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="nav-number">1.9.2.3.</span> <span class="nav-text">默认参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E5%8F%82%E6%95%B0"><span class="nav-number">1.9.2.4.</span> <span class="nav-text">重要参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E6%89%A9%E5%AE%B9%E5%8E%9F%E7%90%86"><span class="nav-number">1.9.2.5.</span> <span class="nav-text">自动扩容原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#threshold%E9%98%88%E5%80%BC%E6%80%8E%E4%B9%88%E8%AE%A1%E7%AE%97"><span class="nav-number">1.9.2.5.1.</span> <span class="nav-text">threshold阈值怎么计算</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%80%8E%E4%B9%88%E6%89%A9%E5%AE%B9"><span class="nav-number">1.9.2.5.2.</span> <span class="nav-text">数组怎么扩容</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E6%97%B6%E6%80%8E%E4%B9%88%E7%A1%AE%E5%AE%9A%E5%AD%98%E6%94%BE%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E7%BB%84%EF%BC%88%E6%A1%B6%EF%BC%89%E7%9A%84%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%A0%87%EF%BC%9F"><span class="nav-number">1.9.2.6.</span> <span class="nav-text">添加元素时怎么确定存放的底层数组（桶）的索引下标？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-hash-%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="nav-number">1.9.2.7.</span> <span class="nav-text">简单介绍一下 hash()原理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK1-7%E4%B8%8EJDK1-8%E4%B8%ADHashMap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.9.2.8.</span> <span class="nav-text">JDK1.7与JDK1.8中HashMap的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%881-8%E6%94%B9%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">1.9.2.9.</span> <span class="nav-text">为什么1.8改用红黑树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hashmap-%E9%93%BE%E8%A1%A8%E8%BD%AC%E7%BA%A2%E9%BB%91%E6%A0%91%E6%9D%A1%E4%BB%B6"><span class="nav-number">1.9.2.10.</span> <span class="nav-text">Hashmap 链表转红黑树条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap%E5%85%81%E8%AE%B8%E7%A9%BA%E9%94%AE%E7%A9%BA%E5%80%BC%E4%B9%88"><span class="nav-number">1.9.2.11.</span> <span class="nav-text">HashMap允许空键空值么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-number">1.9.2.12.</span> <span class="nav-text">线程安全问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentHashMap"><span class="nav-number">1.9.2.13.</span> <span class="nav-text">ConcurrentHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A-1"><span class="nav-number">1.9.2.13.1.</span> <span class="nav-text">数据结构：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8E1-7%E5%8C%BA%E5%88%AB"><span class="nav-number">1.9.2.13.2.</span> <span class="nav-text">与1.7区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E5%85%81%E8%AE%B8key%E5%92%8Cvalue%E4%B8%BAnull"><span class="nav-number">1.9.2.13.3.</span> <span class="nav-text">不允许key和value为null</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%9F"><span class="nav-number">1.9.2.13.4.</span> <span class="nav-text">如何保证线程的安全性？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E5%B9%B6%E5%8F%91%E4%B8%8B%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E6%89%A9%E5%AE%B9"><span class="nav-number">1.9.2.13.5.</span> <span class="nav-text">多并发下怎么实现扩容</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">1.9.3.</span> <span class="nav-text">序列化和反序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="nav-number">1.9.3.0.1.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="nav-number">1.9.3.0.2.</span> <span class="nav-text">反序列化失败的场景：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String"><span class="nav-number">1.9.4.</span> <span class="nav-text">String</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.</span> <span class="nav-text">设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.1.</span> <span class="nav-text">单例模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A"><span class="nav-number">2.1.1.</span> <span class="nav-text">解释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-number">2.1.2.</span> <span class="nav-text">优点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E7%AF%87"><span class="nav-number">3.</span> <span class="nav-text">Spring篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-Beans"><span class="nav-number">3.0.1.</span> <span class="nav-text">设计思想&amp;Beans</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81IOC-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC"><span class="nav-number">3.0.1.1.</span> <span class="nav-text">1、IOC 控制反转</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81AOP-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-number">3.0.1.2.</span> <span class="nav-text">2、AOP 动态代理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">3.0.1.3.</span> <span class="nav-text">3、Bean生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81Bean%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">3.0.1.4.</span> <span class="nav-text">4、Bean作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="nav-number">3.0.1.5.</span> <span class="nav-text">5、循环依赖</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Spring-%E6%A1%86%E6%9E%B6%E9%80%9A%E8%BF%87-%E2%80%9C%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E2%80%9D-%E6%9C%BA%E5%88%B6%E6%9D%A5%E8%A7%A3%E5%86%B3%E5%8D%95%E4%BE%8B-Bean-%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98%E3%80%82%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E4%B8%BB%E8%A6%81%E6%B6%89%E5%8F%8A%E4%BB%A5%E4%B8%8B%E4%B8%89%E4%B8%AA%E7%BC%93%E5%AD%98%EF%BC%9A"><span class="nav-number">3.0.1.5.1.</span> <span class="nav-text">Spring 框架通过 “三级缓存” 机制来解决单例 Bean 的循环依赖问题。三级缓存主要涉及以下三个缓存：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.0.2.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring%E6%B3%A8%E8%A7%A3"><span class="nav-number">3.0.3.</span> <span class="nav-text">Spring注解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81-SpringBoot"><span class="nav-number">3.0.3.1.</span> <span class="nav-text">1、@SpringBoot</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81-SpringMVC"><span class="nav-number">3.0.3.2.</span> <span class="nav-text">2、@SpringMVC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81-SpringMybatis"><span class="nav-number">3.0.3.3.</span> <span class="nav-text">3、@SpringMybatis</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81-Transactional"><span class="nav-number">3.0.3.4.</span> <span class="nav-text">4、@Transactional</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB"><span class="nav-number">3.0.4.</span> <span class="nav-text">Spring源码阅读</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81Spring%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.0.4.1.</span> <span class="nav-text">1、Spring中的设计模式</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Springboot"><span class="nav-number">4.</span> <span class="nav-text">Springboot</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">4.1.</span> <span class="nav-text">自动配置的执行过程</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="当"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">当</p>
  <div class="site-description" itemprop="description">live my life</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/bobbyfined" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;bobbyfined" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://baidu.com/" title="https:&#x2F;&#x2F;baidu.com" rel="noopener" target="_blank">百度</a>
        </li>
    </ul>
  </div>

      </div>
      <!--网易云插件-->
      <!--
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 
        src="//music.163.com/outchain/player?type=2&id=2135473788&auto=1&height=66">
      </iframe>
      -->

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2024-08 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">当</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">139k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:06</span>
</div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

<script>
NexT.utils.loadComments(document.querySelector('#utterances-container'), () => {
    // if (typeof parcelRequire === 'function') { return; }
    var js = document.createElement('script');
    js.type = 'text/javascript';
    js.src = 'https://utteranc.es/client.js';
    js.async = true;
    js.crossorigin = 'anonymous';
    js.setAttribute('repo', 'bobbyfined/boke-comments');
    js.setAttribute('issue-term', 'pathname');
    js.setAttribute('theme', 'github-light');
    document.getElementById('utterances-container').appendChild(js);
});
</script>
  
  
    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas>
    <script src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
    <script src="/js/cursor/explosion.min.js"></script>
  



</body>
</html>
