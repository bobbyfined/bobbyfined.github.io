<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/02/19/hello-world/"/>
      <url>/2025/02/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用ollama本地搭建deepseek</title>
      <link href="/2025/02/13/%E4%BD%BF%E7%94%A8ollama%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAdeepseek/"/>
      <url>/2025/02/13/%E4%BD%BF%E7%94%A8ollama%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAdeepseek/</url>
      
        <content type="html"><![CDATA[<h1 id="使用ollama本地搭建deepseek"><a href="#使用ollama本地搭建deepseek" class="headerlink" title="使用ollama本地搭建deepseek"></a>使用ollama本地搭建deepseek</h1><span id="more"></span><h2 id="1、准备工作"><a href="#1、准备工作" class="headerlink" title="1、准备工作"></a>1、准备工作</h2><p>1、电脑配置：确保你的电脑具备一定的硬件性能，至少拥有 8GB 及以上的运行内存和足够的硬盘空间。如果有英伟达显卡，部署和运行会更加流畅。</p><p>2、下载 ollama：你可以在 ollama 的官方网站（<code>https://ollama.ai/</code>）上找到对应你操作系统（Windows、MacOS 或 Linux）的安装包，下载并安装。</p><p>简单来说，如果你的电脑配置满足最低要求（如8GB内存以上），就可以通过工具（如Ollama）轻松实现本地部署<code>DeepSeek</code>。</p><p>实践是检验真理的唯一标准，话不多说，开干。</p><h2 id="2、本地电脑部署DeepSeek大模型具体步骤"><a href="#2、本地电脑部署DeepSeek大模型具体步骤" class="headerlink" title="2、本地电脑部署DeepSeek大模型具体步骤"></a>2、本地电脑部署DeepSeek大模型具体步骤</h2><h4 id="1、安装ollama"><a href="#1、安装ollama" class="headerlink" title="1、安装ollama"></a>1、安装ollama</h4><p>1、本地部署首先要安装ollama，<code>ollama</code> 是一个用于在本地运行大语言模型的工具，它能让你在自己的电脑上轻松部署和使用各类模型。你可以把它理解为，一个装AI的盒子，把AI装在盒子里，方便管理。</p><p>访问<code>ollama</code>下载地址:<code>https://ollama.com/download</code></p><p><img src="/iamges/%E4%BD%BF%E7%94%A8ollama%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAdeepseek/1.png" alt="img"></p><p>根据自己的电脑类型，选择不同版本。</p><p>2、接下来以Windows为例，下载好安装后，双击安装。（傻瓜式安装即可）</p><p><img src="/iamges/%E4%BD%BF%E7%94%A8ollama%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAdeepseek/2.png" alt="img"></p><p>安装完成后，ollama会在后台运行，任务栏会出现一个类似羊驼的图标。<br><img src="/iamges/%E4%BD%BF%E7%94%A8ollama%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAdeepseek/3.png" alt="img"></p><h4 id="2、选择要安装的模型"><a href="#2、选择要安装的模型" class="headerlink" title="2、选择要安装的模型"></a>2、选择要安装的模型</h4><p>1、访问<code>https://ollama.com/search</code>,选择要安装的模型</p><p><img src="/iamges/%E4%BD%BF%E7%94%A8ollama%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAdeepseek/4.png" alt="img"></p><p>2、点击选择<code>deepseek-r1</code>，进入模型参数界面</p><p><img src="/iamges/%E4%BD%BF%E7%94%A8ollama%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAdeepseek/5.png" alt="img"></p><p>这里的数字越大，参数越多，性能越强，所需要的配置也就越高，1.5b代表模型具备15亿参数。</p><p>例如，若要运行14b参数模型，需要大约11.5G显存。也就是你的电脑显卡最好要达到16G。</p><p>若个人学习用途，一般建议安装最小的1.5b版本即可。大多数的个人电脑配置都能跑的起来。具体大家可以根据自己的电脑性能选择。</p><p>3、以<code>1.5b</code>参数为例，选择1.5b参数后，复制红框中的命令<code>ollama run deepseek-r1:1.5b</code>。</p><p><img src="/iamges/%E4%BD%BF%E7%94%A8ollama%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAdeepseek/6.png" alt="img"></p><p>详细地址: <code>https://ollama.com/library/deepseek-r1:1.5b</code></p><h4 id="3、安装模型"><a href="#3、安装模型" class="headerlink" title="3、安装模型"></a>3、安装模型</h4><p>1、打开命令行，在命令行中输入:<code>ollama run deepseek-r1:1.5b</code></p><p><img src="/iamges/%E4%BD%BF%E7%94%A8ollama%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAdeepseek/7.png" alt="img"></p><p>2、下载成功后，就可以与模型对话啦。<br><img src="/iamges/%E4%BD%BF%E7%94%A8ollama%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAdeepseek/8.png" alt="img"></p><p>此时大模型安装在你的电脑上，就算断网也可以继续用，再也不用担心数据泄露了。</p><h4 id="4、使用模型"><a href="#4、使用模型" class="headerlink" title="4、使用模型"></a>4、使用模型</h4><p>安装好模型后，此时我们可以通过命令行的方式，在命令行中发送消息来与DeepSeek 大模型对话。</p><p>1、例如我的第一个问题是：”世界上是先有鸡还是先有蛋？”</p><p><img src="/iamges/%E4%BD%BF%E7%94%A8ollama%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAdeepseek/9.png" alt="img"><br>对于这个问题，回答的还可以，果然是推理型模型，思考的过程也给我们列出来了。</p><p>2、我的第二个问题是：”你是如何看待DeepSeek爆火的原因“？</p><p><img src="/iamges/%E4%BD%BF%E7%94%A8ollama%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAdeepseek/10.png" alt="img"></p><p>这个问题，回答的就太过于敷衍了，直接将DeepSeek的公司背书给出来了，当然也可以理解，毕竟DeepSeek的投喂数据都是几个月前的，那时，它还并没有爆火出圈，而且我们下载的还是最小阉割版模型。</p><p>3、这里还有一个问题，当你关闭电脑后，下次若再想使用本地模型时，只需要启动了<code>ollama</code>，<br>同时打开命令行界面，输入<code>ollama run deepseek-r1:1.5b</code> 即可。因为你之前已经下载过，这次无需下载，可以直接和模型聊天。</p><p><img src="/iamges/%E4%BD%BF%E7%94%A8ollama%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAdeepseek/11.png" alt="img"></p><h4 id="5、为本地模型搭建UI界面"><a href="#5、为本地模型搭建UI界面" class="headerlink" title="5、为本地模型搭建UI界面"></a>5、为本地模型搭建UI界面</h4><p>1、使用命令行方式来和模型对话，对于不会编程的小伙伴来说，太难受了。不过没关系，我们有很多方案可以为你的本地模型搭建UI界面，比如<code>Open-WebUI</code>、<code>Chatbox AI</code>等。</p><p>2、这里我们以ChatBox AI为例，访问:<code>https://chatboxai.app/zh</code></p><p><img src="/iamges/%E4%BD%BF%E7%94%A8ollama%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAdeepseek/12.png" alt="img"><br>选择对应的版本，下载安装。</p><p>3、选择使用自己的 API Key 或者本地模型：</p><p><img src="/iamges/%E4%BD%BF%E7%94%A8ollama%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAdeepseek/13.png" alt="img"></p><p>4、选择本地跑的 <code>deepseek-r1:1.5b</code>模型：</p><p><img src="/iamges/%E4%BD%BF%E7%94%A8ollama%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAdeepseek/14.png" alt="img"></p><p>Ollama 默认使用 端口11434 提供本地服务。当你在本地运行 Ollama 时，可以通过以下地址访问其 API 服务：<br><code>http://localhost:11434</code><br>如果你需要更改默认端口，可以通过设置环境变量 <code>OLLAMA_HOST</code> 来指定新的端口。</p><p>5、在ChatBox对话框中，输入：”先有鸡还是先有蛋“，即可调用本地模型，生成答案</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deepseek </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Cursor中开发Java项目 -- 开发环境常用插件</title>
      <link href="/2025/02/08/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"/>
      <url>/2025/02/08/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="在Cursor中开发Java项目–业务系统开发"><a href="#在Cursor中开发Java项目–业务系统开发" class="headerlink" title="在Cursor中开发Java项目–业务系统开发"></a>在Cursor中开发Java项目–业务系统开发</h1><span id="more"></span><h1 id="一、Cursor-Tab"><a href="#一、Cursor-Tab" class="headerlink" title="一、Cursor Tab"></a>一、Cursor Tab</h1><p>cursor tab 是一个集代码自动提示、自然语言指令的编程助手</p><p>代码自动提示和完成跟以前的 copilot 依然比较相似，就是在光标末尾自动提示接下来可能有用的代码，不过 cursor 对于这种支持更进一步，其还支持：</p><ul><li><p>多行编辑</p></li><li><p>智能重写</p></li><li><p>光标预测</p></li></ul><h2 id="1-自动提示"><a href="#1-自动提示" class="headerlink" title="1. 自动提示"></a>1. 自动提示</h2><p>自动提示会根据光标停留处字符的上下文，给出一定的自动推理，</p><p>给出注释：“<strong>根据给定的区域列表，找出没有子级的区域</strong>”，很快 cursor 就给出了对应的提示，虽然可能我们还没来得及完整阐述具体的需求，不过这种及时快速反馈无疑一定程度上能加速开发，减轻负担</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/1.png" alt="img"></p><h2 id="2-智能重写"><a href="#2-智能重写" class="headerlink" title="2. 智能重写"></a>2. 智能重写</h2><p>以下场景是从另一个项目中拷贝过来的代码，其中的 import 包位置发生了变化，此处 cursor 根据之前的修改历史，推断出此处应该要做右边这种修改，给出了提示，按下 tab 键即可快速完成修改。</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/2.png" alt="img"></p><p>以下的场景是：需要将百度上搜索到的广州行政区域街道数据入库到数据库中，由于数据量不多，直接改成一条insert sql语句，原本是单列的街道数据，匹配数据库表(id, region, create_time, update_time, parent_id) 字段列，如下：</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/3.png" alt="img"></p><p>手动写完一两行value值之后，自动推断出来后面街道行对应的值，因此一直按下 tab 键，快速改完了后面的100多行街道的记录，尤其是区级、街道级这种上下级行政区域之间需要填充 parent_id 字段值，它也能准确识别需求</p><p>以往这种场景虽然靠着vscode多列编辑也基本能完成，不过相对麻烦一些，在cursor中，就轻松很多</p><h2 id="3-多行编辑"><a href="#3-多行编辑" class="headerlink" title="3. 多行编辑"></a>3. 多行编辑</h2><p>相邻多行代码比较相似时，修改其中一行，相邻的若干行会被自动提示相关的修改建议，按下 tab 键可以快速完成修改</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/4.png" alt="img"></p><h2 id="4-光标预测"><a href="#4-光标预测" class="headerlink" title="4. 光标预测"></a>4. 光标预测</h2><p>想要实现光标自动预测，需要打开设置开关，位于右下角：Cursor Tab -&gt; Cursor Prediction: enabled</p><p>像下面修改了一些地方的代码之后，会自动关联出一些其他相似修改的位置，此时会出现一个 “-&gt;tab” 的图标，按下 tab 键光标会自动定位到对应行，此时会出现相关修改建议，再按一下 tab，完成修改</p><p><img src="file:///C:\Users\JIA\AppData\Local\Temp\ksohtml8944\wps31.jpg" alt="img"></p><p><img src="file:///C:\Users\JIA\AppData\Local\Temp\ksohtml8944\wps32.jpg" alt="img"> </p><h2 id="5-自然语言指令"><a href="#5-自然语言指令" class="headerlink" title="5. 自然语言指令"></a>5. 自然语言指令</h2><h3 id="5-1-代码修改："><a href="#5-1-代码修改：" class="headerlink" title="5.1. 代码修改："></a>5.1. 代码修改：</h3><p>这个方法存在一定的bug，我们先来看看让 AI大模型给我们解释理解一下代码逻辑</p><p>光标停留在在代码编辑框内时，按下 cmd &#x2F; command + k，输入以下指令，</p><p>指令：“请问以下 hierarchicalRegion 方法做了什么事，用途是什么？”</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/5.png" alt="img"></p><p>光标停留在在代码编辑框内时，按下 cmd &#x2F; command + k，输入以下指令，</p><p>指令：“regionList中的__部分区域存在父级区域，得到的结果仍把这部分区域当成了顶级区域，哪里有问题，如何修改__？”</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/6.png" alt="img"></p><p>AI大模型发现了代码中存在瑕疵，即在判断当前区域是否存在父级区域前，需要有一个map存有所有的区域ID到区域的关系映射，然后才能从中判断某个父级区域是否存在，这是代码编写过程中产生的纰漏。</p><p>总结一下思路：</p><ol><li><p>代码解释（开发者跟大模型之间__<strong>对齐思路</strong>__）：保证大模型对代码意图的理解跟我们预期一致</p></li><li><p>表达问题：向大模型表达需要分析的问题，或者需要实现的目的</p></li><li><p>执行修改</p></li><li><p>检查</p></li><li><p>迭代（如果问题依旧存在，继续用自然语言反馈）</p></li></ol><p>以下是另一个修改代码的示例：</p><p>光标停留在在代码编辑框内时，按下 cmd &#x2F; command + k，输入以下指令，</p><p>指令：“以下是一个基于 spring cloud gateway 的 filter，请改成基于 jakarta servlet filter，如果其中使用到了响应式API依赖，请用springmvc 下对应的依赖进行替换，注意保持原有逻辑不要省略，要完整替换，不能省略输出”</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/7.png" alt="img"></p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/8.png" alt="img"></p><h3 id="3-2-终端命令"><a href="#3-2-终端命令" class="headerlink" title="3.2. 终端命令"></a>3.2. 终端命令</h3><p>当你想不起某个命令该如何写的时候，光标停留在在终端处时，按下 cmd &#x2F; command + k，输入以下指令，可以快速得到回答</p><p>指令：“需要导出maven依赖到 target&#x2F;dependencies 目录下”</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/9.png" alt="img"></p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/10.png" alt="img"></p><h1 id="二、Composor-chat"><a href="#二、Composor-chat" class="headerlink" title="二、Composor &#x2F; chat"></a>二、Composor &#x2F; chat</h1><p>Composor 是一个对话式交互的编程助手，可以对话提问时灵活指定提问的上下文相关信息，比如 文档、代码、命令行执行日志，如果文档较大可以精确行范围，只要是文字形式的材料都适用</p><p>使用前，可以打开 cursor 设置对对话提示词设置系统规则，比如要求用中文进行回复，避免阅读大量英文回复</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/11.png" alt="img"></p><h2 id="1-AI-Fix"><a href="#1-AI-Fix" class="headerlink" title="1. AI Fix:"></a>1. AI Fix:</h2><p>在ide编辑器窗口编辑代码时遇到语法错误，鼠标悬浮于红线附近，会自动提示 AI Fix</p><p>点击 AI Fix in Chat 之后，报错会在 chat 对话栏向大模型发起提问，寻找解决办法</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/12.png" alt="img"></p><p>对于答案中如有不清晰的部分，进一步提问</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/13.png" alt="img">s</p><h2 id="2-运行错误"><a href="#2-运行错误" class="headerlink" title="2. 运行错误"></a>2. 运行错误</h2><p>程序运行过程中遇到报错了，此时选中报错日志，然后选中区域右上角会出现 </p><p>“add to chat”、”add to composor” 两个按钮，点击任何一个都会将当前选中内容作为一个相关上下文出现在 chat 或者 composor 中</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/14.png" alt="img"></p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/15.png" alt="img"></p><h2 id="3-通过对话开发新的需求代码"><a href="#3-通过对话开发新的需求代码" class="headerlink" title="3. 通过对话开发新的需求代码"></a>3. 通过对话开发新的需求代码</h2><p><strong>以上技巧相对零散，可能都只____是____在局部使用，如果面对新的需求开发，如何让大模型为我们写代码呢？</strong></p><p>为了可以让大模型从头开始帮我们完整地写一个新的需求，需要让他明白我们的需求，这个中间必然会出现理解不到位的时候，此时需要反复的迭代修改。</p><p>相信使用过大模型写实际项目的同事都领会过，有时需求可能并不复杂，但是让它调整到恰好适配我们实际项目环境（比如各种比较个性化的项目配置）就很麻烦，提示一次，修改一个小地方，再提示一次，再修改一个小地方，反复来回，感觉自己上手写更快速了，效率悖论隐约可见～</p><h3 id="3-1-结构化的提示词"><a href="#3-1-结构化的提示词" class="headerlink" title="3.1 结构化的提示词"></a>3.1 结构化的提示词</h3><p>要想使大模型尽可能准确给出符合我们需求的结果，关键在于提示词编写得足够准确和详细恰当</p><p>由于我们需要的代码结果有很大幅度包含很多业务相关细节，同时整个项目使用的架构、依赖组件也有一定的要求，如果只是简单的寥寥数语，没有足够详细的说明，大模型大概率会根据自己训练时遇到的样本材料给出结果。但是如果每次交互都需要编写大段大段的文字，可能也会很累，觉得还不如自己写代码好了。</p><p>所以，此时，我们需要将提示词中常用的文字抽离出来成为一个有针对性的文档，比如用到的第三方依赖组件&#x2F;技术、项目的内不同组件之间的交互&#x2F;协作组织方式、开发规范、代码文件结构规定、外部数据存储方式、开发流程等相对固定的信息，在项目下新建目录存放这些文档，然后后续在进行新的需求任务开发时，每次都将这些文档作为项目上下文信息一并提交给大模型，让他在理解需求之后按照这些规范给我们生成，这样，大概率出来就是我们想要的结果了。这样就不用每次都写很多的文字，出来的结果也具有较高的统一性，比较好维护。</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/16.png" alt="img"></p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/17.png" alt="img"></p><p>在项目实际开发业务需求前编写一定的技术、项目定义的基础文档可能会花费一定的时间，不过这些文档只需要在项目开始时编写一次（后续可能会修改更新），后续可以反复使用</p><p>整理的需求文档也可以在后续因为调整需要重新生成代码的过程中被反复复用</p><p>积累下来的这些文档相当于对整体项目有了一个比较详细的描述，在后续维护、交接的过程中会方便很多，直接交接一个代码仓库就完成很多事了</p><h3 id="3-2-代码生成前的任务拆分"><a href="#3-2-代码生成前的任务拆分" class="headerlink" title="3.2 代码生成前的任务拆分"></a>3.2 代码生成前的任务拆分</h3><p>除了技术上的细节信息，在开发需求的时候，也可以尽量将需求任务按照逻辑进行一定的拆分，如果一开始对于任务拆分没有太好的思路，可以向大模型提问，让他帮我们整理思路，如果反馈的结果跟我们的理解有偏差，可以逐步调整，直至大模型给出的思路符合需求预期。</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/18.png" alt="img"></p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/19.png" alt="img"></p><p>此时的交互还停留在文字版本的思路上，并不是直接生成代码。先让大模型拆分任务，也相当于跟大模型在对齐思路，避免在它生成结果时天马行空发挥，然后再一遍又一遍的阅读它的代码进行调整，面向自然语言对齐思路相对于面向最终代码对齐思路可能会更加容易一些。</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/20.png" alt="img"></p><h3 id="3-3-检验大模型输出结果：测试"><a href="#3-3-检验大模型输出结果：测试" class="headerlink" title="3.3 检验大模型输出结果：测试"></a>3.3 检验大模型输出结果：测试</h3><p>大模型生成的代码有一定的概率会出错，有可能是技术上的，也可能是业务逻辑的理解错误，所以尤其是对于业务逻辑比较复杂的场景，加上一定的测试手段可以比较快速地帮我们发现这些错误。</p><p>让大模型先生成测试，然后面向测试来生成符合需求的代码，这样可以用机器来测试检验生成的代码可靠性，效率会高很多。</p>]]></content>
      
      
      <categories>
          
          <category> cursor </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cursor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Cursor中开发Java项目 -- 开发环境常用插件</title>
      <link href="/2025/02/08/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/"/>
      <url>/2025/02/08/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="在Cursor中开发Java项目-–-开发环境常用插件"><a href="#在Cursor中开发Java项目-–-开发环境常用插件" class="headerlink" title="在Cursor中开发Java项目 – 开发环境常用插件"></a>在Cursor中开发Java项目 – 开发环境常用插件</h1><span id="more"></span><p>在 Cursor 下开发 Java项目主要依赖 vs code 插件，以下主要介绍一些在Java项目开发下常用的插件：</p><ul><li><p>Extension Pack for Java：Java环境插件包(语言功能&#x2F;lombok&#x2F;debug&#x2F;test&#x2F;项目管理&#x2F;maven&#x2F;gradle&#x2F;refactor)</p></li><li><p>maven-dependency-explorer：maven 项目依赖分析</p></li><li><p>Gitlens：git功能增强</p></li><li><p>IntelliJ IDEA Keybindings：IDEA 快捷键</p></li><li><p>SQLTools &#x2F; SQL Notebook：数据库连接查询工具插件</p></li><li><p>Spring Boot Extension Pack：Spring boot 工程支撑插件包（springboot项目脚手架&#x2F;dashboard等）</p></li></ul><h1 id="一、JAVA语言支持插件"><a href="#一、JAVA语言支持插件" class="headerlink" title="一、JAVA语言支持插件"></a>一、JAVA语言支持插件</h1><p>建议安装 Extension Pack for Java 插件大礼包，包含以下插件：</p><ul><li><p>Language support for java by red hat：</p></li><li><p>Debuger for java, </p></li><li><p>Test Runner for Java, </p></li><li><p>Maven for java, </p></li><li><p>Gradle for Java, </p></li><li><p>Project Manager for Java,</p></li><li><p>IntelliCode</p></li></ul><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/1.png" alt="img"></p><h2 id="Java配置"><a href="#Java配置" class="headerlink" title="Java配置"></a>Java配置</h2><p>安装之后 (在settings.json中增加) 相关配置参考：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;java.jdt.ls.java.home&quot;: &quot;/path/to/jdk21_install_path/&quot;,</span><br><span class="line">   &quot;java.completion.enabled&quot;: true,</span><br><span class="line">   &quot;java.configuration.runtimes&quot;: [</span><br><span class="line">       &#123;</span><br><span class="line">           &quot;name&quot;: &quot;JavaSE-1.8&quot;,</span><br><span class="line">           &quot;path&quot;: &quot;/path/to/jdk_install_path&quot;,</span><br><span class="line">           &quot;default&quot;: true</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">           &quot;name&quot;: &quot;JavaSE-1.7&quot;,</span><br></pre></td></tr></table></figure><h1 id="二、项目相关支持"><a href="#二、项目相关支持" class="headerlink" title="二、项目相关支持"></a>二、项目相关支持</h1><p>基于 Project Manager for Java 插件，提供项目创建、依赖管理、打包、结构预览等功能</p><p>（当然现在比较常用的还是使用maven&#x2F;gradle管理项目，如果需要创建普通Java项目，那么还是由该插件支持）</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/2.png" alt="img"></p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/3.png" alt="img"></p><h1 id="三、lombok支持"><a href="#三、lombok支持" class="headerlink" title="三、lombok支持"></a>三、lombok支持</h1><p>常用的 lombok 直接集成进 Language support for Java语言插件里面去了，所以很容易使用</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/4.png" alt="img"></p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/5.png" alt="img"></p><h1 id="四、Debug-开发调试模式"><a href="#四、Debug-开发调试模式" class="headerlink" title="四、Debug 开发调试模式"></a>四、Debug 开发调试模式</h1><p>由 Debuger for java 插件支持</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/6.png" alt="img"></p><p>相关的断点条件也支持</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/8.png" alt="img"></p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/9.png" alt="img"></p><h1 id="五、maven编译插件"><a href="#五、maven编译插件" class="headerlink" title="五、maven编译插件"></a>五、maven编译插件</h1><p>Maven for java 插件支持常见 clean, compile, test, package, install, deploy 等常见命令，跟 IntelliJ IDEA 类似</p><h2 id="1-maven配置"><a href="#1-maven配置" class="headerlink" title="1. maven配置"></a>1. maven配置</h2><p>在用户配置文件中(settings.json)加入配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;java.configuration.maven.globalSettings&quot;: &quot;/path/to/maven_install_path/conf/settings.xml&quot;,</span><br><span class="line">&quot;maven.executable.path&quot;: &quot;/path/to/maven_install_path/bin/mvn&quot;,</span><br></pre></td></tr></table></figure><h2 id="2-JAVA-HOME-设置"><a href="#2-JAVA-HOME-设置" class="headerlink" title="2. JAVA_HOME 设置"></a>2. JAVA_HOME 设置</h2><p>由于Java语言插件服务本身需要JDK17之后的版本，Maven for java 插件是跟语言插件相关的，所以，建议本机 JAVA_HOME 设置成 JDK17以后的版本，可以避免很多问题</p><h2 id="3-依赖分析"><a href="#3-依赖分析" class="headerlink" title="3. 依赖分析"></a>3. 依赖分析</h2><p>对于 IDEA 下常用的依赖分析，可以直接导出 effective pom 来搜索，包含了完整的所有依赖包，下面还有一个插件maven-dependency-explorer 功能更强大</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/10.png" alt="img"></p><h2 id="4-安全漏洞报告分析"><a href="#4-安全漏洞报告分析" class="headerlink" title="4. 安全漏洞报告分析"></a>4. 安全漏洞报告分析</h2><p>插件支持分析依赖中包含的安全漏洞报告</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/11.png" alt="img"></p><h2 id="5-新建-maven-项目流程"><a href="#5-新建-maven-项目流程" class="headerlink" title="5. 新建 maven 项目流程"></a>5. 新建 maven 项目流程</h2><p>这里直接引用之前的另一个文档中的在 cursor 新建 maven 项目流程：</p><p>使用 ctrl + shift + p 打开命令框，输入“java: create java project”，回车，</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/12.png" alt="img"></p><p>选择 maven，回车</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/13.png" alt="img"></p><p>选择项目原型： maven-archetype-quickstart （常用），回车</p><p>选最新版本，回车</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/14.png" alt="img"></p><p>然后输入创建 maven 项目的 group id, artifact id, 项目保存路径等信息，回车，maven 插件就会开始在命令行中执行 maven 项目创建的命令，</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/15.png" alt="img"></p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/16.png" alt="img"></p><p>注意此时 maven 插件会提示确认以上信息，可以直接回车确认</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/17.png" alt="img"></p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/18.png" alt="img"></p><p>然后弹框提示是否在新窗口打开新创建的maven项目</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/19.png" alt="img"></p><p>打开项目之后如下图，默认生成了一个 App.java 类，</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/20.png" alt="img"></p><p>此时点击 Run | Debug ，可以测试一下开发环境是否可以编译执行，正常会在终端命令行得到以下结果（vs-code 环境比起 Idea 环境展示了更多的真实的执行信息，没有把他们隐藏在UI背后）</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/21.png" alt="img"></p><h2 id="6-打包"><a href="#6-打包" class="headerlink" title="6. 打包"></a>6. 打包</h2><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/22.png" alt="img"></p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/23.png" alt="img"></p><h1 id="六、maven-依赖分析"><a href="#六、maven-依赖分析" class="headerlink" title="六、maven 依赖分析"></a>六、maven 依赖分析</h1><p>使用 maven-dependency-explorer 插件</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/24.png" alt="img"></p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/25.png" alt="img"></p><h1 id="七、代码托管：gitlab"><a href="#七、代码托管：gitlab" class="headerlink" title="七、代码托管：gitlab"></a>七、代码托管：gitlab</h1><h2 id="1-新建gitlab远程仓库"><a href="#1-新建gitlab远程仓库" class="headerlink" title="1. 新建gitlab远程仓库"></a>1. 新建gitlab远程仓库</h2><p>在 gitlab&#x2F;github仓库上创建远程仓库，不截图展示了</p><h2 id="2-本地项目初始化-git-目录"><a href="#2-本地项目初始化-git-目录" class="headerlink" title="2. 本地项目初始化 git 目录"></a>2. 本地项目初始化 git 目录</h2><p><img src="file:///C:\Users\JIA\AppData\Local\Temp\ksohtml8944\wps1.jpg" alt="img"></p><h2 id="3-安装-GitLens-插件"><a href="#3-安装-GitLens-插件" class="headerlink" title="3. 安装 GitLens 插件"></a>3. 安装 GitLens 插件</h2><p>GitLens 是vscode下一款对git操作支持较强的插件，本身收费，可以进行使用其完整功能，安装完成之后，左边“源码管理tab”下会多出几个栏</p><p><img src="file:///C:\Users\JIA\AppData\Local\Temp\ksohtml8944\wps2.jpg" alt="img"></p><p>此处贴上一篇对于gitlens使用讲解很详细的，对于git的一些常用操作也有很好的补充讲解，以下是一些演示：</p><h3 id="a-add-commit"><a href="#a-add-commit" class="headerlink" title="a) add &amp; commit"></a>a) add &amp; commit</h3><p><img src="file:///C:\Users\JIA\AppData\Local\Temp\ksohtml8944\wps3.jpg" alt="img"><img src="file:///C:\Users\JIA\AppData\Local\Temp\ksohtml8944\wps4.jpg" alt="img"></p><h3 id="b-push-到远程仓库"><a href="#b-push-到远程仓库" class="headerlink" title="b) push 到远程仓库"></a>b) push 到远程仓库</h3><p><img src="file:///C:\Users\JIA\AppData\Local\Temp\ksohtml8944\wps5.jpg" alt="img"><img src="file:///C:\Users\JIA\AppData\Local\Temp\ksohtml8944\wps6.jpg" alt="img"></p><p><img src="file:///C:\Users\JIA\AppData\Local\Temp\ksohtml8944\wps7.jpg" alt="img"> </p><h3 id="c-从远程仓库拉取更新"><a href="#c-从远程仓库拉取更新" class="headerlink" title="c) 从远程仓库拉取更新"></a>c) 从远程仓库拉取更新</h3><p><img src="file:///C:\Users\JIA\AppData\Local\Temp\ksohtml8944\wps8.jpg" alt="img"></p><p><img src="file:///C:\Users\JIA\AppData\Local\Temp\ksohtml8944\wps9.jpg" alt="img"> </p><h3 id="d-遇到冲突处理"><a href="#d-遇到冲突处理" class="headerlink" title="d) 遇到冲突处理"></a>d) 遇到冲突处理</h3><p><img src="file:///C:\Users\JIA\AppData\Local\Temp\ksohtml8944\wps10.jpg" alt="img"></p><p><img src="file:///C:\Users\JIA\AppData\Local\Temp\ksohtml8944\wps11.jpg" alt="img"> </p><p>在起冲突的情况下，gitlens不允许直接pull更新或者push，需要先解决冲突或者想办法回退本地更改(可以将本地commit回退，然后创建stash暂存起来)之后pull，再push</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/26.png" alt="img"></p><h1 id="八、快捷键：IntelliJ-IDEA-Keybindings"><a href="#八、快捷键：IntelliJ-IDEA-Keybindings" class="headerlink" title="八、快捷键：IntelliJ IDEA Keybindings"></a>八、快捷键：IntelliJ IDEA Keybindings</h1><p>支持使用 IntelliJ IDEA 快捷键</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/27.png" alt="img"></p><h1 id="九、在Cursor下查询数据库"><a href="#九、在Cursor下查询数据库" class="headerlink" title="九、在Cursor下查询数据库"></a>九、在Cursor下查询数据库</h1><h2 id="1-插件：SQLTools"><a href="#1-插件：SQLTools" class="headerlink" title="1. 插件：SQLTools"></a>1. 插件：SQLTools</h2><p>支持连接多种数据源，安装之后在左侧panel中会出现一个连接预览面板</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/28.png" alt="img"></p><p>点击 add new connection 右边选择 driver，一开始默认没有任何 driver，点击 search vs code marketplace，左边自动搜索可用 driver</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/29.png" alt="img"></p><p>安装 mysql、clickhouse 等常用 driver</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/30.png" alt="img"></p><p>新建一个本地mysql连接测试一下</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/31.png" alt="img"></p><p>界面简洁清晰</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/32.png" alt="img"></p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/33.png" alt="img"></p><h2 id="2-插件：SQL-Notebook"><a href="#2-插件：SQL-Notebook" class="headerlink" title="2. 插件：SQL Notebook"></a>2. 插件：SQL Notebook</h2><p>支持类似 python jupyter notebook 风格的操作界面，支持 mysql等多种数据库</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/34.png" alt="img"></p><p>新建一个测试sql文件，右键 open with … SQL Notebook</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/35.png" alt="img"></p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/36.png" alt="img"></p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/37.png" alt="img"></p><h2 id="3-SQLTools、SQL-Notebook-两个插件也可以一起使用，"><a href="#3-SQLTools、SQL-Notebook-两个插件也可以一起使用，" class="headerlink" title="3. SQLTools、SQL Notebook 两个插件也可以一起使用，"></a>3. SQLTools、SQL Notebook 两个插件也可以一起使用，</h2><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/38.png" alt="img"></p><p>以上在 SQL Notebook 下编辑保存之后得到的就是一个 sql 文本文件，可多次编辑保存，提交 git 方便版本控制等等</p><p><img src="/iamges/%E5%9C%A8Cursor%E4%B8%AD%E5%BC%80%E5%8F%91Java%E9%A1%B9%E7%9B%AE--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E7%AF%87/39.png" alt="img"></p><h1 id="十、Java开发重构"><a href="#十、Java开发重构" class="headerlink" title="十、Java开发重构"></a>十、Java开发重构</h1><p>Language support for java by red hat 插件支持重构的常见各种操作，选中需要重构的代码，右键 Refactor (ctrl + T)，会根据代码情况出现相关提示框进行相关操作</p><p><img src="file:///C:\Users\JIA\AppData\Local\Temp\ksohtml8944\wps12.jpg" alt="img"></p><p><img src="file:///C:\Users\JIA\AppData\Local\Temp\ksohtml8944\wps13.jpg" alt="img"> </p><h1 id="十一、开发单元测试"><a href="#十一、开发单元测试" class="headerlink" title="十一、开发单元测试"></a>十一、开发单元测试</h1><p>由 Test Runner for java 插件支持，安装之后左侧 panel 会出现 Test Explorer 面板，列出项目中的单元测试列表，方便执行操作</p><p><img src="file:///C:\Users\JIA\AppData\Local\Temp\ksohtml8944\wps14.jpg" alt="img"></p><p><img src="file:///C:\Users\JIA\AppData\Local\Temp\ksohtml8944\wps15.jpg" alt="img"> </p><h1 id="十二、Spring应用开发"><a href="#十二、Spring应用开发" class="headerlink" title="十二、Spring应用开发"></a>十二、Spring应用开发</h1><h2 id="spring-项目脚手架：Spring-Initializr-Java-Support"><a href="#spring-项目脚手架：Spring-Initializr-Java-Support" class="headerlink" title="spring 项目脚手架：Spring Initializr Java Support"></a>spring 项目脚手架：Spring Initializr Java Support</h2><p>ctrl + shift + p，打开命令框，输入 create java project，然后选择 :</p><p><img src="file:///C:\Users\JIA\AppData\Local\Temp\ksohtml8944\wps16.jpg" alt="img"></p><p>spring boot 工程 &gt; maven project &gt; springboot 版本号 &gt; java 开发语言 &gt; groupId &gt; artifactId &gt; 打包类型(jar) &gt; JDK 版本(看起来现在只支持17及以后的版本了) &gt; 预选依赖(web, mysql, jdbc, redis …) &gt; 项目存放路径 &gt; 然后新窗口打开项目</p><p><img src="file:///C:\Users\JIA\AppData\Local\Temp\ksohtml8944\wps17.jpg" alt="img"><img src="file:///C:\Users\JIA\AppData\Local\Temp\ksohtml8944\wps18.jpg" alt="img"></p><p><img src="file:///C:\Users\JIA\AppData\Local\Temp\ksohtml8944\wps19.jpg" alt="img"><img src="file:///C:\Users\JIA\AppData\Local\Temp\ksohtml8944\wps20.jpg" alt="img"> </p><p><img src="file:///C:\Users\JIA\AppData\Local\Temp\ksohtml8944\wps21.jpg" alt="img"> </p><p><img src="file:///C:\Users\JIA\AppData\Local\Temp\ksohtml8944\wps22.jpg" alt="img"> </p><p><img src="file:///C:\Users\JIA\AppData\Local\Temp\ksohtml8944\wps23.jpg" alt="img"><img src="file:///C:\Users\JIA\AppData\Local\Temp\ksohtml8944\wps24.jpg" alt="img"> </p><p><img src="file:///C:\Users\JIA\AppData\Local\Temp\ksohtml8944\wps25.jpg" alt="img"> </p><p><img src="file:///C:\Users\JIA\AppData\Local\Temp\ksohtml8944\wps26.jpg" alt="img"> </p><h2 id="springboot-应用程序看板：springboot-dashboard"><a href="#springboot-应用程序看板：springboot-dashboard" class="headerlink" title="springboot 应用程序看板：springboot dashboard"></a>springboot 应用程序看板：springboot dashboard</h2><p>启动应用程序之后在左边panel下打开 springboot dashboard，会显示应用程序中对应的bean, api接口, 配置信息等</p><p><img src="file:///C:\Users\JIA\AppData\Local\Temp\ksohtml8944\wps27.jpg" alt="img"></p><h2 id="springboot-项目开发工具：spring-boot-tools"><a href="#springboot-项目开发工具：spring-boot-tools" class="headerlink" title="springboot 项目开发工具：spring boot tools"></a>springboot 项目开发工具：spring boot tools</h2><p>安装插件：Spring Boot Tools</p><p>安装之后，对于springboot项目常用的注解、配置等会有自动提示，</p><p><img src="file:///C:\Users\JIA\AppData\Local\Temp\ksohtml8944\wps28.jpg" alt="img"> </p><p><img src="file:///C:\Users\JIA\AppData\Local\Temp\ksohtml8944\wps29.jpg" alt="img"> </p><p>ctrl + shift + o 快速查看都有哪些接口可以访问，选中可以快速跳转访问测试</p><p><img src="file:///C:\Users\JIA\AppData\Local\Temp\ksohtml8944\wps30.jpg" alt="img"></p><p>注：ctrl+shift+o快捷键本来绑定的操作是文件&#x2F;变量&#x2F;符号等跳转，spring boot tools 插件给这个操作添加了一些：url、rest接口路径mapping 绑定的跳转</p><p>（快捷键有可能跟IntelliJ IDEA keybindings 插件定义的一些快捷键冲突，稍为调整一下即可）</p>]]></content>
      
      
      <categories>
          
          <category> cursor </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cursor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="/2024/12/18/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2024/12/18/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><span id="more"></span><ol><li><p>线程状态</p><ol><li>线程是cpu任务调度的最小单位，每个线程拥有自己独立的程序计数器、虚拟机栈、本地方法栈</li><li>状态分为：创建，就绪，运行，阻塞，死亡</li></ol></li><li><p>线程状态切换</p><table><thead><tr><th>方法</th><th>作用</th><th>区别</th></tr></thead><tbody><tr><td>start</td><td>启动线程，由虚拟机自动调度执行run()方法</td><td>线程处于就绪状态</td></tr><tr><td>run</td><td>线程逻辑代码块处理，JVM调度执行</td><td>线程处于运行状态</td></tr><tr><td>sleep</td><td>让当前正在执行的线程休眠（暂停执行）</td><td>不释放锁</td></tr><tr><td>wait</td><td>使得当前线程等待</td><td>释放同步锁</td></tr><tr><td>notify</td><td>唤醒在此对象监视器上等待的单个线程</td><td>唤醒单个线程</td></tr><tr><td>notifyAll</td><td>唤醒在此对象监视器上等待的所有线程</td><td>唤醒多个线程</td></tr><tr><td>yiled</td><td>停止当前线程，让同等优先权的线程运行</td><td>用Thread类调用</td></tr><tr><td>join</td><td>使当前线程停下来等待，直至另一个调用join方法的线程终止</td><td>用线程对象调用</td></tr></tbody></table></li></ol><p><img src="/iamges/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1.png" alt="img"></p><h3 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h3><ol><li>继承Thread</li><li>实现Runnable</li><li>实现Callable，使用Future</li><li>使用线程池，Executors</li></ol><h4 id="阻塞唤醒过程"><a href="#阻塞唤醒过程" class="headerlink" title="阻塞唤醒过程"></a><strong>阻塞唤醒过程</strong></h4><p><strong>阻塞：</strong></p><p> 这三个方法的调用都会使当前线程阻塞。该线程将会被放置到对该Object的请求等待队列中，然后让出当前对Object所拥有的所有的同步请求。线程会一直暂停所有线程调度，直到下面其中一种情况发生：</p><p>　　　　① 其他线程调用了该Object的notify方法，而该线程刚好是那个被唤醒的线程；</p><p>　　　　② 其他线程调用了该Object的notifyAll方法；</p><p><strong>唤醒：</strong></p><p> 线程将会从等待队列中移除，重新成为可调度线程。它会与其他线程以常规的方式竞争对象同步请求。<strong>一旦它重新获得对象的同步请求，所有之前的请求状态都会恢复，也就是线程调用wait的地方的状态。线程将会在之前调用wait的地方继续运行下去。</strong></p><p><strong>为什么要出现在同步代码块中：</strong></p><p> 由于<code>wait()属于Object方法，调用之后会强制释放当前对象锁，所以在wait()</code> 调用时必须拿到当前对象的监视器monitor对象。因此，wait()方法在同步方法&#x2F;代码块中调用。</p><h4 id="wait和sleep区别"><a href="#wait和sleep区别" class="headerlink" title="wait和sleep区别"></a><strong>wait和sleep区别</strong></h4><ul><li>wait 方法必须在 synchronized 保护的代码中使用，而 sleep 方法并没有这个要求。</li><li>wait 方法会主动释放 monitor 锁，在同步代码中执行 sleep 方法时，并不会释放 monitor 锁。</li><li>wait 方法意味着永久等待，直到被中断或被唤醒才能恢复，不会主动恢复，sleep 方法中会定义一个时间，时间到期后会主动恢复。</li><li>wait&#x2F;notify 是 Object 类的方法，而 sleep 是 Thread 类的方法。</li></ul><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>优点：通过复用已创建的线程，<strong>降低资源损耗</strong>、线程可以直接处理队列中的任务<strong>加快响应速度</strong>、同时便于<strong>统一监控和管理</strong>。</p><h4 id="1、线程池构造函数"><a href="#1、线程池构造函数" class="headerlink" title="1、线程池构造函数"></a><strong>1、线程池构造函数</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 线程池构造函数7大参数</span><br><span class="line">*/</span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,</span><br><span class="line">    TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,</span><br><span class="line">    RejectedExecutionHandler handler) &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>参数介绍：</strong></p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>corePoolSize</td><td>核心线程池大小</td></tr><tr><td>maximumPoolSize</td><td>最大线程池大小</td></tr><tr><td>keepAliveTime</td><td>线程池中超过 corePoolSize 数目的空闲线程最大存活时间；</td></tr><tr><td>TimeUnit</td><td>keepAliveTime 时间单位</td></tr><tr><td>workQueue</td><td>阻塞任务队列</td></tr><tr><td>threadFactory</td><td>新建线程工厂</td></tr><tr><td>RejectedExecutionHandler</td><td>拒绝策略。当提交任务数超过 maxmumPoolSize+workQueue 之和时，任务会交给RejectedExecutionHandler 来处理</td></tr></tbody></table><h4 id="2、线程处理任务过程："><a href="#2、线程处理任务过程：" class="headerlink" title="2、线程处理任务过程："></a><strong>2、线程处理任务过程：</strong></h4><p><img src="/iamges/%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.png" alt="img"></p><ol><li>当线程池小于corePoolSize，新提交任务将创建一个新线程执行任务，即使此时线程池中存在空闲线程。</li><li>当线程池达到corePoolSize时，新提交任务将被放入 workQueue 中，等待线程池中任务调度执行。</li><li>当workQueue已满，且 maximumPoolSize 大于 corePoolSize 时，新提交任务会创建新线程执行任务。</li><li>当提交任务数超过 maximumPoolSize 时，新提交任务由 RejectedExecutionHandler 处理。</li><li>当线程池中超过corePoolSize 线程，空闲时间达到 keepAliveTime 时，关闭空闲线程 。</li></ol><h4 id="3、线程拒绝策略"><a href="#3、线程拒绝策略" class="headerlink" title="3、线程拒绝策略"></a><strong>3、线程拒绝策略</strong></h4><p> 线程池中的线程已经用完了，无法继续为新任务服务，同时，等待队列也已经排满了，再也塞不下新任务了。这时候我们就需要拒绝策略机制合理的处理这个问题。</p><p>JDK 内置的拒绝策略如下：</p><p> **AbortPolicy：**直接抛出异常，阻止系统正常运行。可以根据业务逻辑选择重试或者放弃提交等策略。</p><p> **CallerRunsPolicy ：**只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。</p><p> 不会造成任务丢失，同时减缓提交任务的速度，给执行任务缓冲时间。</p><p> **DiscardOldestPolicy ：**丢弃最老的一个请求，也就是即将被执行的任务，并尝试再次提交当前任务。</p><p> **DiscardPolicy ：**该策略默默地丢弃无法处理的任务，不予任何处理。如果允许任务丢失，这是最好的一种方案。</p><h4 id="4、线程池大小设置"><a href="#4、线程池大小设置" class="headerlink" title="4、线程池大小设置"></a><strong>4、线程池大小设置</strong></h4><ul><li>CPU 密集型（n+1）</li></ul><p> CPU 密集的意思是该任务需要大量的运算，而没有阻塞，CPU 一直全速运行。</p><p> CPU 密集型任务尽可能的少的线程数量，一般为 CPU 核数 + 1 个线程的线程池。</p><ul><li>IO 密集型（2*n）</li></ul><p> 由于 IO 密集型任务线程并不是一直在执行任务，可以多分配一点线程数，如 CPU * 2</p><p> 也可以使用公式：CPU 核心数 *（1+平均等待时间&#x2F;平均工作时间）。</p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><h4 id="1、乐观锁，CAS思想"><a href="#1、乐观锁，CAS思想" class="headerlink" title="1、乐观锁，CAS思想"></a><strong>1、乐观锁，CAS思想</strong></h4><p><strong>java乐观锁机制：</strong></p><p> 乐观锁体现的是悲观锁的反面。它是一种积极的思想，它总是认为数据是不会被修改的，所以是不会对数据上锁的。但是乐观锁在更新的时候会去判断数据是否被更新过。乐观锁的实现方案一般有两种（版本号机制和CAS）。乐观锁适用于<strong>读多写少的场景，这样可以提高系统的并发量</strong>。在Java中 <strong>java.util.concurrent.atomic</strong>下的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p><p>　　乐观锁，大多是基于数据版本 (Version)记录机制实现。即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来 实现。 读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提 交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据 版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p><p><strong>CAS思想：</strong></p><p> CAS就是compare and swap（<strong>比较交换</strong>），是一种很出名的无锁的算法，就是可以不使用锁机制实现线程间的同步。使用CAS线程是不会被阻塞的，所以又称为非阻塞同步。CAS算法涉及到三个操作：</p><p> 需要读写内存值V；进行比较的值A；准备写入的值B</p><p> 当且仅当V的值等于A的值等于V的值的时候，才用B的值去更新V的值，否则不会执行任何操作（比较和替换是一个原子操作-A和V比较，V和B替换），一般情况下是一个<strong>自旋操作</strong>，即<strong>不断重试</strong></p><p><strong>缺点：</strong></p><ol><li>会造成ABA问题，即T1读取内存变量为A,T2修改内存变量为B,T2修改内存变量为A,这时T1再CAS操作A时是可行的。但实际上在T1第二次操作A时，已经被其他线程修改过了</li><li>高并发的情况下，很容易发生并发冲突，如果CAS一直失败，那么就会一直重试，浪费CPU资源</li></ol><p><strong>原子性：</strong></p><p> 功能限制CAS是能保证单个变量的操作是原子性的，在Java中要配合使用volatile关键字来保证线程的安全；当涉及到多个变量的时候CAS无能为力；除此之外CAS实现需要硬件层面的支持，在Java的普通用户中无法直接使用，只能<strong>借助atomic包下的原子类</strong>实现，灵活性受到了限制</p><h4 id="2、synchronized底层实现"><a href="#2、synchronized底层实现" class="headerlink" title="2、synchronized底层实现"></a><strong>2、synchronized底层实现</strong></h4><p>**使用方法：**主要的三种使⽤⽅式</p><p> <strong>修饰实例⽅法:</strong> 作⽤于当前对象实例加锁，进⼊同步代码前要获得当前对象实例的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>修饰静态⽅法:</strong> 也就是给当前类加锁，会作⽤于类的所有对象实例，因为静态成员不属于任何⼀个实例对象，是类成员。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 代码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>修饰代码块:</strong> 指定加锁对象，对给定对象加锁，进⼊同步代码库前要获得给定对象的锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//代码                                  </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>总结：synchronized锁住的资源只有两类：一个是对象</strong>，一个是<strong>类</strong>。</p><p><strong>底层实现：</strong></p><p> 对象头是我们需要关注的重点，它是synchronized实现锁的基础，因为synchronized申请锁、上锁、释放锁都与对象头有关。对象头主要结构是由<code>Mark Word</code> 组成，<strong>其中<code>Mark Word</code>存储对象的hashCode、锁信息或分代年龄或GC标志等信息</strong>。</p><p> 锁也分不同状态，JDK6之前只有两个状态：无锁、有锁（重量级锁），而在JDK6之后对synchronized进行了优化，新增了两种状态，总共就是四个状态：<strong>无锁状态、偏向锁、轻量级锁、重量级锁</strong>，其中无锁就是一种状态了。锁的类型和状态在对象头<code>Mark Word</code>中都有记录，在申请锁、锁升级等过程中JVM都需要读取对象的<code>Mark Word</code>数据。</p><p> 同步代码块是利用 monitorenter 和 monitorexit 指令实现的，而同步方法则是利用 flags 实现的。</p><h4 id="3、ReenTrantLock底层实现"><a href="#3、ReenTrantLock底层实现" class="headerlink" title="3、ReenTrantLock底层实现"></a><strong>3、ReenTrantLock底层实现</strong></h4><p> 由于ReentrantLock是java.util.concurrent包下提供的一套互斥锁，相比Synchronized，ReentrantLock类提供了一些高级功能</p><p><strong>使用方法：</strong></p><p> 基于API层面的互斥锁，需要lock()和unlock()方法配合try&#x2F;finally语句块来完成</p><p><strong>底层实现：</strong></p><p> ReenTrantLock的实现是一种自旋锁，通过循环调用CAS操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。想尽办法避免线程进入内核的阻塞状态是我们去分析和理解锁设计的关键钥匙。</p><p><strong>和synchronized区别：</strong></p><p> 1、<strong>底层实现</strong>：synchronized 是<strong>JVM</strong>层面的锁，是<strong>Java关键字</strong>，通过monitor对象来完成（monitorenter与monitorexit），ReentrantLock 是从jdk1.5以来（java.util.concurrent.locks.Lock）提供的<strong>API层面</strong>的锁。</p><p> 2、<strong>实现原理</strong><strong>：synchronized 的实现涉及到</strong>锁的升级**，具体为无锁、偏向锁、自旋锁、向OS申请重量级锁；ReentrantLock实现则是通过利用<strong>CAS</strong>（CompareAndSwap）自旋机制保证线程操作的原子性和volatile保证数据可见性以实现锁的功能。</p><p> 3、<strong>是否可手动释放：synchronized 不需要用户去手动释放锁，synchronized 代码执行完后系统会自动让线程释放对锁的占用； ReentrantLock则需要用户去手动释放锁，如果没有手动释放锁，就可能导致死锁现象</strong>。</p><p> 4、<strong>是否可中断</strong>synchronized是不可中断类型的锁，除非加锁的代码中出现异常或正常执行完成； ReentrantLock则可以中断，可通过trylock(long timeout,TimeUnit unit)设置超时方法或者将lockInterruptibly()放到代码块中，调用interrupt方法进行中断。</p><p> 5、<strong>是否公平锁</strong>synchronized为非公平锁 ReentrantLock则即可以选公平锁也可以选非公平锁，通过构造方法new ReentrantLock时传入boolean值进行选择，为空默认false非公平锁，true为公平锁,公平锁性能非常低。</p><h4 id="4、公平锁和非公平锁区别"><a href="#4、公平锁和非公平锁区别" class="headerlink" title="4、公平锁和非公平锁区别"></a><strong>4、公平锁和非公平锁区别</strong></h4><p><strong>公平锁：</strong></p><p> 公平锁自然是遵循<strong>FIFO</strong>（先进先出）原则的，先到的线程会优先获取资源，后到的会进行排队等待</p><p> **优点：**所有的线程都能得到资源，不会饿死在队列中。适合大任务</p><p> **缺点：**吞吐量会下降，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销大</p><p><strong>非公平锁：</strong></p><p> 多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</p><p> **优点：**可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。</p><p> **缺点：**你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁</p><p><img src="/iamges/%E5%A4%9A%E7%BA%BF%E7%A8%8B/3.png" alt="img"></p><h4 id="5、使用层面锁优化"><a href="#5、使用层面锁优化" class="headerlink" title="5、使用层面锁优化"></a><strong>5、使用层面锁优化</strong></h4><p> 【1】<strong>减少锁的时间：</strong> 不需要同步执行的代码，能不放在同步快里面执行就不要放在同步快内，可以让锁尽快释放；</p><p> 【2】<strong>减少锁的粒度：</strong> 它的思想是将物理上的一个锁，拆成逻辑上的多个锁，增加并行度，从而降低锁竞争。它的思想也是用空间来换时间；java中很多数据结构都是采用这种方法提高并发操作的效率，比如：</p><p> <strong>ConcurrentHashMap：</strong></p><p> java中的ConcurrentHashMap在jdk1.8之前的版本，使用一个Segment 数组：Segment&lt; K,V &gt;[] segments</p><p> Segment继承自ReenTrantLock，所以每个Segment是个可重入锁，每个Segment 有一个HashEntry&lt; K,V &gt;数组用来存放数据，put操作时，先确定往哪个Segment放数据，只需要锁定这个Segment，执行put，其它的Segment不会被锁定；所以数组中有多少个Segment就允许同一时刻多少个线程存放数据，这样增加了并发能力。</p><p> 【3】<strong>锁粗化：</strong> 大部分情况下我们是要让锁的粒度最小化，锁的粗化则是要增大锁的粒度;</p><p> 假如有一个循环，循环内的操作需要加锁，我们应该把锁放到循环外面，否则每次进出循环，都进出一次临界区，效率是非常差的；</p><p> 【4】<strong>使用读写锁：</strong></p><p> ReentrantReadWriteLock 是一个读写锁，读操作加读锁，可并发读，写操作使用写锁，只能单线程写；</p><p> 【5】<strong>使用CAS：</strong></p><p> 如果需要同步的操作执行速度非常快，并且线程竞争并不激烈，这时候使用cas效率会更高，因为加锁会导致线程的上下文切换，如果上下文切换的耗时比同步操作本身更耗时，且线程对资源的竞争不激烈，使用volatiled+cas操作会是非常高效的选择；</p><h4 id="7、ThreadLocal原理"><a href="#7、ThreadLocal原理" class="headerlink" title="7、ThreadLocal原理"></a><strong>7、ThreadLocal原理</strong></h4><p><strong>ThreadLocal简介：</strong></p><p> 通常情况下，我们创建的变量是可以被任何⼀个线程访问并修改的。如果想实现每⼀个线程都有⾃⼰的 专属本地变量该如何解决呢？ JDK中提供的 ThreadLocal 类正是为了解决这样的问题。类似操作系统中的TLAB</p><p><strong>原理：</strong></p><p> 首先 ThreadLocal 是一个泛型类，保证可以接受任何类型的对象。因为一个线程内可以存在多个 ThreadLocal 对象，所以其实是 ThreadLocal 内部维护了一个 Map ，是 ThreadLocal 实现的一个叫做 ThreadLocalMap 的静态内部类。</p><p> 最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。</p><p> 我们使用的 get()、set() 方法其实都是调用了这个ThreadLocalMap类对应的 get()、set() 方法。例如下面的</p><p><strong>如何使用：</strong></p><p> 1）存储用户Session</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final ThreadLocal threadSession = new ThreadLocal();</span><br></pre></td></tr></table></figure><p> 2）解决线程安全的问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static ThreadLocal&lt;SimpleDateFormat&gt; format1 = new ThreadLocal&lt;SimpleDateFormat&gt;()</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            threadLocal.set((<span class="type">int</span>) (Math.random() * <span class="number">100D</span>));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - Value: &quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>ThreadLocal内存泄漏的场景</strong></p><p> 实际上 ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，⽽ value 是强引⽤。弱引用的特点是，如果这个对象持有弱引用，那么在下一次垃圾回收的时候必然会被清理掉。</p><p> 所以如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会被清理掉的，这样一来 ThreadLocalMap中使用这个 ThreadLocal 的 key 也会被清理掉。但是，value 是强引用，不会被清理，这样一来就会出现 key 为 null 的 value。 假如我们不做任何措施的话，value 永远⽆法被GC 回收，如果线程长时间不被销毁，可能会产⽣内存泄露。</p><p><img src="/iamges/%E5%A4%9A%E7%BA%BF%E7%A8%8B/4.png" alt="img"></p><p> ThreadLocalMap实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。如果说会出现内存泄漏，那只有在出现了 key 为 null 的记录后，没有手动调用 remove() 方法，并且之后也不再调用 get()、set()、remove() 方法的情况下。因此使⽤完ThreadLocal ⽅法后，<strong>最好⼿动调⽤ remove() ⽅法</strong>。</p><h4 id="8、HashMap线程安全"><a href="#8、HashMap线程安全" class="headerlink" title="8、HashMap线程安全"></a><strong>8、HashMap线程安全</strong></h4><p> <strong>死循环造成 CPU 100%</strong></p><p> HashMap 有可能会发生死循环并且造成 CPU 100% ，这种情况发生最主要的原因就是在<strong>扩容</strong>的时候，也就是内部<strong>新建新的 HashMap</strong> 的时候，扩容的逻辑会<strong>反转散列桶中的节点顺序</strong>，当有多个线程同时进行扩容的时候，由于 HashMap 并非线程安全的，所以如果<strong>两个线程同时反转的话，便可能形成一个循环</strong>，并且这种循环是链表的循环，相当于 A 节点指向 B 节点，B 节点又指回到 A 节点，这样一来，在下一次想要获取该 key 所对应的 value 的时候，便会在遍历链表的时候发生永远无法遍历结束的情况，也就发生 CPU 100% 的情况。</p><p> 所以综上所述，HashMap 是线程不安全的，在多线程使用场景中推荐使用线程安全同时性能比较好的 <strong>ConcurrentHashMap</strong>。</p><h4 id="9、String不可变原因"><a href="#9、String不可变原因" class="headerlink" title="9、String不可变原因"></a>9、String不可变原因</h4><ol><li>可以使用<strong>字符串常量池</strong>，多次创建同样的字符串会指向同一个内存地址</li><li>可以很方便地用作 <strong>HashMap 的 key</strong>。通常建议把不可变对象作为 HashMap的 key</li><li>hashCode生成后就不会改变，使用时无需重新计算</li><li>线程安全，因为具备不变性的对象一定是线程安全的</li></ol><h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><p> Java 内存模型（Java Memory Model，JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了 Java 程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</p><p><img src="/iamges/%E5%A4%9A%E7%BA%BF%E7%A8%8B/5.png" alt="img"></p><p> JMM 是一种规范，是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。目的是保证并发编程场景中的原子性、可见性和有序性。</p><p><strong>原子性：</strong></p><p> 在 Java 中，为了保证原子性，提供了两个高级的字节码指令 Monitorenter 和 Monitorexit。这两个字节码，在 Java 中对应的关键字就是 Synchronized。因此，在 Java 中可以使用 Synchronized 来保证方法和代码块内的操作是原子性的。</p><p><strong>可见性：</strong></p><p> Java 中的 Volatile 关键字修饰的变量在被修改后可以立即同步到主内存。被其修饰的变量在每次使用之前都从主内存刷新。因此，可以使用 Volatile 来保证多线程操作时变量的可见性。除了 Volatile，Java 中的 Synchronized 和 Final 两个关键字也可以实现可见性。只不过实现方式不同</p><p><strong>有序性</strong></p><p> 在 Java 中，可以使用 Synchronized 和 Volatile 来保证多线程之间操作的有序性。区别：Volatile 禁止指令重排。Synchronized 保证同一时刻只允许一条线程操作。</p><h4 id="1、volatile底层实现"><a href="#1、volatile底层实现" class="headerlink" title="1、volatile底层实现"></a><strong>1、volatile底层实现</strong></h4><p><strong>作用：</strong></p><p> 保证数据的“可见性”：被volatile修饰的变量能够保证每个线程能够获取该变量的最新值，从而避免出现数据脏读的现象。</p><p> 禁止指令重排：在多线程操作情况下，指令重排会导致计算结果不一致</p><p><strong>什么是指令重排序：</strong></p><p>是对于<strong>没有相互依赖的操作</strong>，cpu和编译器会将他们优化指令的排序。比如 int a &#x3D; 0; int b &#x3D; 0;</p><p><strong>底层实现：</strong></p><p> “观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p><p>　　lock前缀指令实际上相当于一个<strong>内存屏障</strong>（也成内存栅栏），内存屏障会提供3个功能：</p><p>　　1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；</p><p>　　2）它会强制将对缓存的修改操作立即写入主存；</p><p>　　3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p><p><strong>单例模式中volatile的作用：</strong></p><p>防止代码读取到instance不为null时，instance引用的对象有可能还没有完成初始化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Singleton&#123;</span><br><span class="line">    private volatile static Singleton instance = null;   //禁止指令重排</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if(instance==null) &#123; //减少加锁的损耗</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if(instance==null) //确认是否初始化完成</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>双重检查锁定</strong>:</p><ul><li><strong>第一次检查</strong>：在同步块外检查 <code>instance</code> 是否为 <code>null</code>，目的是减少不必要的同步，提升性能。</li><li><strong>同步块</strong>：如果第一次检查发现 <code>instance</code> 为 <code>null</code>，进入同步块，确保只有一个线程能够执行此块代码。</li><li><strong>第二次检查</strong>：在同步块内再次检查 <code>instance</code> 是否为 <code>null</code>，因为可能有多个线程在第一次检查时都发现 <code>instance</code> 为 <code>null</code>，如果没有第二次检查，那么多个线程可能会创建多个实例。</li><li><strong>实例化</strong>：只有在确认 <code>instance</code> 为 <code>null</code> 的情况下，才会创建新的实例。</li></ul><h4 id="2、AQS思想"><a href="#2、AQS思想" class="headerlink" title="2、AQS思想"></a><strong>2、AQS思想</strong></h4><p><strong>可以用来自定义锁</strong><br>例子<a href="https://blog.csdn.net/Chianz632/article/details/113347388">https://blog.csdn.net/Chianz632/article/details/113347388</a></p><p> AQS的全称为（AbstractQueuedSynchronizer）抽象的队列式的同步器，<strong>是⼀个⽤来构建锁和同步器的框架</strong>，使⽤AQS能简单且⾼效地构造出应⽤⼴泛的⼤量的同步器，如：基于AQS实现的lock, CountDownLatch、CyclicBarrier、Semaphore需解决的问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">状态的原子性管理</span><br><span class="line">线程的阻塞与解除阻塞</span><br><span class="line">队列的管理</span><br></pre></td></tr></table></figure><p>ReentrantLock基于他实现同步</p><p> AQS核⼼思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的⼯作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占⽤，那么就需要⼀套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是⽤**CLH（虚拟的双向队列）**队列锁实现的，即将暂时获取不到锁的线程加⼊到队列中。</p><p><strong>lock：</strong></p><p> 是一种可重入锁，除了能完成 synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。默认为非公平锁，但可以初始化为公平锁； 通过方法 lock()与 unlock()来进行加锁与解锁操作；</p><p><strong>CountDownLatch：</strong></p><p> 通过计数法（倒计时器），让一些线程堵塞直到另一个线程完成一系列操作后才被唤醒；该⼯具通常⽤来控制线程等待，它可以让某⼀个线程等待直到倒计时结束，再开始执⾏。具体可以使用countDownLatch.await()来等待结果。多用于多线程信息汇总。</p><p><strong>CompletableFuture：</strong></p><p> 通过设置参数，可以完成CountDownLatch同样的多平台响应问题，但是可以针对其中部分返回结果做更加灵活的展示。</p><p><strong>CyclicBarrier：</strong></p><p> 字面意思是可循环(Cyclic)使用的屏障（Barrier）。他要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的await()方法。可以用于批量发送消息队列信息、异步限流。</p><p><strong>Semaphore：</strong></p><p> 信号量主要用于两个目的，一个是用于多个共享资源的互斥作用，另一个用于并发线程数的控制。SpringHystrix限流的思想</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ansible-playbook</title>
      <link href="/2024/12/01/ansible-playbook/"/>
      <url>/2024/12/01/ansible-playbook/</url>
      
        <content type="html"><![CDATA[<h1 id="ansible-playbook"><a href="#ansible-playbook" class="headerlink" title="ansible-playbook"></a>ansible-playbook</h1><span id="more"></span><p><strong>1.playbook的相关知识</strong></p><p><strong>1.1 playbook 的简介</strong></p><p>playbook是 一个不同于使用Ansible命令行执行方式的模式，其功能更强大灵活。简单来说，playbook是一个非常简单的配置管理和多主机部署系统，不同于任何已经存在的模式，可作为一个适合部署复杂应用程序的基础。Playbook可以定制配置，可以按照指定的操作步骤有序执行，支持同步和异步方式。我们完成一个任务，例如安装部署一个httpd服务，我们需要多个模块（一个模块也可以称之为task）提供功能来完成。而playbook就是组织多个task的容器，他的实质就是一个文件，有着特定的组织格式，它采用的语法格式是YAML（Yet Another Markup Language）。</p><p><strong>1.2 playbook的 各部分组成</strong></p><p>（1）Tasks：任务，即通过 task 调用 ansible 的模板将多个操作组织在一个 playbook 中运行</p><p>（2）Variables：变量</p><p>（3）Templates：模板</p><p>（4）Handlers：处理器，当changed状态条件满足时，（notify）触发执行的操作</p><p>（5）Roles：角色</p><p>示例：</p><p><img src="/iamges/ansible-playbook/1.png" alt="img"></p><ol start="2"><li><h2 id="基础的playbook剧本编写实例"><a href="#基础的playbook剧本编写实例" class="headerlink" title="基础的playbook剧本编写实例"></a>基础的playbook剧本编写实例</h2></li></ol><p>**playbook中运用的模块就是ansible中的模块，就像docker-compose一样将docker操作容器的指令归纳为一个yaml文件，开启运行yaml中的指令模块就能按照预设计的方向去完成。 **</p><p><strong>实例1：playbook编写 apache的yum安装部署剧本</strong></p><p>剧本编写实现的需求：对Ansible管理的所有的webservers组的成员，yum安装最新版本的apache服务软件，并进行相应环境的调整，确保webservers的apache服务能够正常运行并设置开机自启</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/ansible    #在ansible的所在目录中创建该项目的目录</span><br><span class="line">mkdir apache</span><br><span class="line">vim apache.yaml</span><br><span class="line">---</span><br><span class="line">- name: apache yum apply</span><br><span class="line">  gather_facts: false</span><br><span class="line">  hosts: webservers</span><br><span class="line">  remote_user: root</span><br><span class="line">  tasks:</span><br><span class="line">   - name: test connection</span><br><span class="line">     ping:</span><br><span class="line"> </span><br><span class="line">   - name: stop firewalld</span><br><span class="line">     service: name=firewalld state=stopped</span><br><span class="line"> </span><br><span class="line">   - name: stop selinux</span><br><span class="line">     command: &#x27;/usr/sbin/setenforce 0&#x27;</span><br><span class="line">     ignore_errors: true</span><br><span class="line"> </span><br><span class="line">   - name: yum install apache service</span><br><span class="line">     yum: name=httpd state=latest</span><br><span class="line"> </span><br><span class="line">   - name: start apache service</span><br><span class="line">     service: name=httpd state=started enabled=yes</span><br></pre></td></tr></table></figure><p><img src="/iamges/ansible-playbook/2.png" alt="img"></p><p><strong>运行剧本的方法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//运行playbook</span><br><span class="line">ansible-playbook apache.yaml</span><br><span class="line">//携带参数，并行的级别 是10</span><br><span class="line">ansible-playbook playbook.yml -e &quot;&quot; -f 10</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//补充参数：</span><br><span class="line">-k（–ask-pass）：用来交互输入ssh密码</span><br><span class="line">-K（-ask-become-pass）：用来交互输入sudo密码</span><br><span class="line">-u：指定用户</span><br><span class="line">ansible-playbook apache.yaml --syntax-check    #检查yaml文件的语法是否正确</span><br><span class="line">ansible-playbook apache.yaml --list-task       #检查tasks任务</span><br><span class="line">ansible-playbook apache.yaml --list-hosts      #检查生效的主机</span><br><span class="line">ansible-playbook apache.yaml --start-at-task=&#x27;install httpd&#x27;     #指定从某个task开始运行</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>**1. **<strong>在 Ansible 中，每个任务都在独立的 shell 中运行，命令只影响当前任务，不会影响其他任务</strong></p><p>例如：如果你想cd &#x2F;data，sh test.sh，你这样写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: group2</span><br><span class="line">  remote_user: root</span><br><span class="line">  gather_facts: no</span><br><span class="line">  become: no</span><br><span class="line">  become_user: root</span><br><span class="line">  become_method: sudo</span><br><span class="line">  tasks:</span><br><span class="line">    - name: cd /data</span><br><span class="line">      command: cd /data</span><br><span class="line">      register: cd_result</span><br><span class="line">    - debug: </span><br><span class="line">        var: cd_result</span><br><span class="line">      ignore_errors: yes</span><br><span class="line"></span><br><span class="line">    - name: sh test.sh</span><br><span class="line">      shell: &quot;sh test.sh&quot;</span><br><span class="line">      register: test_sh_result</span><br><span class="line">    - debug: </span><br><span class="line">        var: test_sh_result.stdout</span><br></pre></td></tr></table></figure><p>是执行不成功的，因为第二个任务所在路径是根路径，不会因为第一个任务而改变</p><p>可以使用shell模块的<code>|</code>符号执行两条连贯的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: group2</span><br><span class="line">  remote_user: root</span><br><span class="line">  gather_facts: no</span><br><span class="line">  become: no</span><br><span class="line">  become_user: root</span><br><span class="line">  become_method: sudo</span><br><span class="line">  tasks:</span><br><span class="line">    - name: Change to /data and execute test.sh</span><br><span class="line">      shell: |</span><br><span class="line">        cd /data</span><br><span class="line">        sh test.sh</span><br></pre></td></tr></table></figure><p><strong>在这个 Playbook 中，<strong><strong>shell</strong></strong> 模块使用了 <strong><strong>|</strong></strong> 符号，它允许你在多行中编写 Shell 命令。这样，<strong><strong>cd &#x2F;data</strong></strong> 和 <strong><strong>sh test.sh</strong></strong> 两个命令都在同一个 Shell 中执行。</strong></p><p><strong>2. command模块和shell模块依赖目标主机的python，如果目标主机没装python，可以用raw（执行命令），script（执行脚本）</strong></p><p><strong>3.关于inventory文件</strong></p><p>对于需要登录上去之后切换其他用户，新版本使用ansible_become， ansible_become_user, ansible_become_pass，对每一台设置是否需要切换，以及切换的用户名密码，旧版本使用ansible_sudo_pass</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">别名（不能使用#连接ip，会被默认为主机ip）  ansible_ssh_host=172.168.201.32  ansible_ssh_user=user1  ansible_ssh_pass=&#x27;passwd&#x27; ansible_become=true ansible_become_user=user2  ansible_become_pass=&#x27;passwd&#x27;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ansible </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ansbile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ansible-ad-hoc以及模块</title>
      <link href="/2024/10/14/ansible-ad-hoc%E4%BB%A5%E5%8F%8A%E6%A8%A1%E5%9D%97/"/>
      <url>/2024/10/14/ansible-ad-hoc%E4%BB%A5%E5%8F%8A%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="ansible-ad-hoc以及模块"><a href="#ansible-ad-hoc以及模块" class="headerlink" title="ansible-ad-hoc以及模块"></a>ansible-ad-hoc以及模块</h1><span id="more"></span><h1 id="Ansible功能介绍"><a href="#Ansible功能介绍" class="headerlink" title="Ansible功能介绍"></a><strong>Ansible功能介绍</strong></h1><p> 批量执行远程命令,可以对远程的多台主机同时进行命令的执行批量安装和配置软件服务，可以对远程的多台主机进行自动化的方式配置和管理各种服务编排高级的企业级复杂的IT架构任务, Ansible的Playbook和role可以轻松实现大型的IT复杂架构提供自动化运维工具的开发API, 有很多运维工具,如jumpserver就是基于 ansible 实现自动化管理功能</p><h2 id="ansible的特点"><a href="#ansible的特点" class="headerlink" title="ansible的特点"></a><strong>ansible的特点</strong></h2><ul><li><p>模块化：调用特定的模块完成特定任务，支持自定义模块，可使用任何编程语言写模块</p></li><li><p>Paramiko（python对ssh的实现），PyYAML，Jinja2（模板语言）三个关键模块</p></li><li><p>基于Python语言实现</p></li><li><p>部署简单，基于python和SSH(默认已安装)，agentless，无需代理不依赖PKI（无需ssl）</p></li><li><p>安全，基于OpenSSH</p></li><li><p>幂等性：一个任务执行1遍和执行n遍效果一样，不因重复执行带来意外情况,此特性非绝对</p></li><li><p>支持playbook编排任务，YAML格式，编排任务，支持丰富的数据结构</p></li><li><p>较强大的多层解决方案 role</p></li></ul><h2 id="Ansible结构介绍"><a href="#Ansible结构介绍" class="headerlink" title="Ansible结构介绍"></a><strong>Ansible结构介绍</strong></h2><p><strong>Ansible 组成</strong></p><ul><li><p>组合INVENTORY、API、MODULES、PLUGINS的绿框，为ansible命令工具，其为核心执行工具</p></li><li><p>INVENTORY：Ansible管理主机的清单&#x2F;etc&#x2F;anaible&#x2F;hosts</p></li><li><p>MODULES：Ansible执行命令的功能模块，多数为内置核心模块，也可自定义</p></li><li><p>PLUGINS：模块功能的补充，如连接类型插件、循环插件、变量插件、过滤插件等，该功能不常用</p></li><li><p>API：供第三方程序调用的应用程序编程接口</p></li></ul><p><strong>Ansible命令执行的来源</strong></p><ul><li><p>USER 普通用户，即SYSTEM ADMINISTRATOR</p></li><li><p>PLAYBOOKS：任务剧本（任务集），编排定义Ansible任务集的配置文件，由Ansible顺序依次执行，通常是JSON格式的YML文件</p></li><li><p>CMDB（配置管理数据库） API 调用</p></li><li><p>PUBLIC&#x2F;PRIVATE CLOUD API调用</p></li><li><p>USER-&gt; Ansible Playbook -&gt; Ansibile</p></li></ul><p><strong>Ansible的注意事项</strong></p><ul><li><p>执行ansible的主机一般称为管理端, 主控端，中控，master或堡垒机</p></li><li><p>主控端Python版本需要2.6或以上</p></li><li><p>被控端Python版本小于2.4，需要安装python-simplejson</p></li><li><p>被控端如开启SELinux需要安装libselinux-python</p></li><li><p>windows 不能做为主控端</p></li></ul><p><strong>inventory 主机清单文件</strong></p><p> ansible的主要功用在于批量主机操作，为了便捷地使用其中的部分主机，可以在inventory 主机清单文件中将其分组组织默认的inventory file为 &#x2F;etc&#x2F;ansible&#x2F;hostsinventory file可以有多个，且也可以通过Dynamic Inventory来动态生成。</p><p>注意: 生产建议在每个项目目录下创建项目独立的hosts文件</p><p><strong>官方文档</strong></p><p><a href="https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html">https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html</a></p><p><strong>Inventory 参数说明</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ansible_ssh_host             #将要连接的远程主机名.与你想要设定的主机的别名不同的话,可通过此变量设置.</span><br><span class="line">ansible_ssh_port             #ssh端口号.如果不是默认的端口号,通过此变量设置.这种可以使用 ip:端口</span><br><span class="line"> 192.168.1.100:2222</span><br><span class="line">ansible_ssh_user             #默认的 ssh 用户名</span><br><span class="line">ansible_ssh_pass              #ssh 密码(这种方式并不安全,我们强烈建议使用 --ask-pass 或 SSH 密钥)</span><br><span class="line">ansible_sudo_pass               #sudo 密码(这种方式并不安全,我们强烈建议使用 --ask-sudo-pass)</span><br><span class="line">ansible_sudo_exe (new in version 1.8) #sudo 命令路径(适用于1.8及以上版本)</span><br><span class="line">ansible_connection             #与主机的连接类型.比如:local, ssh 或者 paramiko. Ansible 1.2 以前默</span><br><span class="line">认使用 paramiko.1.2 以后默认使用 &#x27;smart&#x27;,&#x27;smart&#x27; 方式会根据是否支持 ControlPersist, 来判断&#x27;ssh&#x27; 方式是否可行.</span><br><span class="line">ansible_ssh_private_key_file #ssh 使用的私钥文件.适用于有多个密钥,而你不想使用 SSH 代理的情况.</span><br><span class="line">ansible_shell_type         #目标系统的shell类型.默认情况下,命令的执行使用 &#x27;sh&#x27; 语法,可设置为&#x27;csh&#x27; 或 &#x27;fish&#x27;.</span><br><span class="line">ansible_python_interpreter #目标主机的 python 路径.适用于的情况: 系统中有多个 Python, 或者命令路径不是&quot;/usr/bin/python&quot;, 比如 \*BSD, 或者 /usr/bin/python 不是 2.X 版本的Python.之所以不使用 &quot;/usr/bin/env&quot; 机制,因为这要求远程用户的路径设置正确,且要求 &quot;python&quot; 可执行程序名不可为 python以外的名字(实际有可能名为python26).与ansible_python_interpreter 的工作方式相同,可设定如 ruby 或 perl 的路径....</span><br></pre></td></tr></table></figure><p><strong>范例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[test]</span><br><span class="line">10.0.0.8 ansible_connection=local #指定本地连接,无需ssh配置</span><br><span class="line">#ansible_connection=ssh 需要StrictHostKeyChecking no</span><br><span class="line">10.0.0.7 ansible_connection=ssh ansible_ssh_port=2222 ansible_ssh_user=wang</span><br><span class="line">ansible_ssh_password=magedu</span><br><span class="line">10.0.0.6 ansible_connection=ssh ansible_ssh_user=root</span><br><span class="line">ansible_ssh_password=123456</span><br><span class="line">#执行ansible命令时显示别名,如web01</span><br><span class="line">[websrvs]</span><br><span class="line">web01 ansible_ssh_host=10.0.0.101</span><br><span class="line">web02 ansible_ssh_host=10.0.0.102</span><br><span class="line">[websrvs:vars]</span><br><span class="line">ansible_ssh_password=magedu</span><br><span class="line">some_host ansible_ssh_port=2222 ansible_ssh_user=manager</span><br><span class="line">aws_host ansible_ssh_private_key_file=/home/example/.ssh/aws.pem</span><br><span class="line">freebsd_host ansible_python_interpreter=/usr/local/bin/python</span><br><span class="line">ruby_module_host ansible_ruby_interpreter=/usr/bin/ruby.1.9.3</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Ansible相关工具"><a href="#Ansible相关工具" class="headerlink" title="Ansible相关工具"></a><strong>Ansible相关工具</strong></h2><p>&#x2F;usr&#x2F;bin&#x2F;ansible 主程序，临时命令执行工具</p><p>&#x2F;usr&#x2F;bin&#x2F;ansible-doc 查看配置文档，模块功能查看工具,相当于man</p><p>&#x2F;usr&#x2F;bin&#x2F;ansible-playbook 定制自动化任务，编排剧本工具,相当于脚本 &#x2F;usr&#x2F;bin&#x2F;ansible-pull 远程执行命令的工具</p><p>&#x2F;usr&#x2F;bin&#x2F;ansible-vault 文件加密工具</p><p>&#x2F;usr&#x2F;bin&#x2F;ansible-console 基于Console界面与用户交互的执行工具 &#x2F;usr&#x2F;bin&#x2F;ansible-galaxy 下载&#x2F;上传优秀代码或Roles模块的官网平台</p><h2 id="利用ansible实现管理的主要方式："><a href="#利用ansible实现管理的主要方式：" class="headerlink" title="利用ansible实现管理的主要方式："></a><strong>利用ansible实现管理的主要方式：</strong></h2><p>Ansible Ad-Hoc 即利用ansible命令，主要用于临时命令使用场景 Ansible</p><p>playbook 主要用于长期规划好的，大型项目的场景，需要有前期的规划过程</p><h2 id="ansible-doc：获取指定模块的帮助文档"><a href="#ansible-doc：获取指定模块的帮助文档" class="headerlink" title="ansible-doc：获取指定模块的帮助文档"></a><strong>ansible-doc：获取指定模块的帮助文档</strong></h2><p><strong>格式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ansible-doc [options] [module...]</span><br><span class="line"></span><br><span class="line">-l, --list #列出可用模块</span><br><span class="line"></span><br><span class="line">-s, --snippet #显示指定模块的playbook片段</span><br></pre></td></tr></table></figure><p><strong>列出指定模块帮助</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-doc -s module_name</span><br></pre></td></tr></table></figure><p><strong>ansible Ad-Hoc的 执行方式</strong></p><p> <strong>ansible Ad-Hoc说明：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Ansible Ad-Hoc的执行方式主要的工具就是ansible命令:</span><br><span class="line"></span><br><span class="line">#格式：ansible &lt;host-pattern&gt; [-m module_name] [-a args]</span><br><span class="line"></span><br><span class="line"> ansible -i inventory -m command -a &#x27;pwd&#x27; all</span><br></pre></td></tr></table></figure><p><strong>​ 常用选项说明：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">显示版本--version</span><br><span class="line"></span><br><span class="line">指定模块，默认为command-m module</span><br><span class="line"></span><br><span class="line">详细过程 -vv -vvv更详细-v</span><br><span class="line"></span><br><span class="line">显示主机列表，可简写 --list-list-hosts</span><br><span class="line"></span><br><span class="line">检查，并不执行-C, --check</span><br><span class="line"></span><br><span class="line">执行命令的超时时间，默认10s-T, --timeout=TIMEOUT</span><br><span class="line"></span><br><span class="line">提示输入ssh连接密码，默认Key验证-k, --ask-pass</span><br><span class="line"></span><br><span class="line">执行远程执行的用户,默认root-u, --user=REMOTE_USER</span><br><span class="line"></span><br><span class="line">代替旧版的sudo 切换-b, --become</span><br><span class="line"></span><br><span class="line">指定sudo的runas用户，默认为root--become-user=USERNAME</span><br><span class="line"></span><br><span class="line">提示输入sudo时的口令-K, --ask-become-pass</span><br><span class="line"></span><br><span class="line">指定并发同时执行ansible任务的主机数-f FORKS, --forks FORKS</span><br></pre></td></tr></table></figure><p><strong>范例：调用shell模块查看shadow文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#修改被控制端的suduers文件，添加用户ALL=(ALL) NOPASSWD: ALL字段：</span><br><span class="line">#sed -ri &#x27;/## Same thing without a password/a\xiang ALL =(ALL) NOPASSWD: ALL /etc/sudoers</span><br><span class="line">#调用shell模块查看shadow</span><br><span class="line">#ansible 192.168.213.122 -m shell -a &#x27;sudo cat /etc/shadow |head -5&#x27; -u xiang -k -b</span><br><span class="line">[root@Ansible-Master ~14:18]$ ansible 192.168.213.123 -m shell -a &#x27;sudo cat /etc/shadow|head -5&#x27; -u xiang -k </span><br><span class="line">SSH password: </span><br><span class="line">[WARNING]: Consider using &#x27;become&#x27;, &#x27;become_method&#x27;, and &#x27;become_user&#x27; rather than running sudo</span><br><span class="line">192.168.213.123 | CHANGED | rc=0 &gt;&gt;</span><br><span class="line">root:$6$nZpI0Gve/q3y/vLW$k8QocsCR4x65nEqLaFsHhQGR8eYibTP.ixE5pzNY.8qTz3OkwWWIs8c4Z5QZJ6VZ8Lv0YVNvVoapARSpAuHDm1::0:99999:7:::</span><br><span class="line">bin:*:18353:0:99999:7:::</span><br><span class="line">daemon:*:18353:0:99999:7:::</span><br><span class="line">adm:*:18353:0:99999:7:::</span><br><span class="line">lp:*:18353:0:99999:7:::</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Aansible常用模块"><a href="#Aansible常用模块" class="headerlink" title="Aansible常用模块"></a><strong>Aansible常用模块</strong></h2><p>2015年底270多个模块，2016年达到540个，2018年01月12日有1378个模块，2018年07月15日1852 个模块,2019年05月25日（ansible 2.7.10）时2080个模块，2020年03月02日有3387个模块</p><p>参考文档</p><p>虽然模块众多，但最常用的模块也就2，30个而已，针对特定业务只用10几个模块 常用模块帮助文档参考：</p><p><a href="https://docs.ansible.com/ansible/2.9/modules/modules_by_category.html">https://docs.ansible.com/ansible/2.9/modules/modules_by_category.html</a></p><p><a href="https://docs.ansible.com/ansible/2.9/modules/list_of_all_modules.html">https://docs.ansible.com/ansible/2.9/modules/list_of_all_modules.html</a></p><p><a href="https://docs.ansible.com/ansible/latest/modules/list_of_all_modules.html">https://docs.ansible.com/ansible/latest/modules/list_of_all_modules.html</a></p><p><a href="https://docs.ansible.com/ansible/latest/modules/modules_by_category.html%C2%B7">https://docs.ansible.com/ansible/latest/modules/modules_by_category.html·</a></p><h3 id="Command模块"><a href="#Command模块" class="headerlink" title="Command模块"></a><strong>Command模块</strong></h3><p>功能</p><p>在远程主机执行命令，此为默认模块，可忽略 -m 选项</p><p>注意：此命令不支持 $VARNAME &lt; &gt; | ; &amp; 等，可能用shell模块实现</p><p>注意：此模块不具有幂等性</p><p><strong>常用参数</strong></p><ul><li><p>argv：将命令作为列表传输，而非字符串，且只能提供字符串或列表形式，不能同时提供两者，必须提供其中一种</p></li><li><p>chdir：运行命令前，切换到的目录</p></li><li><p>free_form参数 ：必须参数，指定需要远程执行的命令。需要说明一点，free_form 参数与其他参数（如果想要使用一个参数，那么则需要为这个参数赋值，也就是name&#x3D;value模式）并不相同。比如，当我们想要在远程主机上执行 ls 命令时，我们并不需要写成”free_form&#x3D;ls” ，这样写反而是错误的，因为并没有任何参数的名字是 free_form，当我们想要在远程主机中执行 ls 命令时，直接写成 ls 即可。因为 command 模块的作用是执行命令，所以，任何一个可以在远程主机上执行的命令都可以被称为 free_form</p></li><li><p>creates:与removes互斥且功能相反，指定一个文件路径或者目录路径，当该目录或文件存在时，则命令不执行</p></li><li><p>removes：与creates互斥功能相反，指定一个文件路径或者目录路径，当该目录或文件存在时，则命令执行，改参数不会删除文件；</p></li><li><p>stdin：标准输入</p></li><li><p>stdin_add_newline：给 stdin的值增加换行符；默认为YES，增加换行符；</p></li></ul><p><strong>范例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#查看远端passwd信息</span><br><span class="line"></span><br><span class="line">ansible webservs -m command -a &#x27;ls -l /etc/passwd&#x27;</span><br></pre></td></tr></table></figure><p><strong>shell模块（实用）</strong></p><p><strong>功能</strong></p><ul><li><p>和command相似，用shell执行命令,支持各种符号,比如:*,$, &gt;</p></li><li><p>注意：此模块不具有幂等性</p></li><li><p>该模块采用命令名称，后跟一个空格分隔参数列表</p></li><li><p>自由格式的命令或参数是必需的</p></li><li><p>它几乎与命令模块完全相同，但通过远程节点上的 shell （） 运行命令：&#x2F;bin&#x2F;sh</p></li><li><p>对于 Windows 目标，请改用win_shell模块</p></li></ul><p><strong>常用参数</strong></p><ul><li><p>chdir：运行命令前，切换到的目录</p></li><li><p>creates:与removes互斥且功能相反，指定一个文件路径或者目录路径，当该目录或文件存在时，则命令不执行</p></li><li><p>removes：与creates互斥功能相反，指定一个文件路径或者目录路径，当该目录或文件存在时，则命令执行</p></li><li><p>executable：更改用于执行该命令的shell，必须为绝对路径；</p></li></ul><p><strong>范例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#获取远端主机的主机名称</span><br><span class="line"></span><br><span class="line">[root@Ansible-Master ~11:03]#ansible webservs -m shell -a &quot;echo $HOSTNAME&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ansible </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ansible </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用idea 把一个git分支的部分提交记录合并到另一个git分支上</title>
      <link href="/2024/09/21/%E4%BD%BF%E7%94%A8idea%20%E6%8A%8A%E4%B8%80%E4%B8%AAgit%E5%88%86%E6%94%AF%E7%9A%84%E9%83%A8%E5%88%86%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95%E5%90%88%E5%B9%B6%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AAgit%E5%88%86%E6%94%AF%E4%B8%8A/"/>
      <url>/2024/09/21/%E4%BD%BF%E7%94%A8idea%20%E6%8A%8A%E4%B8%80%E4%B8%AAgit%E5%88%86%E6%94%AF%E7%9A%84%E9%83%A8%E5%88%86%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95%E5%90%88%E5%B9%B6%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AAgit%E5%88%86%E6%94%AF%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="使用idea-把一个git分支的部分提交记录合并到另一个git分支上"><a href="#使用idea-把一个git分支的部分提交记录合并到另一个git分支上" class="headerlink" title="使用idea 把一个git分支的部分提交记录合并到另一个git分支上"></a>使用idea 把一个git分支的部分提交记录合并到另一个git分支上</h1><span id="more"></span><p><strong>希望将cloud-dev分支的某个提交记录提交到cloud-master-test合并分支</strong></p><p>切换至cloud-master-test合并分支</p><p>log on 选择要合并的分支，并选择 use me查看分支提交</p><p>选择合并的提交记录单击cherry-pick</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用静态内部类单例模式创建线程池</title>
      <link href="/2024/09/11/%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2024/09/11/%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="使用静态内部类单例模式创建线程池"><a href="#使用静态内部类单例模式创建线程池" class="headerlink" title="使用静态内部类单例模式创建线程池"></a>使用静态内部类单例模式创建线程池</h1><span id="more"></span><p>使用<a href="https://so.csdn.net/so/search?q=%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB&spm=1001.2101.3001.7020">静态内部类</a>单例模式创建线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> cjg</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>：单例定义线程池</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/04/26 11:51</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//多线程查询</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadUtils</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义cpu核数+3数量的线程池</span></span><br><span class="line"><span class="comment">     * 静态内部类方式使用时创建，线程安全</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span>&#123;</span><br><span class="line">        <span class="comment">// 获取cpu 的核数</span></span><br><span class="line">        <span class="keyword">static</span> <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">2</span>,                          <span class="comment">//核心线程池大小</span></span><br><span class="line">                max,                                    <span class="comment">//最大的线程池大小</span></span><br><span class="line">                <span class="number">3</span>,                         <span class="comment">//超时了没有人调用就会释放</span></span><br><span class="line">                TimeUnit.SECONDS,                       <span class="comment">//超时单位</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="number">3</span>),   <span class="comment">//阻塞队列</span></span><br><span class="line">                Executors.defaultThreadFactory(),       <span class="comment">//线程工厂 创建线程的 一般不用动</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()    <span class="comment">//拒绝策略</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.threadPool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> ThreadUtils.newInstance();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            service.submit(() -&gt; &#123;</span><br><span class="line">                log.info(<span class="string">&quot;使用线程池实例&quot;</span>+service.toString());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;模拟解析文件开始，调用线程池的线程:&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    log.info(<span class="string">&quot;结束------&quot;</span>+ finalI);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@7c0c77c7 rejected from java.util.concurrent.ThreadPoolExecutor@5cee5251[Running, <span class="type">pool</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">4</span>, <span class="type">active</span> <span class="variable">threads</span> <span class="operator">=</span> <span class="number">4</span>, <span class="type">queued</span> <span class="variable">tasks</span> <span class="operator">=</span> <span class="number">3</span>, <span class="type">completed</span> <span class="variable">tasks</span> <span class="operator">=</span> <span class="number">0</span>]</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:<span class="number">2063</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:<span class="number">830</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:<span class="number">1379</span>)</span><br><span class="line">at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:<span class="number">112</span>)</span><br><span class="line">at cn.gzsendi.modules.utils.Main.main(ThreadUtils.java:<span class="number">47</span>)</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">26</span> <span class="number">14</span>:<span class="number">32</span>:<span class="number">25</span>,<span class="number">176</span>  INFO [pool-<span class="number">1</span>-thread-<span class="number">1</span>] cn.gzsendi.modules.utils.Main.lambda$main$<span class="number">0</span>:<span class="number">48</span> - 使用线程池实例java.util.concurrent.ThreadPoolExecutor@5cee5251[Running, <span class="type">pool</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">4</span>, <span class="type">active</span> <span class="variable">threads</span> <span class="operator">=</span> <span class="number">4</span>, <span class="type">queued</span> <span class="variable">tasks</span> <span class="operator">=</span> <span class="number">3</span>, <span class="type">completed</span> <span class="variable">tasks</span> <span class="operator">=</span> <span class="number">0</span>]</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">26</span> <span class="number">14</span>:<span class="number">32</span>:<span class="number">25</span>,<span class="number">183</span>  INFO [pool-<span class="number">1</span>-thread-<span class="number">1</span>] cn.gzsendi.modules.utils.Main.lambda$main$<span class="number">0</span>:<span class="number">50</span> - 模拟解析文件开始，调用线程池的线程:pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">26</span> <span class="number">14</span>:<span class="number">32</span>:<span class="number">25</span>,<span class="number">176</span>  INFO [pool-<span class="number">1</span>-thread-<span class="number">4</span>] cn.gzsendi.modules.utils.Main.lambda$main$<span class="number">0</span>:<span class="number">48</span> - 使用线程池实例java.util.concurrent.ThreadPoolExecutor@5cee5251[Running, <span class="type">pool</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">4</span>, <span class="type">active</span> <span class="variable">threads</span> <span class="operator">=</span> <span class="number">4</span>, <span class="type">queued</span> <span class="variable">tasks</span> <span class="operator">=</span> <span class="number">3</span>, <span class="type">completed</span> <span class="variable">tasks</span> <span class="operator">=</span> <span class="number">0</span>]</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">26</span> <span class="number">14</span>:<span class="number">32</span>:<span class="number">25</span>,<span class="number">176</span>  INFO [pool-<span class="number">1</span>-thread-<span class="number">2</span>] cn.gzsendi.modules.utils.Main.lambda$main$<span class="number">0</span>:<span class="number">48</span> - 使用线程池实例java.util.concurrent.ThreadPoolExecutor@5cee5251[Running, <span class="type">pool</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">4</span>, <span class="type">active</span> <span class="variable">threads</span> <span class="operator">=</span> <span class="number">4</span>, <span class="type">queued</span> <span class="variable">tasks</span> <span class="operator">=</span> <span class="number">3</span>, <span class="type">completed</span> <span class="variable">tasks</span> <span class="operator">=</span> <span class="number">0</span>]</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">26</span> <span class="number">14</span>:<span class="number">32</span>:<span class="number">25</span>,<span class="number">184</span>  INFO [pool-<span class="number">1</span>-thread-<span class="number">4</span>] cn.gzsendi.modules.utils.Main.lambda$main$<span class="number">0</span>:<span class="number">50</span> - 模拟解析文件开始，调用线程池的线程:pool-<span class="number">1</span>-thread-<span class="number">4</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">26</span> <span class="number">14</span>:<span class="number">32</span>:<span class="number">25</span>,<span class="number">184</span>  INFO [pool-<span class="number">1</span>-thread-<span class="number">2</span>] cn.gzsendi.modules.utils.Main.lambda$main$<span class="number">0</span>:<span class="number">50</span> - 模拟解析文件开始，调用线程池的线程:pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">26</span> <span class="number">14</span>:<span class="number">32</span>:<span class="number">25</span>,<span class="number">176</span>  INFO [pool-<span class="number">1</span>-thread-<span class="number">3</span>] cn.gzsendi.modules.utils.Main.lambda$main$<span class="number">0</span>:<span class="number">48</span> - 使用线程池实例java.util.concurrent.ThreadPoolExecutor@5cee5251[Running, <span class="type">pool</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">4</span>, <span class="type">active</span> <span class="variable">threads</span> <span class="operator">=</span> <span class="number">4</span>, <span class="type">queued</span> <span class="variable">tasks</span> <span class="operator">=</span> <span class="number">3</span>, <span class="type">completed</span> <span class="variable">tasks</span> <span class="operator">=</span> <span class="number">0</span>]</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">26</span> <span class="number">14</span>:<span class="number">32</span>:<span class="number">25</span>,<span class="number">185</span>  INFO [pool-<span class="number">1</span>-thread-<span class="number">3</span>] cn.gzsendi.modules.utils.Main.lambda$main$<span class="number">0</span>:<span class="number">50</span> - 模拟解析文件开始，调用线程池的线程:pool-<span class="number">1</span>-thread-<span class="number">3</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">26</span> <span class="number">14</span>:<span class="number">32</span>:<span class="number">26</span>,<span class="number">186</span>  INFO [pool-<span class="number">1</span>-thread-<span class="number">4</span>] cn.gzsendi.modules.utils.Main.lambda$main$<span class="number">0</span>:<span class="number">52</span> - 结束------<span class="number">6</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">26</span> <span class="number">14</span>:<span class="number">32</span>:<span class="number">26</span>,<span class="number">186</span>  INFO [pool-<span class="number">1</span>-thread-<span class="number">3</span>] cn.gzsendi.modules.utils.Main.lambda$main$<span class="number">0</span>:<span class="number">52</span> - 结束------<span class="number">5</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">26</span> <span class="number">14</span>:<span class="number">32</span>:<span class="number">26</span>,<span class="number">186</span>  INFO [pool-<span class="number">1</span>-thread-<span class="number">2</span>] cn.gzsendi.modules.utils.Main.lambda$main$<span class="number">0</span>:<span class="number">52</span> - 结束------<span class="number">1</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">26</span> <span class="number">14</span>:<span class="number">32</span>:<span class="number">26</span>,<span class="number">187</span>  INFO [pool-<span class="number">1</span>-thread-<span class="number">3</span>] cn.gzsendi.modules.utils.Main.lambda$main$<span class="number">0</span>:<span class="number">48</span> - 使用线程池实例java.util.concurrent.ThreadPoolExecutor@5cee5251[Running, <span class="type">pool</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">4</span>, <span class="type">active</span> <span class="variable">threads</span> <span class="operator">=</span> <span class="number">4</span>, <span class="type">queued</span> <span class="variable">tasks</span> <span class="operator">=</span> <span class="number">1</span>, <span class="type">completed</span> <span class="variable">tasks</span> <span class="operator">=</span> <span class="number">2</span>]</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">26</span> <span class="number">14</span>:<span class="number">32</span>:<span class="number">26</span>,<span class="number">187</span>  INFO [pool-<span class="number">1</span>-thread-<span class="number">3</span>] cn.gzsendi.modules.utils.Main.lambda$main$<span class="number">0</span>:<span class="number">50</span> - 模拟解析文件开始，调用线程池的线程:pool-<span class="number">1</span>-thread-<span class="number">3</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">26</span> <span class="number">14</span>:<span class="number">32</span>:<span class="number">26</span>,<span class="number">187</span>  INFO [pool-<span class="number">1</span>-thread-<span class="number">2</span>] cn.gzsendi.modules.utils.Main.lambda$main$<span class="number">0</span>:<span class="number">48</span> - 使用线程池实例java.util.concurrent.ThreadPoolExecutor@5cee5251[Running, <span class="type">pool</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">4</span>, <span class="type">active</span> <span class="variable">threads</span> <span class="operator">=</span> <span class="number">4</span>, <span class="type">queued</span> <span class="variable">tasks</span> <span class="operator">=</span> <span class="number">1</span>, <span class="type">completed</span> <span class="variable">tasks</span> <span class="operator">=</span> <span class="number">2</span>]</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">26</span> <span class="number">14</span>:<span class="number">32</span>:<span class="number">26</span>,<span class="number">188</span>  INFO [pool-<span class="number">1</span>-thread-<span class="number">2</span>] cn.gzsendi.modules.utils.Main.lambda$main$<span class="number">0</span>:<span class="number">50</span> - 模拟解析文件开始，调用线程池的线程:pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">26</span> <span class="number">14</span>:<span class="number">32</span>:<span class="number">26</span>,<span class="number">188</span>  INFO [pool-<span class="number">1</span>-thread-<span class="number">4</span>] cn.gzsendi.modules.utils.Main.lambda$main$<span class="number">0</span>:<span class="number">48</span> - 使用线程池实例java.util.concurrent.ThreadPoolExecutor@5cee5251[Running, <span class="type">pool</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">4</span>, <span class="type">active</span> <span class="variable">threads</span> <span class="operator">=</span> <span class="number">4</span>, <span class="type">queued</span> <span class="variable">tasks</span> <span class="operator">=</span> <span class="number">0</span>, <span class="type">completed</span> <span class="variable">tasks</span> <span class="operator">=</span> <span class="number">3</span>]</span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">26</span> <span class="number">14</span>:<span class="number">32</span>:<span class="number">26</span>,<span class="number">189</span>  INFO [pool-<span class="number">1</span>-thread-<span class="number">4</span>] cn.gzsendi.modules.utils.Main.lambda$main$<span class="number">0</span>:<span class="number">50</span> - 模拟解析文件开始，调用线程池的线程:pool-<span class="number">1</span>-thread-<span class="number">4</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">26</span> <span class="number">14</span>:<span class="number">32</span>:<span class="number">26</span>,<span class="number">186</span>  INFO [pool-<span class="number">1</span>-thread-<span class="number">1</span>] cn.gzsendi.modules.utils.Main.lambda$main$<span class="number">0</span>:<span class="number">52</span> - 结束------<span class="number">0</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">26</span> <span class="number">14</span>:<span class="number">32</span>:<span class="number">27</span>,<span class="number">201</span>  INFO [pool-<span class="number">1</span>-thread-<span class="number">4</span>] cn.gzsendi.modules.utils.Main.lambda$main$<span class="number">0</span>:<span class="number">52</span> - 结束------<span class="number">4</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">26</span> <span class="number">14</span>:<span class="number">32</span>:<span class="number">27</span>,<span class="number">201</span>  INFO [pool-<span class="number">1</span>-thread-<span class="number">2</span>] cn.gzsendi.modules.utils.Main.lambda$main$<span class="number">0</span>:<span class="number">52</span> - 结束------<span class="number">3</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">04</span>-<span class="number">26</span> <span class="number">14</span>:<span class="number">32</span>:<span class="number">27</span>,<span class="number">201</span>  INFO [pool-<span class="number">1</span>-thread-<span class="number">3</span>] cn.gzsendi.modules.utils.Main.lambda$main$<span class="number">0</span>:<span class="number">52</span> - 结束------<span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当线程数大于线程池执行拒绝策略</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>公司面试题</title>
      <link href="/2024/08/27/%E5%85%AC%E5%8F%B8%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2024/08/27/%E5%85%AC%E5%8F%B8%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="公司面试题"><a href="#公司面试题" class="headerlink" title="公司面试题"></a>公司面试题</h1> <span id="more"></span><h1 id="HTTPS的加密方式-使用对称加密和非对称加密的好处是什么"><a href="#HTTPS的加密方式-使用对称加密和非对称加密的好处是什么" class="headerlink" title="HTTPS的加密方式?  使用对称加密和非对称加密的好处是什么?"></a>HTTPS的加密方式?  使用对称加密和非对称加密的好处是什么?</h1><ol><li><p><strong>对称加密（Symmetric Encryption）</strong>：使用相同的密钥进行加密和解密。</p></li><li><p><strong>非对称加密（Asymmetric Encryption）</strong>：使用一对公钥和私钥，其中公钥加密的数据只能通过对应的私钥解密，反之亦然。</p></li></ol><h3 id="使用对称加密和非对称加密的好处"><a href="#使用对称加密和非对称加密的好处" class="headerlink" title="使用对称加密和非对称加密的好处"></a>使用对称加密和非对称加密的好处</h3><p><strong>对称加密的好处</strong>：</p><ul><li><strong>速度快</strong>：对称加密算法通常比非对称加密算法快得多，适合大数据量的加密传输。</li><li><strong>计算资源低</strong>：对称加密的计算复杂度较低，节省CPU和内存资源。</li></ul><p><strong>非对称加密的好处</strong>：</p><ul><li><strong>密钥管理安全</strong>：非对称加密通过公钥和私钥的配对，解决了密钥分发和管理的问题。只有私钥持有者能解密数据，保证了数据传输的安全性。</li><li><strong>身份验证</strong>：非对称加密支持数字签名，验证数据发送者的身份，防止数据被篡改。</li></ul><h3 id="HTTPS-结合对称加密和非对称加密的优势"><a href="#HTTPS-结合对称加密和非对称加密的优势" class="headerlink" title="HTTPS 结合对称加密和非对称加密的优势"></a>HTTPS 结合对称加密和非对称加密的优势</h3><ul><li><strong>安全的密钥交换</strong>：通过非对称加密安全地交换对称加密密钥，避免了对称密钥的泄露。</li><li><strong>高效的数据传输</strong>：一旦对称密钥安全交换，使用对称加密进行数据传输，提高传输效率。</li></ul><p>通过结合这两种加密方式，HTTPS 能够提供既安全又高效的数据加密传输。</p><h1 id="如何预防死锁的发生"><a href="#如何预防死锁的发生" class="headerlink" title="如何预防死锁的发生?"></a>如何预防死锁的发生?</h1><p>破坏死锁的4个条件之一就可以：</p><p>循环等待；不可剥夺；请求保持；互斥；</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>死锁问题，事务卡住了</title>
      <link href="/2024/08/01/%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%EF%BC%8C%E4%BA%8B%E5%8A%A1%E5%8D%A1%E4%BD%8F%E4%BA%86/"/>
      <url>/2024/08/01/%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%EF%BC%8C%E4%BA%8B%E5%8A%A1%E5%8D%A1%E4%BD%8F%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<h1 id="死锁问题，事务卡住了"><a href="#死锁问题，事务卡住了" class="headerlink" title="死锁问题，事务卡住了"></a>死锁问题，事务卡住了</h1> <span id="more"></span><p><strong>执行查询查看事务信息：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM information_schema.innodb_trx;</span><br></pre></td></tr></table></figure><p><strong>查看当前运行的线程:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW PROCESSLIST;</span><br></pre></td></tr></table></figure><p><strong>使用 KILL 命令终止该连接：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KILL [connection_id];</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea开发spring项目ClassPathXmlApplicationContext读取配置文件路径问题</title>
      <link href="/2024/06/01/idea%E5%BC%80%E5%8F%91spring%E9%A1%B9%E7%9B%AEClassPathXmlApplicationContext%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"/>
      <url>/2024/06/01/idea%E5%BC%80%E5%8F%91spring%E9%A1%B9%E7%9B%AEClassPathXmlApplicationContext%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="idea开发spring项目ClassPathXmlApplicationContext读取配置文件路径问题"><a href="#idea开发spring项目ClassPathXmlApplicationContext读取配置文件路径问题" class="headerlink" title="idea开发spring项目ClassPathXmlApplicationContext读取配置文件路径问题"></a>idea开发spring项目ClassPathXmlApplicationContext读取配置文件路径问题</h1><span id="more"></span><p>将applicationContext.xml文件放在src目录下，编译后从生成的target可以看到classes目录（存放.class文件）并没有applicationContext.xml，因为编译只会对.java文件编译</p><p><img src="/iamges/2/1.png" alt="1"></p><p>而application.<a href="https://so.csdn.net/so/search?q=xml&spm=1001.2101.3001.7020">xml</a>文件放在resource目录下，IDEA就会将xml文件复制到classess文件夹下，就能正常访问了。</p><p><img src="/iamges/2/2.png" alt="2"></p><p>若想要配置不同的applicationContext.xml读取路径，则可以创建相应的包目录，指定对应的包路径就可以访问</p><p><img src="/iamges/2/3.png" alt="3"></p><p><img src="/iamges/2/4.png" alt="4"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud-Nacos：服务注册+配置中心</title>
      <link href="/2024/05/01/SpringCloud-Nacos%EF%BC%9A%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C-%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
      <url>/2024/05/01/SpringCloud-Nacos%EF%BC%9A%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C-%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringCloud-Nacos：服务注册-配置中心"><a href="#SpringCloud-Nacos：服务注册-配置中心" class="headerlink" title="SpringCloud-Nacos：服务注册+配置中心"></a>SpringCloud-Nacos：服务注册+配置中心</h1><span id="more"></span><p>SpringCloud-Nacos：服务注册+配置中心</p><h3 id="1-下载安装包"><a href="#1-下载安装包" class="headerlink" title="1.下载安装包"></a>1.下载安装包</h3><p>在Nacos的GitHub页面，提供有下载链接，可以下载编译好的Nacos服务端或者源代码：</p><p>GitHub主页：<a href="https://github.com/alibaba/nacos">https://github.com/alibaba/nacos</a></p><p>GitHub的Release下载页：<a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a></p><h3 id="2-解压"><a href="#2-解压" class="headerlink" title="2.解压"></a>2.解压</h3><p>解压后在bin目录下打开cmd，输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup.cmd -m standalone</span><br></pre></td></tr></table></figure><p>启动nacos，默认用户名和密码都是nacos</p><p>nacos默认端口是8848</p><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p>在项目的父级pom加入springCloud的alibaba依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再需要使用nacos管理的微服务中加入nacos客户端依赖，并注释eruka的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再application.yml文件中加入nacos配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/cloud_order?useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">orderservice</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>启动项目</p><p><img src="/iamges/1/1.png" alt="1"></p><h3 id="4-设置集群"><a href="#4-设置集群" class="headerlink" title="4.设置集群"></a>4.设置集群</h3><p>在application.yml文件中设置集群名称</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/cloud_order?useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">orderservice</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span> <span class="comment">#集群名称</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当多个实例想设置多个集群时，可以在不同实例中设置不同的集群并重启对应实例</p><p><img src="/iamges/1/2.png" alt="2"></p><p>orderservice使用restTemplate实现负载均衡</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span> <span class="comment">//开启负载均衡，即使一个实例也要加</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">public</span> Order <span class="title function_">queryOrderById</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.查询订单</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderMapper.findById(orderId);</span><br><span class="line"><span class="comment">//        String url = &quot;http://localhost:8081/user/&quot; +order.getUserId();</span></span><br><span class="line">        <span class="comment">//将http地址换成实例名，不用端口，使用负载均衡</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://userservice/user/&quot;</span> +order.getUserId();</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> restTemplate.getForObject(url, User.class);</span><br><span class="line">        order.setUser(user);</span><br><span class="line">        <span class="comment">// 4.返回</span></span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过在orderservice配置文件中配置集群访问的策略，实现负载均衡优先使用同局域网下的集群用例</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">userservice:</span> <span class="comment">#要做配置的微服务名称</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class="comment">#负载均衡优先使用同局域网下的集群用例</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/iamges/1/3.png" alt="3"></p><p><img src="/iamges/1/4.png" alt="4"></p><p><img src="/iamges/1/5.png" alt="5"></p><p>优先访问了同集群下的8081和8082端口的服务，8083不访问，当同集群下的服务挂了才去访问</p><h3 id="5-设置开发环境"><a href="#5-设置开发环境" class="headerlink" title="5.设置开发环境"></a>5.设置开发环境</h3><p>使用nacos的命名空间，将服务部署到开发环境，不会影响生成环境</p><p><img src="/iamges/1/6.png" alt="6"></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/cloud_order?useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">orderservice</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span> <span class="comment">#集群名称</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">e915565d-ba06-4c02-823a-62bea0e82947</span> <span class="comment">#开发环境</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>namespace对应的是生成的命名空间id， orderservice启动后就会把服务部署到dev环境，orderservice的服务便不会访问到public空间下的服务了（隔离）</p><h3 id="6-配置配置中心"><a href="#6-配置配置中心" class="headerlink" title="6. 配置配置中心"></a>6. 配置配置中心</h3><p>（配置中心需要先把服务注册上一次，再使用bootstrap.yml文件配置）</p><p>在nacos中新建配置文件，DataID格式为 服务名-环境.yaml</p><p><img src="/iamges/1/7.png" alt="7"></p><p>因为实现配置中心必须spring需要先获取nacos配置才再去获取application.yml，获取nacos配置需要在读取application.yml之前完成，因此将nacos的配置信息放在bootstrap.yml中（读取优先级比application.yml更高）</p><p>bootstarp.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userservice</span> <span class="comment">#服务名</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment">#环境</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#ip地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#配置文件后缀</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>并把application中的nacos信息去掉</p><p>测试：</p><p><img src="/iamges/1/8.png" alt="8"></p><p>结果：</p><p><img src="/iamges/1/9.png" alt="9"></p><h4 id="实现配置的热更新："><a href="#实现配置的热更新：" class="headerlink" title="实现配置的热更新："></a>实现配置的热更新：</h4><p><strong>方式一：</strong></p><p>在@Value注入的变量所在的类上添加注解@RefreshScope</p><p><img src="/iamges/1/10.png" alt="10"></p><p><img src="/iamges/1/11.png" alt="11"></p><p><img src="/iamges/1/12.png" alt="12"></p><p>实现日期格式热更新</p><p><strong>方式二：</strong></p><p>使用@ConfigurationProperties注解 写一个配置类或者相关配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;pattern&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PatternProperties</span> &#123;</span><br><span class="line">    <span class="comment">//变量名就是配置名</span></span><br><span class="line">    <span class="keyword">private</span> String dateoformat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取配置信息</p><p><img src="/iamges/1/13.png" alt="13"></p><h3 id="7-配置文件多环境共享"><a href="#7-配置文件多环境共享" class="headerlink" title="7. 配置文件多环境共享"></a>7. 配置文件多环境共享</h3><p>nacos在启动时会加载配置中心的两种类型的配置文件</p><ol><li>服务名+环境.文件后缀</li><li>服务名.文件后缀</li></ol><p>因此可以配置userservice.yaml作为userservice的多环境共享配置文件</p><p><img src="/iamges/1/14.png" alt="14"></p><p>在PatternProperties类中增加字段envShareValue</p><p><img src="/iamges/1/15.png" alt="15"></p><p>编写测试接口</p><p><img src="/iamges/1/16.png" alt="16"><br>将8082的userservice服务设为test环境作为对比</p><p><img src="/iamges/1/17.png" alt="17"></p><p>结果：dev环境下可以访问到全部，test只能访问到共享的配置文件</p><p><img src="/iamges/1/18.png" alt="18"></p><p><img src="/iamges/1/19.png" alt="19"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SecureCRT设置端口转发原理</title>
      <link href="/2023/12/09/SecureCRT%E8%AE%BE%E7%BD%AE%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%8E%9F%E7%90%86/"/>
      <url>/2023/12/09/SecureCRT%E8%AE%BE%E7%BD%AE%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="SecureCRT设置端口转发原理"><a href="#SecureCRT设置端口转发原理" class="headerlink" title="SecureCRT设置端口转发原理"></a>SecureCRT设置端口转发原理</h1> <span id="more"></span><h2 id="1-普通端口转发"><a href="#1-普通端口转发" class="headerlink" title="1. 普通端口转发"></a><strong>1. 普通端口转发</strong></h2><p>在中间服务器设置如下：</p><p><img src="/iamges/SecureCRT%E8%AE%BE%E7%BD%AE%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%8E%9F%E7%90%86/1.png" alt="img"></p><h2 id="2-动态端口转发（SOCKS-4-或-SOCKS-5）"><a href="#2-动态端口转发（SOCKS-4-或-SOCKS-5）" class="headerlink" title="2. 动态端口转发（SOCKS 4 或 SOCKS 5）"></a><strong>2. 动态端口转发（SOCKS 4 或 SOCKS 5）</strong></h2><p>通过设置动态端口转发，中间服务器能访问的所有地址，都能通过Loacl设置的端口转发访问到，可以配合proxifer配置拦截本地127.0.0.1:12345的流量到指定的某些ip</p><p><img src="/iamges/SecureCRT%E8%AE%BE%E7%BD%AE%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%8E%9F%E7%90%86/2.png" alt="img"></p><p><img src="/iamges/SecureCRT%E8%AE%BE%E7%BD%AE%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%8E%9F%E7%90%86/3.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos 7安装fping指定版本</title>
      <link href="/2023/11/06/centos%207%E5%AE%89%E8%A3%85fping%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC/"/>
      <url>/2023/11/06/centos%207%E5%AE%89%E8%A3%85fping%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="centos-7安装fping指定版本"><a href="#centos-7安装fping指定版本" class="headerlink" title="centos 7安装fping指定版本"></a>centos 7安装fping指定版本</h1> <span id="more"></span><p>在CentOS 7上安装</p><p>fping 5.1可以通过源代码编译的方式进行。以下是安装步骤</p><ol><li>安装编译所需的依赖项：</li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install gcc make</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>下载fping源代码：</strong></li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://fping.org/dist/fping-<span class="number">5</span>.<span class="number">1</span>.tar.gz</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>解压源代码文件：</strong></li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf fping-<span class="number">5</span>.<span class="number">1</span>.tar.gz </span><br><span class="line"><span class="built_in">cd</span> fping-<span class="number">5</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure><ol start="4"><li><strong>编译和安装fping</strong></li></ol><p>make之后可以到src目录下找fping执行**&#x2F;usr&#x2F;local&#x2F;fping&#x2F;fping-5.1&#x2F;fping -v** 应该可以成功，</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./configure make</span><br><span class="line"></span><br><span class="line"> sudo make install</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>之后默认安装在&#x2F;usr&#x2F;local&#x2F;sbin下</p><ol start="5"><li><strong>给<del>&#x2F;.bashrc和</del>&#x2F;.bash_profile配置相关路径</strong></li></ol><p><strong>~&#x2F;.bashrc</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc </span><br><span class="line">添加 </span><br><span class="line">export <span class="built_in">PATH</span>=$<span class="built_in">PATH</span>:/usr/local/sbin</span><br><span class="line">重新加载 </span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>配置如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># .bashrc</span><br><span class="line"></span><br><span class="line"># User specific aliases and functions</span><br><span class="line"></span><br><span class="line">alias rm=&#x27;rm -i&#x27;</span><br><span class="line">alias cp=&#x27;cp -i&#x27;</span><br><span class="line">alias mv=&#x27;mv -i&#x27;</span><br><span class="line"></span><br><span class="line"># Source global definitions</span><br><span class="line"><span class="keyword">if</span> [ -f /etc/bashrc ]; then</span><br><span class="line">        . /etc/bashrc</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">export <span class="built_in">PATH</span>=$<span class="built_in">PATH</span>:/usr/local/sbin</span><br></pre></td></tr></table></figure><p><strong>~&#x2F;.bash_profile</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br><span class="line">添加</span><br><span class="line"><span class="built_in">PATH</span>=$<span class="built_in">PATH</span>:$HOME/bin:/usr/local/sbin</span><br><span class="line">重新加载</span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure><p>配置如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[sendi@zabbix1 ~]$ </span><br><span class="line"># .bash_profile</span><br><span class="line"></span><br><span class="line"># Get the aliases and functions</span><br><span class="line"><span class="keyword">if</span> [ -f ~/.bashrc ]; then</span><br><span class="line">        . ~/.bashrc</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># User specific environment and startup programs</span><br><span class="line"></span><br><span class="line"><span class="built_in">PATH</span>=$<span class="built_in">PATH</span>:$HOME/bin:/usr/local/sbin</span><br><span class="line"></span><br><span class="line">export <span class="built_in">PATH</span></span><br><span class="line">export JAVA_HOME=/usr/local/jdk1.<span class="number">8</span></span><br><span class="line">export TOMCAT_HOME=/usr/local/tomcat</span><br><span class="line">export CATALINA_HOME=/usr/local/tomcat</span><br><span class="line"><span class="built_in">PATH</span>=$<span class="built_in">PATH</span>:$HOME/bin:$JAVA_HOME/bin:$CATALINA_HOME/bin</span><br><span class="line">export CLASS_PATH=$JAVA_HOME/bin/lib:$JAVA_HOME/jre/lib:$JAVA_HOME/lib/tool.jar</span><br><span class="line">export <span class="built_in">PATH</span></span><br><span class="line">~           </span><br></pre></td></tr></table></figure><p>，<strong>~&#x2F;.bashrc</strong> 和 <strong>~&#x2F;.bash_profile</strong> 是两个不同的文件，它们在 Bash Shell 中有不同的作用。</p><ol><li><p>~&#x2F;.bashrc</p><ol><li>~&#x2F;.bashrc</li></ol><ul><li>当用户每次打开一个新的终端窗口时，Bash Shell 会自动执行 ~&#x2F;.bashrc</li><li>通常，~&#x2F;.bashrc 中包含用户特定的配置，如别名、环境变量等。</li><li>~&#x2F;.bashrc通常用于配置用户特定的 Shell 环境。</li></ul></li><li><p>~&#x2F;.bash_profile</p><ol><li>~&#x2F;.bash_profile 是用户登录时 Bash Shell 的初始化文件。</li></ol><ul><li>当用户登录时（通常是通过命令行登录或图形用户界面登录），Bash Shell 会自动执行 ~&#x2F;.bash_profile 文件中的命令。</li><li>~&#x2F;.bash_profile 通常包含用户登录时需要进行的初始化操作，例如设置环境变量、启动程序等。</li><li>一般来说，~&#x2F;.bash_profile 只会在用户登录时执行一次，而不会在每次打开新终端窗口时执行。</li></ul></li></ol><p>在一些 Linux 系统中，<strong>~&#x2F;.bash_profile</strong> 会引用 <strong>~&#x2F;.bashrc</strong>，这样的话，<strong>~&#x2F;.bashrc</strong> 中的配置会在每次打开新终端窗口时生效，而不仅限于用户登录时。</p><p>在你的情况下，如果你是希望在每次打开新终端窗口时都能够使用 <strong>fping</strong> 命令，你应该将相关的路径配置添加到 <strong>~&#x2F;.bashrc</strong> 文件中。如果你希望只在用户登录时配置环境变量，那就将路径配置添加到 <strong>~&#x2F;.bash_profile</strong> 文件中。</p><p>可能普通用户sudo fping <a href="http://www.baidu.com会执行不成功,显示sudo/">www.baidu.com会执行不成功，显示sudo</a>: fping: command not found</p><p>这可能是因为 sudo 命令的环境变量配置中没有包含 &#x2F;usr&#x2F;local&#x2F;sbin 路径。</p><h3 id="sudo-的环境变量配置："><a href="#sudo-的环境变量配置：" class="headerlink" title="sudo 的环境变量配置："></a><strong>sudo</strong> <strong>的环境变量配置：</strong></h3><p>编辑 <strong>sudo</strong> 的环境变量配置文件（通常是 <strong>&#x2F;etc&#x2F;sudoers</strong>）以确保 <strong>&#x2F;usr&#x2F;local&#x2F;sbin</strong> 在 <strong>sudo</strong> 环境中被包含。不建议直接编辑 <strong>&#x2F;etc&#x2F;sudoers</strong> 文件，而是使用 <strong>visudo</strong> 命令来编辑，因为这样可以避免语法错误。</p><p>在终端中输入以下命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo visudo</span><br></pre></td></tr></table></figure><p>在打开的文件中，找到 </p><p>Defaults secure_path 行，确保这一行包含了 &#x2F;usr&#x2F;local&#x2F;sbin 路径，例如：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Defaults secure_path=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span><br></pre></td></tr></table></figure><p>如果这一行没有包含 &#x2F;usr&#x2F;local&#x2F;sbin，请将其添加进去。保存并退出文件。</p><p>这样，<strong>sudo</strong> 命令就应该能够找到 fping 了，普通用户就可以使用 sudo 运行 fping 命令。如果在编辑 sudoers 文件时遇到问题，可能需要使用 <strong>visudo 的 -f</strong> 选项来编辑指定的文件，例如：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo visudo -f /etc/sudoers</span><br></pre></td></tr></table></figure><p>请注意，修改系统配置文件前请备份，确保不会引入错误。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>==，equals，hashcode</title>
      <link href="/2023/08/13/==%EF%BC%8Cequals%EF%BC%8Chashcode/"/>
      <url>/2023/08/13/==%EF%BC%8Cequals%EF%BC%8Chashcode/</url>
      
        <content type="html"><![CDATA[<h1 id="比较的是值是否相等"><a href="#比较的是值是否相等" class="headerlink" title="&#x3D;&#x3D;比较的是值是否相等"></a>&#x3D;&#x3D;比较的是值是否相等</h1> <span id="more"></span><p>如果作用于基本数据类型的变量，则直接比较其存储的 值是否相等，</p><p>如果作用于引用类型的变量，则比较的是所指向的对象的地址是否相等。</p><p><strong>equals比较的是是否是同一个对象</strong></p><p>equals()方法不能作用于基本数据类型的变量</p><p>equals()方法存在于Object类中，在没有重写equals()方法的类中，调用equals()方法其实和使用&#x3D;&#x3D;的效果一样，也是比较的是引用类型的变量所指向的对象的地址，不过，Java提供的类中，有些类都重写了equals()方法，重写后的equals()方法一般都是比较两个对象的值，比如String类。</p><p>String的equals源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">    if (this == anObject) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (anObject instanceof String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        int n = value.length;</span><br><span class="line">        if (n == anotherString.value.length) &#123;</span><br><span class="line">            char v1[] = value;</span><br><span class="line">            char v2[] = anotherString.value;</span><br><span class="line">            int i = 0;</span><br><span class="line">            while (n-- != 0) &#123;</span><br><span class="line">                if (v1[i] != v2[i])</span><br><span class="line">                    return false;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较的是值</p><p>所以示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int x = 10;</span><br><span class="line">int y = 10;</span><br><span class="line">String str1 = new String(&quot;abc&quot;);</span><br><span class="line">String str2 = new String(&quot;abc&quot;);</span><br><span class="line">System.out.println(x == y); // true</span><br><span class="line">System.out.println(str1 == str2); // false</span><br><span class="line">System.out.println(str1.equals(str2)); // true</span><br></pre></td></tr></table></figure><p>hashCode()方法和equals()方法的作用其实是一样的，在Java里都是用来对比两个对象是否相等一致。</p><p>但是hashCode()并不是完全可靠，<strong>有时候不同的对象他们生成的hashcode也会一样</strong>（生成hash值得公式可能存在的问题），所以hashCode()只能说是大部分时候可靠，并不是绝对可靠</p><p>所以有：</p><p><strong>1.equals()相等的两个对象他们的hashCode()肯定相等，也就是用equals()对比是绝对可靠的。</strong></p><p><strong>2.hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的</strong></p><p><img src="/iamges/==%EF%BC%8Cequals%EF%BC%8Chashcode/1.png" alt="img"></p><p>选B。</p><p>A、D选项是对字符串内容的比较。**JVM为了减少字符串对象的重复创建，其维护了一个特殊的内存，这段内存被成为字符串常量池。**代码中出现字面量形式创建字符串对象时，JVM首先会对这个字面量进行检查，如果字符串常量池中存在相同内容的字符串对象的引用，则将这个引用返回，否则新的字符串对象被创建，然后将这个引用放入字符串常量池，并返回该引用。所以返回true。</p><p>C选项是引用地址的比较，同上也属于常量池的同一个字符串地址，所以相等返回true。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux常用命令（持续更新）</title>
      <link href="/2023/08/09/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
      <url>/2023/08/09/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="linux常用命令（持续更新）"><a href="#linux常用命令（持续更新）" class="headerlink" title="linux常用命令（持续更新）"></a>linux常用命令（持续更新）</h1> <span id="more"></span><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bin/kafka-consumer-groups.sh --new-consumer --zookeeper <span class="number">172</span>.<span class="number">53</span>.<span class="number">81</span>.<span class="number">33</span>:<span class="number">2181</span> --topic aiops_warning --describe</span><br><span class="line"></span><br><span class="line">#消费topic</span><br><span class="line">bin/kafka-console-consumer.sh --zookeeper <span class="number">172</span>.<span class="number">53</span>.<span class="number">81</span>.<span class="number">33</span>:<span class="number">2181</span> --topic aiops_warning --from-beginning |grep &#x27;M_1040&#x27;&gt; console.log</span><br><span class="line">bin/kafka-console-consumer.sh --zookeeper <span class="number">172</span>.<span class="number">53</span>.<span class="number">81</span>.<span class="number">33</span>:<span class="number">2181</span> --topic cloud_dept_ping_host_bus</span><br><span class="line"></span><br><span class="line">#删除消费组</span><br><span class="line">bin/kafka-consumer-groups.sh --zookeeper <span class="number">172</span>.<span class="number">53</span>.<span class="number">81</span>.<span class="number">33</span>:<span class="number">2181</span> --group new-workplan-filter-test --delete</span><br><span class="line"></span><br><span class="line">#查看消费组</span><br><span class="line">bin/kafka-console-consumer.sh --bootstrap-server <span class="number">172</span>.<span class="number">53</span>.<span class="number">81</span>.<span class="number">33</span>:<span class="number">9092</span> --list</span><br><span class="line">bin/kafka-topics.sh --list --zookeeper <span class="number">172</span>.<span class="number">53</span>.<span class="number">81</span>.<span class="number">33</span>:<span class="number">2181</span></span><br><span class="line"></span><br><span class="line">#生产消息</span><br><span class="line">bin/kafka-console-producer.sh --broker-list <span class="number">172</span>.<span class="number">53</span>.<span class="number">81</span>.<span class="number">11</span>:<span class="number">9092</span> --topic cloud_dept_ping_host_bus</span><br><span class="line">bin/kafka-console-producer.sh --broker-list <span class="number">172</span>.<span class="number">168</span>.<span class="number">201</span>.<span class="number">25</span>:<span class="number">9092</span> --topic cloud_dept_ping_host_bus</span><br><span class="line"></span><br><span class="line">#查看集群节点权重</span><br><span class="line">bin/kafka-topics.sh --zookeeper <span class="number">172</span>.<span class="number">53</span>.<span class="number">81</span>.<span class="number">33</span>:<span class="number">2181</span> --describe  | grep &#x27;itmp_zabbix_data&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#跨服务器发送文件</span><br><span class="line">scp -P目标服务器端口 文件名 用户名@目标ip:目标文件夹</span><br><span class="line">scp -P58022 程序 sdnmuser@<span class="number">172</span>.<span class="number">53</span>.<span class="number">81</span>.<span class="number">13</span>:/home/sdnmuser/upload-file</span><br><span class="line">d=MG_l)&#123;<span class="number">2</span>cc</span><br><span class="line"></span><br><span class="line">#跨服务器拉拉取文件</span><br><span class="line">scp -P58022 sdnmuser@源服务器IP:/<span class="built_in">path</span>/to/源服务器文件 /目标服务器目录</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sftp  sdnmuser@<span class="number">132</span>.<span class="number">122</span>.<span class="number">150</span>.<span class="number">216</span> 输密码</span><br><span class="line">get 文件名</span><br><span class="line"></span><br><span class="line">#sdnmuser密码：<span class="number">9</span>LE1g#HnpEQd(E</span><br><span class="line">#dxwgwh30密码：l8@rxWXt0w93kp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ps -ef | grep zabbix_agent | grep -v grep  | awk -F &#x27; &#x27; &#x27;&#123;<span class="built_in">print</span> $<span class="number">2</span>&#125;&#x27; | xargs kill -<span class="number">9</span> </span><br><span class="line">#重启zabbix_agent</span><br><span class="line">sudo systemctl stop zabbix-agent</span><br><span class="line">/home/sdnmuser/zabbix_agent/sbin/zabbix_agentd -c /home/sdnmuser/zabbix_agent/zabbix_agentd.conf</span><br><span class="line">sudo systemctl <span class="built_in">start</span> zabbix-agent</span><br><span class="line"></span><br><span class="line">#重启zabbix_server</span><br><span class="line">sudo systemctl stop zabbix-server</span><br><span class="line">sudo systemctl <span class="built_in">start</span> zabbix-server</span><br><span class="line">sudo systemctl restart zabbix-server</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#通过进程号找进程位置</span><br><span class="line">ls -l /proc/&lt;pid&gt;/exe</span><br><span class="line"></span><br><span class="line">#通过端口找进程号</span><br><span class="line">sudo lsof -i:&lt;port&gt; -t</span><br><span class="line"></span><br><span class="line">#启动prometheus </span><br><span class="line">nohup ./prometheus --config.file=prometheus.yml &gt; /dev/null &amp;</span><br><span class="line"></span><br><span class="line">#修改分组</span><br><span class="line"></span><br><span class="line">#删除当前目录小于<span class="number">1</span>k的文件</span><br><span class="line"><span class="built_in">find</span> ./ -<span class="built_in">type</span> f  -maxdepth <span class="number">1</span> -size -<span class="number">1</span>k -exec rm -f &#123;&#125; \;</span><br><span class="line"></span><br><span class="line">ip a #就是网卡名</span><br><span class="line">#设置丢包率</span><br><span class="line">sudo tc qdisc add dev ens192 root netem loss <span class="number">50</span>%</span><br><span class="line">#解除丢包率</span><br><span class="line">sudo tc qdisc <span class="built_in">del</span> dev ens192 root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#执行</span><br><span class="line">ssh sdnmuser@<span class="number">132</span>.<span class="number">96</span>.<span class="number">28</span>.<span class="number">8</span> &#x27;sh -s&#x27; &lt; test_sybase.sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 设置iptables，放行<span class="number">80</span>端口和<span class="number">22</span>端口</span><br><span class="line">iptables -I INPUT -p tcp --dport <span class="number">80</span> -m state --state NEW -j ACCEPT</span><br><span class="line">iptables -I INPUT -p tcp --dport <span class="number">22</span> -m state --state NEW -j ACCEPT</span><br><span class="line"></span><br><span class="line">sudo iptables -nL</span><br><span class="line">sudo vim /etc/sysconfig/iptables</span><br><span class="line">sudo service iptables restart</span><br><span class="line"></span><br><span class="line"># INPUT链拒绝所有请求</span><br><span class="line">iptables -P INPUT DROP</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis的延迟加载</title>
      <link href="/2023/08/01/Mybatis%E7%9A%84%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD/"/>
      <url>/2023/08/01/Mybatis%E7%9A%84%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="Mybatis的延迟加载"><a href="#Mybatis的延迟加载" class="headerlink" title="Mybatis的延迟加载"></a>Mybatis的延迟加载</h1><span id="more"></span><p>延迟加载其实就是将<strong>数据加载时机推迟，比如推迟嵌套查询的执行时机</strong>。在Mybatis中经常用到关联查询，但是并不是任何时候都需要立即返回关联查询结果。比如查询订单信息，并不一定需要及时返回订单对应的产品信息，查询商品分类信息并不一定要及时返回该类别下有哪些产品，这种情况一下需要一种机制，当需要查看时，再执行查询，返回需要的结果集，这种需求在Mybatis中可以使用延迟加载机制来实现。延迟加载可以实现先查询主表，按需实时做关联查询，返回关联表结果集，一定程度上提高了效率。</p><p>以商品类别category和商品product为例，一个类别下可以有多个商品，一个商品属于一种类别。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> </span></span><br><span class="line"><span class="meta">    <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> </span></span><br><span class="line"><span class="meta">    <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.sl.mapper.LazyLoadMapper&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 分类信息查询 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;lazyLoadTest&quot;</span>  <span class="attr">resultMap</span>=<span class="string">&quot;lazyLoadProductsByCategoryTest&quot;</span>&gt;</span></span><br><span class="line">            select * from category where id=#&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;lazyLoadProductsByCategoryTest&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.sl.po.Category&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;Id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;Name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;remark&quot;</span> <span class="attr">property</span>=<span class="string">&quot;Remark&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 一个分类对应多个产品，此处使用collection --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;productList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.sl.po.Product&quot;</span>  <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">select</span>=<span class="string">&quot;selectProductsByCategoryId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 嵌套查询返回商品信息，延迟加载将要执行的sql --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectProductsByCategoryId&quot;</span>  <span class="attr">resultType</span>=<span class="string">&quot;com.sl.po.Product&quot;</span>&gt;</span></span><br><span class="line">            select * from products where categoryid=#&#123;id&#125; </span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>启用延迟加载和按需加载</strong></p><p>Mybatis配置文件中通过两个属性lazyLoadingEnabled和aggressiveLazyLoading来控制延迟加载和按需加载。</p><p>lazyLoadingEnabled：是否启用延迟加载，mybatis默认为false，不启用延迟加载。lazyLoadingEnabled属性控制全局是否使用延迟加载，特殊关联关系也可以通过嵌套查询中fetchType属性单独配置（fetchType属性值lazy或者eager）。</p><p>aggressiveLazyLoading：是否按需加载属性，默认值false，lazyLoadingEnabled属性启用时只要加载对象，就会加载该对象的所有属性；关闭该属性则会按需加载，即使用到某关联属性时，实时执行嵌套查询加载该属性。</p><p>SqlMapConfig.xml中修改配置，注册lazyLoadMapper.xml</p><p><img src="/iamges/Mybatis%E7%9A%84%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD/1.png" alt="img"></p><p><img src="/iamges/Mybatis%E7%9A%84%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD/2.png" alt="img"></p><p>此时没有运行嵌套查询，只允许了最外层的查询，因为运行到61之前只需要获取分类信息。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h2><p>它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName()，拦截器 invoke()方法发现 a.getB()是null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis批量插入的两种方式</title>
      <link href="/2023/08/01/mybatis%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2023/08/01/mybatis%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="mybatis批量插入的两种方式"><a href="#mybatis批量插入的两种方式" class="headerlink" title="mybatis批量插入的两种方式"></a>mybatis批量插入的两种方式</h1><span id="more"></span><h1 id="一-mybatis里的foreach标签"><a href="#一-mybatis里的foreach标签" class="headerlink" title="一. mybatis里的foreach标签"></a>一. mybatis里的foreach标签</h1><p>foreach的主要用在构建in条件中，它可以在SQL语句中进行迭代一个集合。foreach元素的属性主要有 item，index，collection，open，separator，close。item表示集合中每一个元素进行迭代时的别名，index指 定一个名字，用于表示在迭代过程中，每次迭代到的位置，open表示该语句以什么开始，separator表示在每次进行迭代之间以什么符号作为分隔 符，close表示以什么结束，在使用foreach的时候最关键的也是最容易出错的就是collection属性，该属性是必须指定的，但是在不同情况 下，该属性的值是不一样的，主要有一下3种情况：</p><p>如果传入的是单参数且参数类型是一个List的时候，collection属性值为list</p><p>如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array</p><p>如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了</p><p>具体用法如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> &lt;insert id=&quot;insertBatch&quot; parameterType=&quot;List&quot;&gt;              </span><br><span class="line"></span><br><span class="line">INSERT INTO TStudent(name,age)</span><br><span class="line"></span><br><span class="line">&lt;foreach collection=&quot;list&quot; item=&quot;item&quot; index=&quot;index&quot; open=&quot;(&quot;close=&quot;)&quot;separator=&quot;union all&quot;&gt;</span><br><span class="line"></span><br><span class="line">SELECT #&#123;item.name&#125; as a, #&#123;item.age&#125; as b FROM DUAL</span><br><span class="line"></span><br><span class="line">&lt;/foreach&gt;</span><br><span class="line"></span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure><h1 id="二、使用mybatis-ExecutorType-BATCH"><a href="#二、使用mybatis-ExecutorType-BATCH" class="headerlink" title="二、使用mybatis ExecutorType.BATCH"></a>二、使用mybatis ExecutorType.BATCH</h1><p>mybatis内置的ExecutorType有三种模式，默认为simple，该模式下它为每个语句的执行创建一个新的预处理语句，单条提交sql；而batch模式重复使用已经预处理的语句，并且批量执行所有更新语句，显然batch性能将更优； 但batch模式也有自己的问题，比如在Insert操作时，在事务没有提交之前，是没有办法获取到自增的id，这在某型情形下是不符合业务要求的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取sqlsession</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从spring注入原有的sqlSessionTemplate</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> SqlSessionTemplate sqlSessionTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新获取一个模式为BATCH，自动提交为false的session</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果自动提交设置为true,将无法控制提交的条数，改为最后统一提交，可能导致内存溢出</span></span><br><span class="line"></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionTemplate.getSqlSessionFactory().openSession(ExecutorType.BATCH,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过新的session获取mapper</span></span><br><span class="line"></span><br><span class="line">fooMapper = session.getMapper(FooMapper.class);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">Foo</span> <span class="variable">foo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line"></span><br><span class="line">foo.setName(String.valueOf(System.currentTimeMillis()));</span><br><span class="line"></span><br><span class="line">fooMapper.insert(foo);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i % <span class="number">1000</span> == <span class="number">0</span> || i == size - <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手动每1000个一提交，提交后无法回滚 </span></span><br><span class="line"></span><br><span class="line">session.commit();</span><br><span class="line"></span><br><span class="line"><span class="comment">//清理缓存，防止溢出</span></span><br><span class="line"></span><br><span class="line">session.clearCache();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//没有提交的数据可以回滚</span></span><br><span class="line"></span><br><span class="line">session.rollback();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line"></span><br><span class="line">session.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spring+mybatis</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL 解锁与锁表和批解锁</title>
      <link href="/2023/08/01/MYSQL%20%E8%A7%A3%E9%94%81%E4%B8%8E%E9%94%81%E8%A1%A8%E5%92%8C%E6%89%B9%E8%A7%A3%E9%94%81/"/>
      <url>/2023/08/01/MYSQL%20%E8%A7%A3%E9%94%81%E4%B8%8E%E9%94%81%E8%A1%A8%E5%92%8C%E6%89%B9%E8%A7%A3%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="MYSQL-解锁与锁表和批解锁"><a href="#MYSQL-解锁与锁表和批解锁" class="headerlink" title="MYSQL 解锁与锁表和批解锁"></a>MYSQL 解锁与锁表和批解锁</h1> <span id="more"></span><p>重启是可以解决表被锁的问题的，但针对线上业务很显然不太具有可行性。</p><p>下面来看看不用跑路的解决方案：</p><h2 id="第一步：查看表使用"><a href="#第一步：查看表使用" class="headerlink" title="第一步：查看表使用"></a>第一步：查看表使用</h2><p>遇到数据库阻塞问题，首先要查询一下表是否在使用。</p><p>复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show open tables where in_use &gt; 0 ;1.</span><br></pre></td></tr></table></figure><p>如果查询结果为空，那么说明表没在使用，说明不是锁表的问题。</p><p>复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ysql&gt;  show open tables where in_use &gt; 0 ;</span><br><span class="line"></span><br><span class="line">Empty set (0.00 sec)1.2.</span><br></pre></td></tr></table></figure><p>如果查询结果不为空，比如出现如下结果：</p><p>复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  show open tables where in_use &gt; 0 ;</span><br><span class="line"></span><br><span class="line">+----------+-------+--------+-------------+</span><br><span class="line"></span><br><span class="line">| Database | Table | In_use | Name_locked |</span><br><span class="line"></span><br><span class="line">+----------+-------+--------+-------------+</span><br><span class="line"></span><br><span class="line">| test     | t     |      1 |           0 |</span><br><span class="line"></span><br><span class="line">+----------+-------+--------+-------------+</span><br><span class="line"></span><br><span class="line">1 row in set (0.00 sec)1.2.3.4.5.6.7.</span><br></pre></td></tr></table></figure><p>则说明表(test)正在被使用，此时需要进一步排查。</p><h2 id="第二步：查看进程"><a href="#第二步：查看进程" class="headerlink" title="第二步：查看进程"></a>第二步：查看进程</h2><p>查看数据库当前的进程，看看是否有慢SQL或被阻塞的线程。</p><p>执行命令：</p><p>复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show processlist;1.</span><br></pre></td></tr></table></figure><p>该命令只显示当前用户正在运行的线程，当然，如果是root用户是能看到所有的。</p><p>在上述实践中，阿里云控制台之所以能够查看到所有的线程，猜测应该使用的就是root用户，而笔者去kill的时候，无法kill掉，是因为登录的用户非root的数据库账号，无法操作另外一个用户的线程。</p><h2 id="第三步：查看当前运行的所有事务"><a href="#第三步：查看当前运行的所有事务" class="headerlink" title="第三步：查看当前运行的所有事务"></a>第三步：查看当前运行的所有事务</h2><p>如果情况紧急，此步骤可以跳过，主要用来查看核对：</p><p>复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM information_schema.INNODB_TRX;1.</span><br></pre></td></tr></table></figure><h2 id="第四步：查看当前出现的锁"><a href="#第四步：查看当前出现的锁" class="headerlink" title="第四步：查看当前出现的锁"></a>第四步：查看当前出现的锁</h2><p>如果情况紧急，此步骤可以跳过，主要用来查看核对：</p><p>复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM information_schema.INNODB_LOCKs;1.</span><br></pre></td></tr></table></figure><h2 id="第五步：查询锁等待的对应关系"><a href="#第五步：查询锁等待的对应关系" class="headerlink" title="第五步：查询锁等待的对应关系"></a>第五步：查询锁等待的对应关系</h2><p>复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM information_schema.INNODB_LOCK_waits;1.</span><br></pre></td></tr></table></figure><p>看事务表INNODB_TRX中是否有正在锁定的事务线程，看看ID是否在show processlist的sleep线程中。如果在，说明这个sleep的线程事务一直没有commit或者rollback，而是卡住了，需要手动kill掉。</p><p>搜索的结果中，如果在事务表发现了很多任务，最好都kill掉。</p><h2 id="第六步：kill掉事务"><a href="#第六步：kill掉事务" class="headerlink" title="第六步：kill掉事务"></a>第六步：kill掉事务</h2><p>执行kill命令：</p><p>复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill 1011;1.</span><br></pre></td></tr></table></figure><p>对应的线程都执行完kill命令之后，后续事务便可正常处理。</p><p>针对紧急情况，通常也会直接操作第一、第二、第六步。</p><h2 id="MySQL的锁"><a href="#MySQL的锁" class="headerlink" title="MySQL的锁"></a>MySQL的锁</h2><p>这里再补充一些MySQL锁相关的知识点：数据库锁设计的初衷是处理并发问题，作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则，而锁就是用来实现这些访问规则的重要数据结构。</p><p>根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表级锁和行锁三类。MySQL中表级别的锁有两种：一种是表锁，一种是元数据锁(metadata lock，MDL)。</p><p>表锁是在Server层实现的，ALTER TABLE之类的语句会使用表锁，忽略存储引擎的锁机制。表锁通过lock tables… read&#x2F;write来实现，而对于InnoDB来说，一般会采用行级锁。毕竟锁住整张表影响范围太大了。</p><p>另外一个表级锁是MDL(metadata lock)，用于并发情况下维护数据的一致性，保证读写的正确性，不需要显式的使用，在访问一张表时会被自动加上。</p><h2 id="MySQL锁表场景"><a href="#MySQL锁表场景" class="headerlink" title="MySQL锁表场景"></a>MySQL锁表场景</h2><p>常见的一种锁表场景就是有事务操作处于：Waiting for table metadata lock状态。</p><p>Waiting for table metadata lock</p><p>MySQL在进行alter table等DDL操作时，有时会出现Waiting for table metadata lock的等待场景。</p><p>一旦alter table TableA的操作停滞在Waiting for table metadata lock状态，后续对该表的任何操作(包括读)都无法进行，因为它们也会在Opening tables的阶段进入到Waiting for table metadata lock的锁等待队列。如果核心表出现了锁等待队列，就会造成灾难性的后果。</p><h3 id="场景一：长事务运行，阻塞DDL，继而阻塞所有同表的后续操作。"><a href="#场景一：长事务运行，阻塞DDL，继而阻塞所有同表的后续操作。" class="headerlink" title="场景一：长事务运行，阻塞DDL，继而阻塞所有同表的后续操作。"></a>场景一：长事务运行，阻塞DDL，继而阻塞所有同表的后续操作。</h3><p>通过show processlist可以看到表上有正在进行的操作(包括读)，此时alter table语句无法获取到metadata 独占锁，会进行等待。</p><h3 id="场景二：为提交事务，阻塞DDL，继而阻塞所有同表的后续操作。"><a href="#场景二：为提交事务，阻塞DDL，继而阻塞所有同表的后续操作。" class="headerlink" title="场景二：为提交事务，阻塞DDL，继而阻塞所有同表的后续操作。"></a>场景二：为提交事务，阻塞DDL，继而阻塞所有同表的后续操作。</h3><p>通过show processlist看不到表上有任何操作，但实际上存在有未提交的事务，可以在</p><p>information_schema.innodb_trx中查看到。在事务没有完成之前，表上的锁不会释放，alter table同样获取不到metadata的独占锁。</p><p>处理方法：通过 select * frominformation_schema.innodb_trx\G, 找到未提交事物的sid，然后kill掉，让其回滚。</p><h3 id="场景三：显式事务失败操作获得锁，未释放"><a href="#场景三：显式事务失败操作获得锁，未释放" class="headerlink" title="场景三：显式事务失败操作获得锁，未释放"></a>场景三：显式事务失败操作获得锁，未释放</h3><p>通过show processlist看不到表上有任何操作，在</p><p>information_schema.innodb_trx中也没有任何进行中的事务。很可能是因为在一个显式的事务中，对表进行了一个失败的操作(比如查询了一个不存在的字段)，这时事务没有开始，但是失败语句获取到的锁依然有效，没有释放。从performance_schema.events_statements_current表中可以查到失败的语句。</p><p>处理方法：通过performance_schema.events_statements_current找到其sid，kill 掉该session，也可以kill掉DDL所在的session。</p><p>总之，alter table的语句是很危险的(核心是未提交事务或者长事务导致的)，在操作之前要确认对要操作的表没有任何进行中的操作、没有未提交事务、也没有显式事务中的报错语句。</p><p>如果有alter table的维护任务，在无人监管的时候运行，最好通过lock_wait_timeout设置好超时时间，避免长时间的metedata锁等待。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>关于MySQL的锁表其实还有很多其他场景，我们在实践的过程中尽量避免锁表情况的发生，当然这需要一定经验的支撑。但更重要的是，如果发现锁表我们要能够快速的响应，快速的解决问题，避免影响正常业务，避免情况进一步恶化。所以，本文中的解决思路大家一定要收藏或记忆一下，做到有备无患，避免突然状况下抓瞎。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GIT提交时切换账号</title>
      <link href="/2023/07/27/git%E6%8F%90%E4%BA%A4%E6%97%B6%E5%88%87%E6%8D%A2%E8%B4%A6%E5%8F%B7/"/>
      <url>/2023/07/27/git%E6%8F%90%E4%BA%A4%E6%97%B6%E5%88%87%E6%8D%A2%E8%B4%A6%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="GIT提交时切换账号"><a href="#GIT提交时切换账号" class="headerlink" title="GIT提交时切换账号"></a>GIT提交时切换账号</h1> <span id="more"></span><h2 id="要在git提交时切换账号，你可以按照以下步骤进行操作："><a href="#要在git提交时切换账号，你可以按照以下步骤进行操作：" class="headerlink" title="要在git提交时切换账号，你可以按照以下步骤进行操作："></a>要在git提交时切换账号，你可以按照以下步骤进行操作：</h2><ol><li><p>查看当前git用户信息：在命令行中输入以下命令，可以查看当前git账号的用户名和邮箱。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git config user.name</span><br><span class="line"></span><br><span class="line">git config user.email</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>切换到新的git账号：如果要使用不同的git账号提交，可以按照以下步骤进行切换。</p><p>– 修改全局git用户信息：在命令行中输入以下命令，将全局的git用户名和邮箱修改为新的账号信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config –global user.name “New User Name”</span><br><span class="line">   </span><br><span class="line">git config –global user.email “New User Email”</span><br></pre></td></tr></table></figure><p>– 修改当前仓库的git用户信息：在命令行中进入到对应的git仓库目录，输入以下命令，将当前仓库的git用户名和邮箱修改为新的账号信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config user.name “New User Name”</span><br><span class="line">   </span><br><span class="line">git config user.email “New User Email”</span><br></pre></td></tr></table></figure></li><li><p>提交代码：现在你可以使用新的git账号提交代码了。</p><p>– 添加修改到暂存区：在命令行中使用git add命令将修改的文件添加到暂存区。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add      #– 提交代码到本地仓库：在命令行中使用git commit命令将暂存区的修改提交到本地仓库。 </span><br><span class="line">git commit -m &quot;Commit message&quot;   #推送代码到远程仓库：在命令行中使用git push命令将本地仓库的修改推送到远程仓库。     git push origin     </span><br></pre></td></tr></table></figure></li></ol><p>通过以上步骤，你可以在git提交时切换到不</p><ol start="3"><li>重新提交代码</li></ol><p>假设你已经在本地进行了更改并且想用新账号提交这些更改，你可以执行以下步骤：</p><p><strong>3.1 取消上一次提交（如果已经提交但未推送）</strong></p><p>如果你已经提交了代码，但想使用新账号重新提交，可以先撤销最后一次提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD~1</span><br></pre></td></tr></table></figure><p>这样做会保留你的更改，但取消提交。</p><p><strong>3.2 重新提交</strong></p><p>现在用新账号提交代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;Your commit message&quot;</span><br></pre></td></tr></table></figure><p><strong>3.3 推送到远程仓库</strong></p><p>最后，将提交推送到远程仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin branch-name</span><br></pre></td></tr></table></figure><p>其中 branch-name 是你要推送的分支名称。</p>]]></content>
      
      
      <categories>
          
          <category> GIT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GIT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git Commit规范</title>
      <link href="/2023/04/01/Git%20Commit%E8%A7%84%E8%8C%83/"/>
      <url>/2023/04/01/Git%20Commit%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="Git-Commit规范"><a href="#Git-Commit规范" class="headerlink" title="Git Commit规范"></a>Git Commit规范</h1><span id="more"></span><p><strong>参考资料</strong></p><p><a href="https://juejin.cn/post/7243451555930898469">https://juejin.cn/post/7243451555930898469</a></p><p><strong>关键词</strong></p><p>……</p><p><strong>结构样式</strong></p><p>每个 commit message 包含一个 header，body 和 footer。header 有一个特殊的格式包含有 type，scope 和 subject：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt; &lt;issus-ID&gt;</span><br><span class="line"></span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;BLANK LINE&gt;</span><br></pre></td></tr></table></figure><footer><p>header、body、footer 之间都要空一行，header 是必填项，scope 是选填项。commit message 的每一行的文字不能超过 100 个字符。这样子在 github 和 git 工具上更便于阅读。</p><p><strong>header</strong></p><p><strong>Type</strong></p><p>type 用于说明 commit 的类别，必须为以下类型的一种：</p><ul><li><p><strong>feat</strong>：增加新功能（feature）</p></li><li><p><strong>fix</strong>： 修复问题&#x2F;BUG</p></li><li><p><strong>style</strong>： 代码风格相关无影响运行结果的</p></li><li><p><strong>perf</strong>： 优化相关，比如提升性能、体验。</p></li><li><p><strong>refactor</strong>：重构，既不是修复 bug 也不是添加新功能的代码更改</p></li><li><p><strong>revert</strong>：回滚到上一个版本，撤销功能，撤销修改</p></li><li><p><strong>test</strong>： 测试相关</p></li><li><p><strong>docs</strong>：文档&#x2F;注释（documentation）</p></li><li><p><strong>chore</strong>： 依赖更新&#x2F;脚手架配置修改等</p></li><li><p>**workflow：**工作流改进</p></li><li><p><strong>ci</strong>： 持续集成</p></li><li><p><strong>types：</strong> 类型定义文件更改</p></li><li><p><strong>merge</strong>：代码合并</p></li><li><p><strong>sync</strong>：同步主线或分支的Bug</p></li><li><p><strong>build</strong>： 影响构建系统或外部依赖关系的更新(范围:gulp，broccoli，npm)</p></li></ul><p><strong>Scope</strong></p><p>scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同，当影响的范围有多个时候，可以使用 *。</p><p>例如在Angular，可以是location，browser，compile，compile，rootScope， ngHref，ngClick，ngView等。</p><p><strong>Subject</strong></p><p>subject 用于对 commit 变化的简洁描述，不超过50个字符：</p><ul><li><p>使用祈使句，一般以动词原形开始，例如使用 change 而不是 changed 或者 changes</p></li><li><p>第一个字母小写</p></li><li><p>结尾不加句号或其他标点符号。（.或 。）</p></li></ul><p><strong>Body</strong></p><ul><li><p>body 用于对 commit 详细描述。使用祈使句，一般以动词原形开始，例如使用 change 而不是 changed 或者 changes。</p></li><li><p>body 应该包含这次变化的动机以及与之前行为的对比。</p></li></ul><p><strong>Footer</strong></p><ul><li>footer 目前用于两种情况。</li></ul><p><strong>不兼容的变动</strong></p><p>所有不兼容的变动都必须在 footer 区域进行说明，以 BREAKING CHANGE: 开头，后面的是对变动的描述，变动的理由和迁移注释。</p><p>BREAKING CHANGE: isolate scope bindings definition has changed and</p><pre><code>the inject option for the directive controller injection was removed.Before:scope: &#123;  myAttr: &#39;attribute&#39;,  myBind: &#39;bind&#39;,  myExpression: &#39;expression&#39;,  myEval: &#39;evaluate&#39;,  myAccessor: &#39;accessor&#39;&#125;After:scope: &#123;  myAttr: &#39;@&#39;,  myBind: &#39;@&#39;,  myExpression: &#39;&amp;&#39;,  // myEval - usually not useful, but in cases where the expression is assignable, you can use &#39;=&#39;  myAccessor: &#39;=&#39; // in directive&#39;s template change myAccessor() to myAccessor&#125;</code></pre><p> The removed <code>inject</code> wasn’t generaly useful for directives so there should be no code using it.</p><p><strong>关闭 issue</strong></p><p>如果 commit 是针对某个 issue，可以在 footer 关闭这个 issue。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">## 关闭单个</span><br><span class="line"></span><br><span class="line">Closes #234</span><br><span class="line"></span><br><span class="line">## 关闭多个</span><br><span class="line"></span><br><span class="line">Closes #123, #245, #992</span><br></pre></td></tr></table></figure><p><strong>Revert</strong></p><p>如果 commit 用于撤销之前的 commit，这个 commit 就应该以 revert: 开头，后面是撤销这个 commit 的 header。在 body 里面应该写 This reverts commit <hash>.，其中的 hash 是被撤销 commit 的 SHA 标识符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">revert: feat(pencil): add &#x27;graphiteWidth&#x27; option</span><br><span class="line"></span><br><span class="line">This reverts commit 667ecc1654a317a13331b17617d973392f415f02.</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">feat($browser): onUrlChange event (popstate/hashchange/polling)</span><br><span class="line"></span><br><span class="line">Added new event to $browser:</span><br><span class="line"></span><br><span class="line">- forward popstate event if available</span><br><span class="line"></span><br><span class="line">- forward hashchange event if popstate not available</span><br><span class="line"></span><br><span class="line">- do polling when neither popstate nor hashchange available</span><br><span class="line"></span><br><span class="line">Breaks $browser.onHashChange, which was removed (use onUrlChange instead)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fix($compile): couple of unit tests for IE9</span><br><span class="line"></span><br><span class="line">Older IEs serialize html uppercased, but IE9 does not...</span><br><span class="line"></span><br><span class="line">Would be better to expect case insensitive, unfortunately jasmine does</span><br><span class="line"></span><br><span class="line">not allow to user regexps for throw expectations.</span><br><span class="line"></span><br><span class="line">Closes #351</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">style($location): add couple of missing semi colons</span><br></pre></td></tr></table></figure><ul><li><pre><code>docs(guide): updated fixed docs from Google DocsCouple of typos fixed:- indentation- batchLogbatchLog -&gt; batchLog- start periodic checking- missing brace</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> GIT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GIT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea配置父子模块工程</title>
      <link href="/2023/04/01/idea%E9%85%8D%E7%BD%AE%E7%88%B6%E5%AD%90%E6%A8%A1%E5%9D%97%E5%B7%A5%E7%A8%8B/"/>
      <url>/2023/04/01/idea%E9%85%8D%E7%BD%AE%E7%88%B6%E5%AD%90%E6%A8%A1%E5%9D%97%E5%B7%A5%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="idea配置父子模块工程"><a href="#idea配置父子模块工程" class="headerlink" title="idea配置父子模块工程"></a>idea配置父子模块工程</h1><span id="more"></span><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol><li><p>在Gitee创建一个新仓库</p></li><li><p>初始化本地仓库</p></li><li><p>创建README.md并提交，保证仓库不是空仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></li><li><p>进入父仓库目录，输入以下命令</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">touch README.md</span><br><span class="line">git commit -m &quot;说明&quot;</span><br><span class="line"># 关联远程仓库（在Gitee新建仓库后跳转到的页面会给出刚创建的远程仓库地址 也就是clone地址）</span><br><span class="line">git remote add origin https://gitee.com/xxx/xxx</span><br><span class="line"># 提交到远程仓库 使用 -u 下次提交就可以直接使用git push</span><br><span class="line">git push -u origin &quot;master&quot;</span><br></pre></td></tr></table></figure><h2 id="git-命令-u-含义"><a href="#git-命令-u-含义" class="headerlink" title="git 命令 -u 含义"></a>git 命令 -u 含义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">官网解释（大概意思就是使用-u时的本地分支与远程分支建立联系，下次使用要指定分支的命令时可以不用再指定分支）</span><br><span class="line">-u</span><br><span class="line">--set-upstream</span><br><span class="line">For every branch that is up to date or successfully pushed, add upstream (tracking) reference, used by argument-less git-pull and other commands.</span><br></pre></td></tr></table></figure><h1 id="如果idea拉取之后父模块没有代码"><a href="#如果idea拉取之后父模块没有代码" class="headerlink" title="如果idea拉取之后父模块没有代码"></a>如果idea拉取之后父模块没有代码</h1><p>如果你在IntelliJ IDEA中没有看到子模块相关的选项，并且确认项目中确实没有子模块，那么你可能需要检查项目的<code>.gitmodules</code>文件和<code>.git/config</code>文件来确保子模块配置正确。以下是一些步骤来帮助你解决这个问题：</p><h3 id="检查-gitmodules-文件"><a href="#检查-gitmodules-文件" class="headerlink" title="检查 .gitmodules 文件"></a>检查 <code>.gitmodules</code> 文件</h3><ol><li><p><strong>打开 <code>.gitmodules</code> 文件</strong>：</p><ul><li>在项目根目录下找到 <code>.gitmodules</code> 文件并打开它。</li><li>确认文件中是否有正确的子模块配置。</li></ul></li><li><p><strong>添加或修改子模块配置</strong>：</p><ul><li><p>如果文件中没有子模块配置，你可以手动添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[submodule &quot;path/to/submodule&quot;]</span><br><span class="line">    path = path/to/submodule</span><br><span class="line">    url = https://example.com/path/to/submodule.git</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="初始化和更新子模块"><a href="#初始化和更新子模块" class="headerlink" title="初始化和更新子模块"></a>初始化和更新子模块</h3><ol><li><p><strong>通过命令行初始化子模块</strong>：</p><ul><li><p>打开IntelliJ IDEA的终端（通常位于底部工具栏，标签名为“Terminal”）。</p></li><li><p>输入以下命令来初始化和更新子模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>通过图形界面初始化子模块</strong>：</p></li></ol><ul><li>打开 <code>VCS</code> 菜单。</li><li>选择 <code>Git</code> &gt; <code>Submodule</code> &gt; <code>Update...</code>。</li><li>在弹出的对话框中，确保选中了所有需要初始化和更新的子模块，然后点击“OK”。</li></ul><h3 id="示例操作"><a href="#示例操作" class="headerlink" title="示例操作"></a>示例操作</h3><p>假设你的项目结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">project-root/</span><br><span class="line">├── .git/</span><br><span class="line">├── .gitmodules</span><br><span class="line">├── src/</span><br><span class="line">└── submodules/</span><br><span class="line">    └── submodule1/</span><br></pre></td></tr></table></figure><ol><li><p><strong>打开 <code>.gitmodules</code> 文件</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[submodule &quot;submodules/submodule1&quot;]</span><br><span class="line">    path = submodules/submodule1</span><br><span class="line">    url = https://example.com/path/to/submodule1.git</span><br></pre></td></tr></table></figure></li><li><p><strong>通过命令行初始化子模块</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br></pre></td></tr></table></figure></li><li><p><strong>通过图形界面初始化子模块</strong>：</p><ul><li>打开 <code>VCS</code> 菜单。</li><li>选择 <code>Git</code> &gt; <code>Submodule</code> &gt; <code>Update...</code>。</li><li>确保选中了所有需要初始化和更新的子模块，然后点击“OK”。</li></ul></li></ol><p>通过以上步骤，你应该能够成功初始化并更新子模块，解决子模块没有代码的问题。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GIT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mockito单元测试</title>
      <link href="/2023/02/15/Mockito%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
      <url>/2023/02/15/Mockito%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Mockito单元测试"><a href="#Mockito单元测试" class="headerlink" title="Mockito单元测试"></a>Mockito单元测试</h1><span id="more"></span><p>使用Mockito可以mock对象，定义对象中代码逻辑的执行结果，mock对象对逻辑执行也只是做记录而不会真正执行，使用spy创建spy对象的话则会执行真实的代码逻辑，如果打桩就会返回定义的结果，不打桩就返回真实执行的返回结果。</p><h2 id="一、api"><a href="#一、api" class="headerlink" title="一、api"></a>一、api</h2><p>org.mockito.Mockito是mockito提供的核心api，提供了大量的静态方法，用于帮助我们来mock对象，验证行为等等，然后需要注意的是，很多方法都被封装在了MockitoCore类里面</p><ul><li><p>mock：构建一个我们需要的对象；可以mock具体的对象，也可以mock接口。</p></li><li><p>spy：构建监控对象</p></li><li><p>verify：验证某种行为</p></li><li><p>when：当执行什么操作的时候，一般配合thenXXX 一起使用。表示执行了一个操作之后产生什么效果。</p></li><li><p>doReturn：返回什么结果</p></li><li><p>doThrow：抛出一个指定异常</p></li><li><p>doAnswer：做一个什么相应，需要我们自定义Answer；</p></li><li><p>times：某个操作执行了多少次</p></li><li><p>atLeastOnce：某个操作至少执行一次</p></li><li><p>atLeast：某个操作至少执行指定次数</p></li><li><p>atMost：某个操作至多执行指定次数</p></li><li><p>atMostOnce：某个操作至多执行一次</p></li><li><p>doNothing：不做任何处理</p></li><li><p>doReturn：返回一个结果</p></li><li><p>doThrow：抛出一个指定异常</p></li><li><p>doAnswer：指定一个操作，传入Answer</p></li><li><p>doCallRealMethod：返回真实业务执行的结果，只能用于监控对象</p></li></ul><h2 id="二、ArgumentMatchers"><a href="#二、ArgumentMatchers" class="headerlink" title="二、ArgumentMatchers"></a>二、ArgumentMatchers</h2><p>用于进行参数匹配，减少很多不必要的代码</p><p>-<br>  anyInt：任何int类型的参数，类似的还有anyLong&#x2F;anyByte等等。</p><p>-<br>  eq：等于某个值的时候，如果是对象类型的，则看toString方法</p><p>-<br>  isA：匹配某种类型</p><p>-<br>  matches：使用正则表达式进行匹配</p><h2 id="三、OngoingStubbing"><a href="#三、OngoingStubbing" class="headerlink" title="三、OngoingStubbing"></a>三、OngoingStubbing</h2><ul><li><p>OngoingStubbing用于返回操作的结果。</p></li><li><p>thenReturn：指定一个返回的值</p></li><li><p>thenThrow：抛出一个指定异常</p></li><li><p>then：指定一个操作，需要传入自定义Answer；</p></li><li><p>thenCallRealMethod：返回真实业务执行的结果，只能用于监控对象。</p></li></ul><h2 id="mock对象"><a href="#mock对象" class="headerlink" title="mock对象"></a><strong>mock对象</strong></h2><p>顾名思义，就是模仿一个对象，对象的交互都会被模仿，因此可以根据自己的需求选择相应交互去验证或设置返回自己想要的结果，但是对于对象的行为只会被记录，不会实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">void testBehavior() &#123;</span><br><span class="line"> </span><br><span class="line">    //构建moock数据</span><br><span class="line">    List&lt;String&gt; list = mock(List.class);</span><br><span class="line">    list.add(&quot;1&quot;);</span><br><span class="line">    list.add(&quot;2&quot;);</span><br><span class="line"> </span><br><span class="line">    System.out.println(list.get(0)); // 会得到null ，前面只是在记录行为而已，没有往list中添加数据</span><br><span class="line"> </span><br><span class="line">    verify(list).add(&quot;1&quot;); // 正确，因为该行为被记住了</span><br><span class="line">    verify(list).add(&quot;3&quot;);//报错，因为前面没有记录这个行为</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="stub-打桩"><a href="#stub-打桩" class="headerlink" title="stub 打桩"></a><strong>stub 打桩</strong></h2><p>用于预先说明当执行了什么操作的时候，产生一个什么响应，一旦测试桩函数被调用，该函数将会一致返回固定的值</p><p>常用打桩函数：when 、thenReturn、then、thenThrow、thenAnswer这几个函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">void testStub() &#123;</span><br><span class="line">    List&lt;Integer&gt; l = mock(ArrayList.class);</span><br><span class="line"> </span><br><span class="line">    when(l.get(0)).thenReturn(10);</span><br><span class="line">    when(l.get(1)).thenReturn(20);</span><br><span class="line">    when(l.get(2)).thenThrow(new RuntimeException(&quot;no such element&quot;));</span><br><span class="line"> </span><br><span class="line">    assertEquals(l.get(0), 10);</span><br><span class="line">    assertEquals(l.get(1), 20);</span><br><span class="line">    assertNull(l.get(4));</span><br><span class="line">    assertThrows(RuntimeException.class, () -&gt; &#123;</span><br><span class="line">        int x = l.get(2);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>void函数存根</p><p>主要用到doThrow(), doAnswer(), doNothing(), doReturn() and doCallRealMethod()等函数，当然，这些函数也可以用于有返回值的函数的存根；需要注意的是，doCallRealMethod不能用于Mock对象，只能用于监察对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">void testVoidStub()&#123;</span><br><span class="line">    List&lt;Integer&gt; l = mock(ArrayList.class);</span><br><span class="line">    doReturn(10).when(l).get(1);</span><br><span class="line">    doThrow(new RuntimeException(&quot;you cant clear this List&quot;)).when(l).clear();</span><br><span class="line"> </span><br><span class="line">    assertEquals(l.get(1),10);</span><br><span class="line">    assertThrows(RuntimeException.class,()-&gt;l.clear());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="spy"><a href="#spy" class="headerlink" title="spy"></a><strong>spy</strong></h2><p>spy类的原理是，如果不打桩默认都会执行真实的方法，如果打桩则返回桩实现。</p><p>对 spy 变量打桩时，如果使用 when 去设置模拟值时，他里面的代码逻辑依然会被执行，只是mock了返回结果；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">void testBehavior() &#123;</span><br><span class="line"> </span><br><span class="line">    //构建moock数据</span><br><span class="line">    List&lt;String&gt; list = mock(List.class);</span><br><span class="line">    list.add(&quot;1&quot;);</span><br><span class="line">    list.add(&quot;2&quot;);</span><br><span class="line">    List&lt;String&gt; list2 = spy(List.class);</span><br><span class="line">    list2.add(&quot;1&quot;);</span><br><span class="line">    list2.add(&quot;2&quot;);</span><br><span class="line"> </span><br><span class="line">    System.out.println(list.get(0)); // 会得到null ，前面只是在记录行为而已，没有往list中添加数据</span><br><span class="line">    System.out.println(list2.get(0)); // 会得到1，执行了真实的代码逻辑</span><br><span class="line"> </span><br><span class="line">    verify(list).add(&quot;1&quot;); // 正确，因为该行为被记住了</span><br><span class="line">    verify(list).add(&quot;3&quot;);//报错，因为前面没有记录这个行为</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java spi</title>
      <link href="/2023/02/01/java%20spi/"/>
      <url>/2023/02/01/java%20spi/</url>
      
        <content type="html"><![CDATA[<h1 id="java-spi"><a href="#java-spi" class="headerlink" title="java spi"></a>java spi</h1><span id="more"></span><p><strong>SPI组成</strong></p><p>spi机制由三个组件形成，分别是service(公开的接口或者抽象类)， service Provider（接口的实现类），ServiceLoader（核心组件，负责在运行时加载并发现实现类）</p><p><strong>运行流程</strong></p><p>![img](&#x2F;iamges&#x2F;java spi&#x2F;1.png)</p><p>application调用serviceLoader加载实现类， 最终application拿到的是service接口，不关心具体的实现</p><p>java spi在JDBC中的应用：</p><p>出现前：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(&quot;驱动名&quot;);</span><br></pre></td></tr></table></figure><p>出现后，直接添加依赖即可！</p><p>![img](&#x2F;iamges&#x2F;java spi&#x2F;2.png)</p><p><strong>java spi三大规范要素</strong></p><p>一、</p><p>路径：配置文件的文件路径必须在JAR包中的META-INF&#x2F;services目录下；</p><p>名称：service接口的全限定名</p><p>内容：service接口实现类的全限定名，每个实现类都需要单独占据一行</p><p>二、</p><p>service接口的实现类必须具备无参的默认构造方法，因为之后通过反射技术实例化它时，是不带参数的</p><p>三、</p><p>保证能加载到配置文件和接口实现类</p><p>方式1：将接口实现类的jar包放在classpath中</p><p>方式2：将jar包安装在jre的扩展目录中</p><p>方式3：自定义一个classLoader</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h2><p>提供一种组件发现和注册的方式，可以用于实现各种插件，或者灵活替换框架所使用的组件</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h2><p>基于面向接口编程，优雅地实现模块之间的解耦</p><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a><strong>设计思想</strong></h2><p>面向接口 + 配置文件 + 反射技术</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h2><p>JDBC实现（导入maven依赖）, 切换实现api项目</p><p>例子</p><p>SPIdemo</p><p>定义一个接口模块</p><p>![img](&#x2F;iamges&#x2F;java spi&#x2F;3.png)</p><p>引入接口模块依赖并创建两个实现类模块，并在classpath路径下创建META-INF services目录 创建对应配置文件</p><p>![img](&#x2F;iamges&#x2F;java spi&#x2F;4.png)</p><p>![img](&#x2F;iamges&#x2F;java spi&#x2F;5.png)</p><p>![img](&#x2F;iamges&#x2F;java spi&#x2F;6.png)</p><p>![img](&#x2F;iamges&#x2F;java spi&#x2F;7.png)</p><p>![img](&#x2F;iamges&#x2F;java spi&#x2F;8.png)</p><p>创建application调用其中的实现类(通过类加载器加载接口，只关注接口)</p><p>引入对应实现类的依赖</p><p>![img](&#x2F;iamges&#x2F;java spi&#x2F;9.png)</p><p>![img](&#x2F;iamges&#x2F;java spi&#x2F;10.png)</p><h2 id="Java-SPI与springboot的自动配置"><a href="#Java-SPI与springboot的自动配置" class="headerlink" title="Java SPI与springboot的自动配置"></a><strong>Java SPI与springboot的自动配置</strong></h2><p>spring启动类默认扫描的是所在包下的类</p><p>![img](&#x2F;iamges&#x2F;java spi&#x2F;11.png)</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工程输出中文乱码，全局各种配置UTF-8后依旧没作用</title>
      <link href="/2023/02/01/%E5%B7%A5%E7%A8%8B%E8%BE%93%E5%87%BA%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%EF%BC%8C%E5%85%A8%E5%B1%80%E5%90%84%E7%A7%8D%E9%85%8D%E7%BD%AEUTF-8%E5%90%8E%E4%BE%9D%E6%97%A7%E6%B2%A1%E4%BD%9C%E7%94%A8/"/>
      <url>/2023/02/01/%E5%B7%A5%E7%A8%8B%E8%BE%93%E5%87%BA%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%EF%BC%8C%E5%85%A8%E5%B1%80%E5%90%84%E7%A7%8D%E9%85%8D%E7%BD%AEUTF-8%E5%90%8E%E4%BE%9D%E6%97%A7%E6%B2%A1%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="工程输出中文乱码，全局各种配置UTF-8后依旧没作用"><a href="#工程输出中文乱码，全局各种配置UTF-8后依旧没作用" class="headerlink" title="工程输出中文乱码，全局各种配置UTF-8后依旧没作用"></a>工程输出中文乱码，全局各种配置UTF-8后依旧没作用</h1><span id="more"></span><p><strong>旧开发的坑</strong></p><p><strong>首先检查工程之前的编码，以前的开发没注意创建一些文件时会直接默认成GBK编码，打开项目，idea编译器会提示为GBK编码，中文显示乱码，一开始就设置项目为GBK才能看到中文显示，而现在开发大部分默认设置成UTF-8，</strong></p><p><strong>所以新建文件都是UTF-8，编译走了UTF-8后执行就会显示成中文乱码，暴力解决思路，把涉及到的文件删除新建，或者整个工程重新新建，一开始就默认成了UTF-8就能解决一切</strong></p><p><img src="/iamges/%E5%B7%A5%E7%A8%8B%E8%BE%93%E5%87%BA%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%EF%BC%8C%E5%85%A8%E5%B1%80%E5%90%84%E7%A7%8D%E9%85%8D%E7%BD%AEUTF-8%E5%90%8E%E4%BE%9D%E6%97%A7%E6%B2%A1%E4%BD%9C%E7%94%A8/1.png" alt="img"></p><p><strong>因为文件编码与全局编码设置不一样，重新建一个文件覆盖这个同名文件即可，可能是之前开发建文件时的全局编码设置为gbk导致，然后现在开发设置的全局编码普遍为utf-8，所以编译执行后中文就会乱码</strong></p><p>#############################################</p><p><strong>常规解决</strong></p><p>**解决方案一、**<strong>项目设置pom文件编译的编码格式为utf-8</strong></p><p>在maven项目的pom.xml文件设置编译插件及项目编码<encoding>UTF-8</encoding>，具体如下图所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">        &lt;!-- 插件 --&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;!-- 编译插件 --&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;3.3&lt;/version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;compilerVersion&gt;$&#123;java.version&#125;&lt;/compilerVersion&gt;</span><br><span class="line">                    &lt;source&gt;$&#123;java.version&#125;&lt;/source&gt;</span><br><span class="line">                    &lt;target&gt;$&#123;java.version&#125;&lt;/target&gt;</span><br><span class="line">                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span><br><span class="line">                    &lt;!-- prevents endPosTable exception for maven compile --&gt;</span><br><span class="line">                    &lt;useIncrementalCompilation&gt;false&lt;/useIncrementalCompilation&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p><strong>解决方案二、idea设置File Encodings为utf-8</strong></p><p>idea打开配置，搜索encode，配置如下图所示：</p><p><img src="/iamges/%E5%B7%A5%E7%A8%8B%E8%BE%93%E5%87%BA%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%EF%BC%8C%E5%85%A8%E5%B1%80%E5%90%84%E7%A7%8D%E9%85%8D%E7%BD%AEUTF-8%E5%90%8E%E4%BE%9D%E6%97%A7%E6%B2%A1%E4%BD%9C%E7%94%A8/2.png" alt="img"></p><p><strong>解决方案三、tomcat启动配置设置VM编码参数</strong></p><p>编辑tomcat启动配置，添加VM参数：-Dfile.encoding&#x3D;UTF-8</p><p><img src="/iamges/%E5%B7%A5%E7%A8%8B%E8%BE%93%E5%87%BA%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%EF%BC%8C%E5%85%A8%E5%B1%80%E5%90%84%E7%A7%8D%E9%85%8D%E7%BD%AEUTF-8%E5%90%8E%E4%BE%9D%E6%97%A7%E6%B2%A1%E4%BD%9C%E7%94%A8/3.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络基础</title>
      <link href="/2023/01/01/%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/01/01/%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><span id="more"></span><h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><h3 id="一、OSI七层模型"><a href="#一、OSI七层模型" class="headerlink" title="一、OSI七层模型"></a>一、OSI七层模型</h3><p>OSI（Open Systems Interconnection）七层模型是一种网络通信的参考模型，它将网络通信过程划分为七个层次，从上到下分别是：应用层、表示层、会话层、传输层、网络层、数据链路层和物理层。下面我们将详细介绍每个层次及其对应的协议。</p><ol><li>应用层<br>应用层是OSI模型的最上层，负责处理特定的应用程序细节。常见的协议包括TELNET、FTP、TFTP、SMTP、SNMP、HTTP、BOOTP、DHCP和DNS等。</li><li>表示层<br>表示层负责对数据进行编码和解码，以确保发送方和接收方之间的数据格式一致。常见的表示层协议包括文本的ASCII和EBCDIC编码，以及图形、声音等<a href="https://cloud.baidu.com/solution/media.html">多媒体</a>数据的TIFF、JPEG、GIF、PICT和MIDI等编码方式。</li><li>会话层<br>会话层负责建立、管理和终止会话（即数据通信的对话）。常见的会话层协议包括Socket、NFS、SQL、RPC、X-WINDOWS、ASP（APPTALK会话协议）和SCP等。</li><li>传输层<br>传输层负责建立端到端的连接，确保数据能够可靠地传输到目标端。常见的传输层协议包括TCP和UDP等。</li><li>网络层<br>网络层负责将数据包从源地址发送到目标地址，并在必要时通过路由选择来选择最佳路径。常见的网络层协议包括IP、IPX、ICMP和RIP等。</li><li>数据链路层<br>数据链路层负责将数据包从源节点发送到目标节点，通常涉及到与网络硬件（如交换机和路由器）的直接交互。常见的数据链路层协议包括SDLC、HDLC、PPP、STP（Spanning Tree Protocol）和帧中继等。</li><li>物理层<br>物理层负责将数据以比特流的形式传输，主要关注硬件设备（如电缆和收发器）的电气和机械特性。常见的物理层协议包括EIA&#x2F;TIA RS-232、EIA&#x2F;TIA RS-449、V.35、RJ-45等。</li></ol><h3 id="二、TCP-IP模型"><a href="#二、TCP-IP模型" class="headerlink" title="二、TCP&#x2F;IP模型"></a>二、TCP&#x2F;IP模型</h3><p>TCP&#x2F;IP（Transmission Control Protocol&#x2F;Internet Protocol）模型是一种简化的网络通信模型，它将OSI模型的某些层次进行了合并。TCP&#x2F;IP模型分为四层：应用层、传输层、网络层和链路层。下面我们将介绍每个层次及其对应的协议。</p><ol><li>应用层<br>应用层负责处理应用程序的细节，与OSI模型的应用层类似。常见的协议包括Telnet、FTP、HTTP、SMTP和DNS等。</li><li>传输层<br>传输层负责建立端到端的连接，确保数据的可靠传输。常见的协议包括TCP和UDP等。</li><li>网络层<br>网络层负责将数据包从源地址发送到目标地址。常见的协议包括IP、ICMP和RIP等。</li><li>链路层<br>链路层负责将数据包从源节点发送到目标节点，与OSI模型的数据链路层类似。常见的协议包括Ethernet、ARP等。</li></ol><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><ol><li>客户端发送SYN报文至服务端，客户端处于syn-sent状态</li><li>服务端发送SYN+ACK报文至客户端，服务端处于syn-rcvd（received）状态</li><li>客户端发送ack报文至服务端**（可携带数据）**，客户端处于established状态</li></ol><h2 id="之所以三次的原因"><a href="#之所以三次的原因" class="headerlink" title="之所以三次的原因"></a>之所以三次的原因</h2><p>​ <strong>主要是为了建立可靠的通信信道，保证客户端与服务端同时具备发送、接收数据的能力</strong></p><ol><li><p>可以在发生网络阻塞或者客户端宕机时阻止历史连接</p><p>假如客户端第一次发送SYN报文后宕机且网络阻塞，客户端重启之后会重新发送SYN报文。<strong>如果不是三次握手</strong>，服务端在接收到SYN报文之后进入established状态并开始发送数据，而客户端接受到数据之后比较ACK序列号发现不是自己期望的ACK（重启之后发送的SYN的响应ACK）就会发送RST报文断开连接。</p><p>断开之后，服务端接受到新的SYN报文重新进入established状态，发送数据和ACK，客户端比较后确认并进入established状态，此时建立连接。</p><p>这种情况，第一次的尝试连接白白发送的数据，浪费了资源！！！</p><p>因此，<strong>要解决这种现象，最好就是在服务端发送数据前，也就是建立连接之前，要阻止掉历史连接，这样就不会造成资源浪费，而要实现这个功能，就需要三次握手</strong>。（在第二次的时候服务端不会发送数据，而是发送ACK）</p><p>所以，<strong>TCP 使用三次握手建立连接的最主要原因是防止「历史连接」初始化了连接</strong></p></li></ol><p><img src="/iamges/%E7%BD%91%E7%BB%9C/1.png" alt="img"></p><ol start="2"><li><p>同步双方初始序列号</p><p>TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：</p><ul><li>接收方可以去除重复的数据；</li><li>接收方可以根据数据包的序列号按序接收；</li><li>可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）</li></ul><p>当客户端发送携带「初始序列号」的 <code>SYN</code> 报文的时候，需要服务端回一个 <code>ACK</code> 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，<strong>这样一来一回，才能确保双方的初始序列号能被可靠的同步。</strong></p></li></ol><p><img src="/iamges/%E7%BD%91%E7%BB%9C/2.png" alt="img"></p><ol start="3"><li><p>避免资源浪费</p><p>和1差不多，在网络阻塞的时候会建立多次尝试的连接并发送数据，导致资源浪费</p></li></ol><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><pre><code>1. 客户端发送FIN报文，进入fin_wait_1状态，不再发送数据（双方都可以主动关闭，不一定是客户端）1. 服务端接受到FIN报文，发送ACK报文确认，进入close_wait状态，继续发送剩下还没发送完的数据1. 客户端接收到ACK报文后进入fin_wait_2状态1. 服务端发送完数据后，发送FIN报文至客户端，进入last_ack状态1. 客户端接收到FIN报文回一个ACK报文，进入time_wait状态1. 服务端接受到后ACK后断开和客户端连接1. 客户端经过2msl后断开服务端连接。</code></pre><p><img src="/iamges/%E7%BD%91%E7%BB%9C/3.png" alt="img"></p><h2 id="之所以四次原因"><a href="#之所以四次原因" class="headerlink" title="之所以四次原因"></a>之所以四次原因</h2><p>确保服务端与客户端之间发送的数据能全部传输完</p><h2 id="连接涉及的状态大概有哪些？"><a href="#连接涉及的状态大概有哪些？" class="headerlink" title="连接涉及的状态大概有哪些？"></a>连接涉及的状态大概有哪些？</h2><ul><li>syn_sent</li><li>syn_rcvd</li><li>established</li><li>time_wait</li><li>close_wait</li></ul><h2 id="linux中查看某状态的列表"><a href="#linux中查看某状态的列表" class="headerlink" title="linux中查看某状态的列表"></a>linux中查看某状态的列表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -anp|grep ESTABLISHED</span><br></pre></td></tr></table></figure><h2 id="TIME-WAIT状态过多可能原因"><a href="#TIME-WAIT状态过多可能原因" class="headerlink" title="TIME_WAIT状态过多可能原因"></a>TIME_WAIT状态过多可能原因</h2><p>高并发下短连接过多，服务端请求处理完就进入正常挥手</p><p>解决思路：</p><p>​使用负载均衡器，服务器会先关闭来自负载均衡器的连接</p><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="http和https区别"><a href="#http和https区别" class="headerlink" title="http和https区别"></a>http和https区别</h3><table><thead><tr><th>HTTP</th><th>HTTPS</th></tr></thead><tbody><tr><td>默认端口80</td><td>HTTPS默认使用端口443</td></tr><tr><td>明文传输、数据未加密、安全性差</td><td>传输过程ssl加密、安全性较好</td></tr><tr><td>响应速度快、消耗资源少</td><td>响应速度较慢、消耗资源多、需要用到CA证书</td></tr></tbody></table><h3 id="常见响应码"><a href="#常见响应码" class="headerlink" title="常见响应码"></a>常见响应码</h3><ul><li>100：Continue — 继续。客户端应继续其请求。</li><li>200：OK — 请求成功。一般用于GET与POST请求。</li><li>301：Moved Permanently — 永久重定向。</li><li>302：Found — 暂时重定向。</li><li>400：Bad Request — 客户端请求的语法错误，服务器无法理解。</li><li>403：Forbideen — 服务器理解请求客户端的请求，但是拒绝执行此请求。</li><li>404：Not Found — 服务器无法根据客户端的请求找到资源（网页）。</li><li>500：Internal Server Error — 服务器内部错误，无法完成请求。</li><li>502：Bad Gateway — 作为网关或者代理服务器尝试执行请求时，从远程服务器接收到了无效的响应。</li></ul><h3 id="cookie和session区别"><a href="#cookie和session区别" class="headerlink" title="cookie和session区别"></a>cookie和session区别</h3><ul><li>保存位置：cookie在客户端，session在服务端</li><li>安全性：cookie不安全，session安全</li><li>作用：cookie一般用来保存用户信息，session主要作⽤就是通过服务端记录⽤户的状态</li></ul><h3 id="浏览器输入URL过程"><a href="#浏览器输入URL过程" class="headerlink" title="浏览器输入URL过程"></a>浏览器输入URL过程</h3><p> **过程：**DNS解析、TCP连接、发送HTTP请求、服务器处理请求并返回HTTP报文、浏览器渲染、结束</p><table><thead><tr><th>过程</th><th>使用的协议</th></tr></thead><tbody><tr><td>1、浏览器查找域名DNS的IP地址 DNS查找过程（浏览器缓存、路由器缓存、DNS缓存）</td><td>DNS：获取域名对应的ip</td></tr><tr><td>2、根据ip建立TCP连接</td><td>TCP：与服务器建立连接</td></tr><tr><td>3、浏览器向服务器发送HTTP请求</td><td>HTTP：发送请求</td></tr><tr><td>4、服务器响应HTTP响应</td><td>HTTP</td></tr><tr><td>5、浏览器进行渲染</td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2022/10/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/10/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><span id="more"></span><h2 id="死锁需要满足的条件"><a href="#死锁需要满足的条件" class="headerlink" title="死锁需要满足的条件"></a>死锁需要满足的条件</h2><ol><li>互斥：资源使用必须互斥，多个进程不能同时使用</li><li>循环等待：请求资源的进程都在等待上一个进程占用的资源，形成一个回环</li><li>非剥夺：进程已获得的资源在完成操作时不可以被剥夺，需要进程自己主动释放</li><li>请求与保持：进程获得资源后，又对其他资源进程请求并且不释放自己已经获得的资源</li></ol><h2 id="解除死锁的方法"><a href="#解除死锁的方法" class="headerlink" title="解除死锁的方法"></a>解除死锁的方法</h2><p>破环满足的任一条件，如：</p><ul><li><strong>乐观锁</strong>，破坏互斥条件（请求资源时不会对资源进行上锁）</li><li>剥夺资源，即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件，<strong>数据库deadlock超时</strong></li><li>资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，从而破坏环路等待的条件，<strong>转账场景</strong></li><li>资源一次性分配，从而剥夺请求和保持条件、<strong>tryLock</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础</title>
      <link href="/2022/09/01/redis/"/>
      <url>/2022/09/01/redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis篇"><a href="#Redis篇" class="headerlink" title="Redis篇"></a><strong>Redis篇</strong></h1><span id="more"></span><h2 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h2><p>Redis是一款内存高速缓存数据库。Redis全称为：<strong>Remote Dictionary Server</strong>（远程数据服务），使用C语言编写，Redis是一个key-value存储系统（键值存储系统），支持丰富的数据类型，如：String、list、set、zset、hash。</p><p>Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。</p><h2 id="WhyRedis"><a href="#WhyRedis" class="headerlink" title="WhyRedis"></a>WhyRedis</h2><blockquote><p>一个产品的使用场景肯定是需要根据产品的特性，先列举一下Redis的特点：</p></blockquote><ul><li>读写性能优异<ul><li>Redis能读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s （测试条件见下一节）。</li></ul></li><li>数据类型丰富<ul><li>Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li></ul></li><li>原子性<ul><li>Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</li></ul></li><li>丰富的特性<ul><li>Redis支持 publish&#x2F;subscribe, 通知, key 过期等特性。</li></ul></li><li>持久化<ul><li>Redis支持RDB, AOF等持久化方式</li></ul></li><li>发布订阅<ul><li>Redis支持发布&#x2F;订阅模式</li></ul></li><li>分布式<ul><li>Redis Cluste</li></ul></li></ul><p> 总结：速度快，完全基于内存，使用C语言实现，网络层使用epoll解决高并发问题，单线程模型避免了不必要的上下文切换及竞争条件；</p><p>其他类型产品：</p><table><thead><tr><th></th><th>GuavaCache</th><th>Tair</th><th>EVCache</th><th>Aerospike</th></tr></thead><tbody><tr><td>类别</td><td>本地JVM缓存</td><td>分布式缓存</td><td>分布式缓存</td><td>分布式nosql数据库</td></tr><tr><td>应用</td><td>本地缓存</td><td>淘宝</td><td>Netflix、AWS</td><td>广告</td></tr><tr><td>性能</td><td>非常高</td><td>较高</td><td>很高</td><td>较高</td></tr><tr><td>持久化</td><td>无</td><td>有</td><td>有</td><td>有</td></tr><tr><td>集群</td><td>无</td><td>灵活配置</td><td>有</td><td>自动扩容</td></tr></tbody></table><p> 与传统数据库不同的是 Redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。另外，Redis 也经常用来做分布式锁。除此之外，Redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。</p><p>不同产品的介绍：</p><h4 id="1、redis"><a href="#1、redis" class="headerlink" title="1、redis"></a>1、redis</h4><p> 1）完全基于内存，绝大部分请求是纯粹的内存操作。数据存在内存中，类似于 HashMap，查找和操作的时间复杂度都是O(1)；</p><p> 2）数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；</p><p> 3）采用<strong>单线程</strong>，避免了多线程不必要的上下文切换和竞争条件，不存在加锁释放锁操作，减少了因为锁竞争导致的性能消耗；（6.0以后多线程）</p><p> 4）使用EPOLL多路 I&#x2F;O 复用模型，非阻塞 IO；</p><p> 5）使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p><h4 id="Redis的使用场景"><a href="#Redis的使用场景" class="headerlink" title="Redis的使用场景"></a>Redis的使用场景</h4><blockquote><p>redis应用场景总结redis平时我们用到的地方蛮多的，下面就了解的应用场景做个总结：</p></blockquote><h5 id="热点数据的缓存"><a href="#热点数据的缓存" class="headerlink" title="# 热点数据的缓存"></a><a href="#%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BC%93%E5%AD%98">#</a> 热点数据的缓存</h5><p>缓存是Redis最常见的应用场景，之所有这么使用，主要是因为Redis读写性能优异。而且逐渐有取代memcached，成为首选服务端缓存的组件。而且，Redis内部是支持事务的，在使用时候能有效保证数据的一致性。</p><p>作为缓存使用时，一般有两种方式保存数据：</p><ul><li>读取前，先去读Redis，如果没有数据，读取数据库，将数据拉入Redis。</li><li>插入数据时，同时写入Redis。</li></ul><p>方案一：实施起来简单，但是有两个需要注意的地方：</p><ul><li>避免缓存击穿。（数据库没有就需要命中的数据，导致Redis一直没有数据，而一直命中数据库。）</li><li>数据的实时性相对会差一点。</li></ul><p>方案二：数据实时性强，但是开发时不便于统一处理。</p><p>当然，两种方式根据实际情况来适用。如：方案一适用于对于数据实时性要求不是特别高的场景。方案二适用于字典表、数据量不大的数据存储。</p><h5 id="限时业务的运用"><a href="#限时业务的运用" class="headerlink" title="# 限时业务的运用"></a><a href="#%E9%99%90%E6%97%B6%E4%B8%9A%E5%8A%A1%E7%9A%84%E8%BF%90%E7%94%A8">#</a> 限时业务的运用</h5><p>redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。</p><h5 id="计数器相关问题"><a href="#计数器相关问题" class="headerlink" title="# 计数器相关问题"></a><a href="#%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98">#</a> 计数器相关问题</h5><p>redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。</p><h5 id="分布式锁"><a href="#分布式锁" class="headerlink" title="# 分布式锁"></a><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">#</a> 分布式锁</h5><p>这个主要利用redis的setnx命令进行，setnx：”set if not exists”就是如果不存在则成功设置缓存同时返回1，否则返回0 ，这个特性在很多后台中都有所运用，因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先 通过setnx设置一个lock， 如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。</p><p>在分布式锁的场景中，主要用在比如秒杀系统等。</p><h5 id="延时操作"><a href="#延时操作" class="headerlink" title="# 延时操作"></a><a href="#%E5%BB%B6%E6%97%B6%E6%93%8D%E4%BD%9C">#</a> 延时操作</h5><p>比如在订单生产后我们占用了库存，10分钟后去检验用户是否真正购买，如果没有购买将该单据设置无效，同时还原库存。 由于redis自2.8.0之后版本提供Keyspace Notifications功能，允许客户订阅Pub&#x2F;Sub频道，以便以某种方式接收影响Redis数据集的事件。 所以我们对于上面的需求就可以用以下解决方案，我们在订单生产时，设置一个key，同时设置10分钟后过期， 我们在后台实现一个监听器，监听key的实效，监听到key失效时将后续逻辑加上。</p><p>当然我们也可以利用rabbitmq、activemq等消息中间件的延迟队列服务实现该需求。</p><h5 id="排行榜相关问题"><a href="#排行榜相关问题" class="headerlink" title="# 排行榜相关问题"></a><a href="#%E6%8E%92%E8%A1%8C%E6%A6%9C%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98">#</a> 排行榜相关问题</h5><p>关系型数据库在排行榜方面查询速度普遍偏慢，所以可以借助redis的SortedSet进行热点数据的排序。</p><p>比如点赞排行榜，做一个SortedSet, 然后以用户的openid作为上面的username, 以用户的点赞数作为上面的score, 然后针对每个用户做一个hash, 通过zrangebyscore就可以按照点赞数获取排行榜，然后再根据username获取用户的hash信息，这个当时在实际运用中性能体验也蛮不错的。</p><h5 id="点赞、好友等相互关系的存储"><a href="#点赞、好友等相互关系的存储" class="headerlink" title="# 点赞、好友等相互关系的存储"></a><a href="#%E7%82%B9%E8%B5%9E%E3%80%81%E5%A5%BD%E5%8F%8B%E7%AD%89%E7%9B%B8%E4%BA%92%E5%85%B3%E7%B3%BB%E7%9A%84%E5%AD%98%E5%82%A8">#</a> 点赞、好友等相互关系的存储</h5><p>Redis 利用集合的一些命令，比如求交集、并集、差集等。</p><p>在微博应用中，每个用户关注的人存在一个集合中，就很容易实现求两个人的共同好友功能。</p><h5 id="简单队列"><a href="#简单队列" class="headerlink" title="# 简单队列"></a><a href="#%E7%AE%80%E5%8D%95%E9%98%9F%E5%88%97">#</a> 简单队列</h5><p>由于Redis有list push和list pop这样的命令，所以能够很方便的执行队列操作。</p><h4 id="2、Memcache"><a href="#2、Memcache" class="headerlink" title="2、Memcache"></a>2、Memcache</h4><table><thead><tr><th>redis</th><th>Memcached</th></tr></thead><tbody><tr><td>内存高速数据库</td><td>高性能分布式内存缓存数据库</td></tr><tr><td>支持hash、list、set、zset、string结构</td><td>只支持key-value结构</td></tr><tr><td>将大部分数据放到内存</td><td>全部数据放到内存中</td></tr><tr><td>支持持久化、主从复制备份</td><td>不支持数据持久化及数据备份</td></tr><tr><td>数据丢失可通过AOF恢复</td><td>挂掉后，数据不可恢复</td></tr><tr><td>单线程（2~4万TPS）</td><td>多线程（20-40万TPS）</td></tr></tbody></table><h5 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a><strong>使用场景：</strong></h5><p> 1、如果有持久方面的需求或对数据类型和处理有要求的应该选择redis。</p><p> 2、如果简单的key&#x2F;value 存储应该选择memcached。</p><h4 id="3、Tair"><a href="#3、Tair" class="headerlink" title="3、Tair"></a>3、Tair</h4><p> Tair(Taobao Pair)是淘宝开发的分布式Key-Value存储引擎，既可以做缓存也可以做数据源（三种引擎切换）</p><ul><li>MDB（Memcache）属于内存型产品,支持kv和类hashMap结构,性能最优</li><li>RDB（Redis）支持List.Set.Zset等复杂的数据结构,性能次之,可提供缓存和持久化存储两种模式</li><li>LDB（levelDB）属于持久化产品,支持kv和类hashmap结构,性能较前两者稍低,但持久化可靠性最高</li></ul><p><strong>分布式缓存</strong></p><p>大访问少量临时数据的存储（kb左右）</p><p>用于缓存，降低对后端数据库的访问压力</p><p>session场景</p><p>高速访问某些数据结构的应用和计算（rdb）</p><p><strong>数据源存储</strong></p><p>快速读取数据（fdb）</p><p>持续大数据量的存入读取（ldb），交易快照</p><p>高频度的更新读取（ldb），库存</p><p><strong>痛点</strong>：redis集群中，想借用缓存资源必须得指明redis服务器地址去要。这就增加了程序的维护复杂度。因为redis服务器很可能是需要频繁变动的。所以人家淘宝就想啊，为什么不能像操作分布式数据库或者hadoop那样。增加一个中央节点，让他去代理所有事情。在tair中程序只要跟tair中心节点交互就OK了。同时tair里还有配置服务器概念。又免去了像操作hadoop那样，还得每台hadoop一套一模一样配置文件。改配置文件得整个集群都跟着改。</p><h4 id="4、Guava"><a href="#4、Guava" class="headerlink" title="4、Guava"></a>4、Guava</h4><p> 分布式缓存一致性更好一点，用于集群环境下多节点使用同一份缓存的情况；有网络IO，吞吐率与缓存的数据大小有较大关系；</p><p> 本地缓存非常高效，本地缓存会占用堆内存，影响垃圾回收、影响系统性能。</p><p><strong>本地缓存设计：</strong></p><p> 以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况，每个实例都需要各自保存一份缓存，缓存不具有一致性。</p><p><strong>解决缓存过期：</strong></p><p> 1、将缓存过期时间调为永久</p><p> 2、将缓存失效时间分散开，不要将缓存时间长度都设置成一样；比如我们可以在原有的失效时间基础上增加一个随机值，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p><p><strong>解决内存溢出：</strong></p><p> <strong>第一步</strong>，修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)</p><p>　<strong>第二步</strong>，检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。</p><p>　<strong>第三步</strong>，对代码进行走查和分析，找出可能发生内存溢出的位置。</p><p><strong>Google Guava Cache</strong></p><p><strong>自己设计本地缓存痛点：</strong></p><ul><li>不能按照一定的规则淘汰数据，如 LRU，LFU，FIFO 等。</li><li>清除数据时的回调通知</li><li>并发处理能力差，针对并发可以使用CurrentHashMap，但缓存的其他功能需要自行实现</li><li>缓存过期处理，缓存数据加载刷新等都需要手工实现</li></ul><p><strong>Guava Cache 的场景：</strong></p><ul><li>对性能有非常高的要求</li><li>不经常变化，占用内存不大</li><li>有访问整个集合的需求</li><li>数据允许不实时一致</li></ul><p><strong>Guava Cache 的优势</strong>：</p><ul><li>缓存过期和淘汰机制</li></ul><p>在GuavaCache中可以设置Key的过期时间，包括访问过期和创建过期。GuavaCache在缓存容量达到指定大小时，采用LRU的方式，将不常使用的键值从Cache中删除</p><ul><li>并发处理能力</li></ul><p>GuavaCache类似CurrentHashMap，是线程安全的。提供了设置并发级别的api，使得缓存支持并发的写入和读取，采用分离锁机制，分离锁能够减小锁力度，提升并发能力，分离锁是分拆锁定，把一个集合看分成若干partition, 每个partiton一把锁。更新锁定</p><ul><li>防止缓存击穿</li></ul><p>一般情况下，在缓存中查询某个key，如果不存在，则查源数据，并回填缓存。（Cache Aside Pattern）在高并发下会出现，多次查源并重复回填缓存，可能会造成源的宕机（DB），性能下降 GuavaCache可以在CacheLoader的load方法中加以控制，对同一个key，只让一个请求去读源并回填缓存，其他请求阻塞等待。（相当于集成数据源，方便用户使用）</p><ul><li>监控缓存加载&#x2F;命中情况</li></ul><p>统计</p><p><strong>问题：</strong></p><p> OOM-&gt;设置过期时间、使用弱引用、配置过期策略</p><h4 id="5、EVCache"><a href="#5、EVCache" class="headerlink" title="5、EVCache"></a>5、EVCache</h4><p>EVCache是一个Netflflix（网飞）公司开源、快速的分布式缓存，是基于Memcached的内存存储实现的，用以构建超大容量、高性能、低延时、跨区域的全球可用的缓存数据层。</p><p>E：Ephemeral：数据存储是短暂的，有自身的存活时间</p><p>V：Volatile：数据可以在任何时候消失</p><p>EVCache典型地适合对强一致性没有必须要求的场合</p><p>典型用例：Netflflix向用户推荐用户感兴趣的电影</p><p><a href="https://camo.githubusercontent.com/0c8bd20c483867b2013cffe847fa944fd85ffe5c3191156b9c52fd0129773fe6/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676d6170646e683079616a33306b75306169676d632e6a7067"><img src="https://camo.githubusercontent.com/0c8bd20c483867b2013cffe847fa944fd85ffe5c3191156b9c52fd0129773fe6/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676d6170646e683079616a33306b75306169676d632e6a7067" alt="image-20210103185340548"></a></p><p><strong>EVCache集群</strong>在峰值每秒可以处理<strong>200kb</strong>的请求，</p><p>Netflflix生产系统中部署的EVCache经常要处理超过<strong>每秒3000万个</strong>请求，存储数十亿个对象，</p><p>跨数千台memcached服务器。整个EVCache集群<strong>每天处理近2万亿个</strong>请求。</p><p>EVCache集群响应平均延时大约是1-5毫秒，最多不会超过20毫秒。</p><p>EVCache集群的缓存命中率在99%左右。</p><p><strong>典型部署</strong></p><p>EVCache 是线性扩展的，可以在一分钟之内完成扩容，在几分钟之内完成负载均衡和缓存预热。</p><p><a href="https://camo.githubusercontent.com/33102298c3f3d5abe4f00c8e7f176d490a90620fea4a51a9058ee62fe3a47d8b/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676d617067393971386c6a333069783066336a72772e6a7067"><img src="https://camo.githubusercontent.com/33102298c3f3d5abe4f00c8e7f176d490a90620fea4a51a9058ee62fe3a47d8b/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676d617067393971386c6a333069783066336a72772e6a7067" alt="image-20210103185611516"></a></p><p>1、集群启动时，EVCache向服务注册中心（Zookeeper、Eureka）注册各个实例</p><p>2、在web应用启动时，查询命名服务中的EVCache服务器列表，并建立连接。</p><p>3、客户端通过key使用一致性hash算法，将数据分片到集群上。</p><h4 id="6、ETCD"><a href="#6、ETCD" class="headerlink" title="6、ETCD"></a>6、ETCD</h4><p> <strong>和Zookeeper一样，CP模型追求数据一致性，越来越多的系统开始用它保存关键数据。比如，秒杀系统经常用它保存各节点信</strong>息，以便控制消费 MQ 的服务数量。还有些业务系统的<strong>配置数据</strong>，也会通过 etcd 实时同步给业务系统的各节点，比如，秒杀管理后台会使用 etcd 将秒杀活动的<strong>配置数据实时同步给秒杀 API 服务各节点</strong>。</p><p><a href="https://camo.githubusercontent.com/b4c59c1cbe5f5ae99de66c57b6f60219e98726f7fc941f47271cb0356f2a0a37/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f3030386933736b4e6c7931677832746739717330306a333074613067343076632e6a7067"><img src="https://camo.githubusercontent.com/b4c59c1cbe5f5ae99de66c57b6f60219e98726f7fc941f47271cb0356f2a0a37/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f3030386933736b4e6c7931677832746739717330306a333074613067343076632e6a7067" alt="image-20210418174251742"></a></p><h3 id="Redis底层"><a href="#Redis底层" class="headerlink" title="Redis底层"></a>Redis底层</h3><p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20240702224859420.png" alt="image-20240702224859420"></p><h4 id="1、redis数据类型"><a href="#1、redis数据类型" class="headerlink" title="1、redis数据类型"></a>1、redis数据类型</h4><p>五种基本数据类型</p><p><a href="https://pdai.tech/md/db/nosql-redis/db-redis-data-types.html">https://pdai.tech/md/db/nosql-redis/db-redis-data-types.html</a></p><table><thead><tr><th>类型</th><th>底层</th><th>应用场景</th><th>编码类型</th></tr></thead><tbody><tr><td>String</td><td>SDS数组</td><td>帖子、评论、热点数据、输入缓冲</td><td>RAW &lt;&lt; EMBSTR &lt;&lt; INT</td></tr><tr><td>List</td><td>QuickList</td><td>评论列表、商品列表、发布与订阅、慢查询、监视器</td><td>LINKEDLIST &lt;&lt; ZIPLIST</td></tr><tr><td>Set</td><td>intSet</td><td>适合交集、并集、查集操作，例如朋友关系</td><td>HT &lt;&lt; INSET</td></tr><tr><td>Zset</td><td>跳跃表</td><td>去重后排序，适合排名场景</td><td>SKIPLIST &lt;&lt; ZIPLIST</td></tr><tr><td>Hash</td><td>哈希</td><td>结构化数据，比如存储对象</td><td>HT &lt;&lt; ZIPLIST</td></tr><tr><td>Stream</td><td>紧凑列表</td><td>消息队列</td><td></td></tr></tbody></table><h4 id="2、相关API"><a href="#2、相关API" class="headerlink" title="2、相关API"></a><strong>2、相关API</strong></h4><blockquote><p><a href="http://redisdoc.com/">http://redisdoc.com</a></p></blockquote><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>String</td><td>SET</td><td>SETNX</td><td>SETEX</td><td>GET</td><td>GETSET</td><td>INCR</td><td>DECR</td><td>MSET</td><td>MGET</td></tr><tr><td>Hash</td><td>HSET</td><td>HSETNX</td><td>HGET</td><td>HDEL</td><td>HLEN</td><td>HMSET</td><td>HMGET</td><td>HKEYS</td><td>HGETALL</td></tr><tr><td>LIST</td><td>LPUSH</td><td>LPOP</td><td>RPUSH</td><td>RPOP</td><td>LINDEX</td><td>LREM</td><td>LRANGE</td><td>LLEN</td><td>RPOPLPUSH</td></tr><tr><td>ZSET</td><td>ZADD</td><td>ZREM</td><td>ZSCORE</td><td>ZCARD</td><td>ZRANGE</td><td>ZRANK</td><td>ZREVRANK</td><td></td><td>ZREVRANGE</td></tr><tr><td>SET</td><td>SADD</td><td>SREM</td><td>SISMEMBER</td><td>SCARD</td><td>SINTER</td><td>SUNION</td><td>SDIFF</td><td>SPOP</td><td>SMEMBERS</td></tr><tr><td>事务</td><td>MULTI</td><td>EXEC</td><td>DISCARD</td><td>WATCH</td><td>UNWATCH</td><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="3、redis各个类型的底层结构"><a href="#3、redis各个类型的底层结构" class="headerlink" title="3、redis各个类型的底层结构"></a>3、redis各个类型的底层结构</h4><p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20240703203721396.png" alt="image-20240703203721396"></p><h5 id="1-String（字符串）"><a href="#1-String（字符串）" class="headerlink" title="1. String（字符串）"></a>1. String（字符串）</h5><ul><li>简单动态字符串（SDS）<ul><li>当字符串比较短时，Redis 使用 SDS 结构来存储。SDS 是 Redis 自定义的一种字符串类型，支持高效的字符串操作。</li><li>SDS 结构包含了实际的字符串数据、已用空间长度、总空间长度，以及额外的未使用空间，用于减少内存分配次数和频繁的内存复制。</li></ul></li><li>整数编码（int）<ul><li>当字符串表示的是一个整数，并且在特定范围内时，Redis 会使用整数编码来存储该字符串，以节省内存。</li></ul></li></ul><h5 id="2-List（列表）"><a href="#2-List（列表）" class="headerlink" title="2. List（列表）"></a>2. List（列表）</h5><ul><li><strong>压缩列表（Ziplist）</strong>：<ul><li>当列表元素数量较少且每个元素的长度都较小时，Redis 使用压缩列表。压缩列表是一种连续内存块，紧凑地存储多个元素，节省内存空间。</li></ul></li><li><strong>双向链表（Linked List）</strong>：<ul><li>当列表元素数量较多或者元素较大时，Redis 使用双向链表。这种结构支持高效的插入和删除操作，但占用的内存较多。</li></ul></li><li><strong>快速列表（Quicklist）</strong>：<ul><li>Redis 4.0 引入了一种混合数据结构，结合了压缩列表和双向链表的优点。Quicklist 是由多个小的压缩列表组成的双向链表，既节省内存又保持了操作的高效性。</li></ul></li></ul><h5 id="3-Hash（哈希表）"><a href="#3-Hash（哈希表）" class="headerlink" title="3. Hash（哈希表）"></a>3. Hash（哈希表）</h5><ul><li><strong>压缩列表（Ziplist）</strong>：<ul><li>当哈希表中的键值对数量较少，且每个键和值都较短时，使用压缩列表来存储。</li></ul></li><li><strong>哈希表（Hashtable）</strong>：<ul><li>当哈希表中的键值对数量较多或者某些键和值较长时，使用哈希表结构。哈希表使用链地址法解决冲突，提供 O(1) 时间复杂度的查找、插入和删除操作。</li></ul></li></ul><h5 id="4-Set（集合）"><a href="#4-Set（集合）" class="headerlink" title="4. Set（集合）"></a>4. Set（集合）</h5><ul><li><strong>整数集合（Intset）</strong>：<ul><li>当集合中的元素都是整数且数量较少时，Redis 使用整数集合存储。整数集合是一种有序且不重复的整数数组。</li></ul></li><li><strong>哈希表（Hashtable）</strong>：<ul><li>当集合中的元素较多或者包含非整数元素时，使用哈希表结构存储。哈希表提供 O(1) 时间复杂度的查找、插入和删除操作。</li></ul></li></ul><h5 id="5-Sorted-Set（有序集合）"><a href="#5-Sorted-Set（有序集合）" class="headerlink" title="5. Sorted Set（有序集合）"></a>5. Sorted Set（有序集合）</h5><ul><li><strong>压缩列表（Ziplist）</strong>：<ul><li>当有序集合中的元素数量较少，并且每个元素的长度较短时，使用压缩列表存储。</li></ul></li><li><strong>跳跃表和哈希表（Skip List and Hashtable）</strong>：<ul><li>当有序集合中的元素较多或者元素较大时，使用跳跃表和哈希表相结合的方式存储。跳跃表用于维持元素的有序性，提供范围查询功能；哈希表用于快速查找元素分值（score），提高操作效率。</li></ul></li></ul><h5 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h5><p><strong>Redis Stream</strong>的底层主要使用了listpack(紧凑列表)和Rax树(基数树)。</p><p> <strong>listpack</strong>表示一个字符串列表的序列化，listpack可用于存储字符串或整数。用于存储stream的消息内 容。</p><p> <strong>Rax树</strong>是一个有序字典树 (基数树 Radix Tree)，按照 key 的字典序排列，支持快速地定位、插入和删除操 作。</p><h4 id="4、Zset底层实现"><a href="#4、Zset底层实现" class="headerlink" title="4、Zset底层实现"></a>4、Zset底层实现</h4><p> 跳表(skip List)是一种随机化的数据结构，基于并联的链表，实现简单，插入、删除、查找的复杂度均为O(logN)。简单说来跳表也是链表的一种，只不过它在链表的基础上增加了跳跃功能，正是这个跳跃的功能，使得在查找元素时，跳表能够提供O(logN)的时间复杂度</p><p> Zset<strong>数据量少的时候使用压缩链表ziplist</strong>实现，有序集合使用紧挨在一起的压缩列表节点来保存，第一个节点保存member，第二个保存score。ziplist内的集合元素按score从小到大排序，score较小的排在表头位置。 <strong>数据量大的时候使用跳跃列表skiplist和哈希表hash_map</strong>结合实现，查找删除插入的时间复杂度都是O(longN)</p><p> Redis使用跳表而不使用红黑树，是因为跳表的索引结构序列化和反序列化更加快速，方便持久化。</p><p><strong>搜索</strong></p><p> 跳跃表按 score 从小到大保存所有集合元素，查找时间复杂度为平均 <em>O(logN)，最坏 O(N) 。</em></p><p><strong>插入</strong></p><p>  选用链表作为底层结构支持，为了高效地动态增删。因为跳表底层的单链表是有序的，为了维护这种有序性，在插入前需要遍历链表，找到该插入的位置，单链表遍历查找的时间复杂度是O(n)，同理可得，跳表的遍历也是需要遍历索引数，所以是O(logn)。</p><p><strong>删除</strong></p><p>  如果该节点还在索引中，删除时不仅要删除单链表中的节点，还要删除索引中的节点；单链表在知道删除的节点是谁时，时间复杂度为O(1)，但针对单链表来说，删除时都需要拿到前驱节点O(logN)才可改变引用关系从而删除目标节点。</p><h3 id="Redis可用性"><a href="#Redis可用性" class="headerlink" title="Redis可用性"></a><strong>Redis可用性</strong></h3><h4 id="1、redis持久化"><a href="#1、redis持久化" class="headerlink" title="1、redis持久化"></a>1、redis持久化</h4><p>持久化就是把内存中的数据持久化到本地磁盘，防止服务器宕机了内存数据丢失</p><p>Redis 提供两种持久化机制 <strong>RDB（默认）</strong> 和 <strong>AOF 机制</strong>，Redis4.0以后采用混合持久化，用 AOF 来<strong>保证数据不丢失</strong>，作为数据恢复的第一选择; 用 RDB 来做不同程度的<strong>冷备</strong></p><p>**RDB：**是Redis DataBase缩写快照</p><p> RDB是Redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。</p><p> <strong>优点：</strong></p><p> 1）只有一个文件 dump.rdb，方便持久化；</p><p> 2）容灾性好，一个文件可以保存到安全的磁盘。</p><p> 3）性能最大化，fork 子进程来进行持久化写操作，让主进程继续处理命令，只存在毫秒级不响应请求。</p><p> 4）相对于数据集大时，比 AOF 的启动效率更高。</p><p> <strong>缺点：</strong></p><p> 数据安全性低，RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。</p><p><strong>AOF：持久化</strong></p><p> AOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。</p><p> <strong>优点：</strong></p><p> 1）数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。</p><p> 2）通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</p><p><strong>缺点：</strong></p><p> 1）AOF 文件比 RDB 文件大，且恢复速度慢。</p><p> 2）数据集大的时候，比 rdb 启动效率低。</p><h4 id="2、redis事务"><a href="#2、redis事务" class="headerlink" title="2、redis事务"></a>2、redis事务</h4><p> 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p><p><strong>Redis事务的概念</strong></p><p> Redis 事务的本质是通过MULTI、EXEC、WATCH等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p><p>Redis的事务总是具有ACID中的<strong>一致性和隔离性</strong>，其他特性是不支持的。当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性。</p><p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的</p><p><strong>事务命令：</strong></p><p>**MULTI：**用于开启一个事务，它总是返回OK。MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。</p><p>**EXEC：**执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值 nil 。</p><p>**WATCH ：**是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。（<strong>秒杀场景</strong>）</p><p>**DISCARD：**调用该命令，客户端可以清空事务队列，并放弃执行事务，且客户端会从事务状态中退出。</p><p><strong>UNWATCH</strong>：命令可以取消watch对所有key的监控。</p><p><strong>问题：</strong></p><p><strong>redis是单线程的，本身不就是有事务吗，为什么还需要借助这些原语呢</strong>？</p><p>​Redis 确实是单线程的，这意味着<strong>每个</strong>命令都是原子性的（atomic）。但是，Redis 的事务机制 (<code>MULTI</code> 和 <code>EXEC</code>) 提供了对<strong>一组</strong>命令进行原子操作的能力，使得它们在执行时不会被其他命令插入和打断。</p><h4 id="3、redis失效策略"><a href="#3、redis失效策略" class="headerlink" title="3、redis失效策略"></a>3、redis失效策略</h4><p><strong>内存淘汰策略</strong></p><p>1）全局的键空间选择性移除</p><p> <strong>noeviction</strong>：当内存不足以容纳新写入数据时，新写入操作会报错。（字典库常用）默认·</p><p> <strong>allkeys-lru</strong>：在键空间中，移除最近最少使用的key。（缓存常用）</p><p> <strong>allkeys-random</strong>：在键空间中，随机移除某个key。</p><p>2）设置过期时间的键空间选择性移除</p><p> <strong>volatile-lru</strong>：在设置了过期时间的键空间中，移除最近最少使用的key。</p><p> <strong>volatile-random</strong>：在设置了过期时间的键空间中，随机移除某个key。 </p><p> <strong>volatile-ttl</strong>：在设置了过期时间的键空间中，有更早过期时间的key优先移除。</p><p><strong>缓存失效策略</strong></p><p> **定时清除：**针对每个设置过期时间的key都创建指定定时器</p><p> **惰性清除：**访问时判断，对内存不友好</p><p> **定时扫描清除：**定时100ms随机20个检查过期的字典，若存在25%以上则继续循环删除。</p><h4 id="4、redis读写模式"><a href="#4、redis读写模式" class="headerlink" title="4、redis读写模式"></a>4、redis读写模式</h4><p> <strong>CacheAside旁路缓存</strong></p><p>写请求更新数据库后删除缓存数据。读请求不命中查询数据库，查询完成写入缓存</p><p><a href="https://camo.githubusercontent.com/4f6ecd7d5622bcefd365e4401ecd0dea2118de6fc9cc095863b0dd66c7619532/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303830363139343331363533392e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c3278366546393261574e3062334a352c73697a655f31362c636f6c6f725f4646464646462c745f3730"><img src="https://camo.githubusercontent.com/4f6ecd7d5622bcefd365e4401ecd0dea2118de6fc9cc095863b0dd66c7619532/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303830363139343331363533392e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c3278366546393261574e3062334a352c73697a655f31362c636f6c6f725f4646464646462c745f3730" alt="在这里插入图片描述"></a></p><p><a href="https://camo.githubusercontent.com/49b8ac7e090eeca2a3f08c792e57e06bbf8be6d68d52cfdddc1a751fec288956/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303830363139343330303832362e706e67"><img src="https://camo.githubusercontent.com/49b8ac7e090eeca2a3f08c792e57e06bbf8be6d68d52cfdddc1a751fec288956/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303830363139343330303832362e706e67" alt="img"></a></p><p> 业务端处理所有数据访问细节，同时利用 <strong>Lazy 计算</strong>的思想，更新 DB 后，直接删除 cache 并通过 DB 更新，确保数据以 DB 结果为准，则可以大幅降低 cache 和 DB 中数据不一致的概率</p><p> 如果没有专门的存储服务，同时是对<strong>数据一致性要求比较高的业务，或者是缓存数据更新比较复杂的业务</strong>，适合使用 Cache Aside 模式。如微博发展初期，不少业务采用这种模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 延迟双删，用以保证最终一致性,防止小概率旧数据读请求在第一次删除后更新数据库</span><br><span class="line">public void write(String key,Object data)&#123;</span><br><span class="line">redis.delKey(key);</span><br><span class="line">db.updateData(data);</span><br><span class="line">Thread.sleep(1000);</span><br><span class="line">redis.delKey(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>高并发下保证绝对的一致，先删缓存再更新数据，需要用到<strong>内存队列做异步串行化</strong>。非高并发场景，先更新数据再删除缓存，<strong>延迟双删</strong>策略基本满足了</p><ul><li>先更新db后删除redis：删除redis失败则出现问题</li><li>先删redis后更新db：删除redis瞬间，旧数据被回填redis</li><li>先删redis后更新db休眠后删redis：同第二点，休眠后删除redis 可能宕机</li><li>java内部jvm队列：不适用分布式场景且降低并发</li></ul><p> <strong>Read&#x2F;Write Though</strong>（读写穿透）</p><p> <strong>先查询</strong>缓存中数据是否存在,如果存在则直接返回,如果<strong>不存在</strong>,则由<strong>缓存组件负责从数据库中同步加载数据.</strong></p><p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20240704172728882.png" alt="image-20240704172728882"></p><p><strong>场景：</strong></p><p>微博 Feed 的 Outbox Vector（即用户最新微博列表）就采用这种模式。一些粉丝较少且不活跃的用户发表微博后，Vector 服务会首先查询 Vector Cache，如果 cache 中没有该用户的 Outbox 记录，则不写该用户的 cache 数据，直接更新 DB 后就返回，只有 cache 中存在才会通过 CAS 指令进行更新。</p><p><strong>Write Behind Caching（异步缓存写入）</strong></p><p><a href="https://camo.githubusercontent.com/bb84938d32f1558559bd84a76a87191f74665ee11ad6e0f361459c15a155a6d3/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303865476d5a456c7931676f726c7367373469366a333139353065336468732e6a7067"><img src="https://camo.githubusercontent.com/bb84938d32f1558559bd84a76a87191f74665ee11ad6e0f361459c15a155a6d3/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303865476d5a456c7931676f726c7367373469366a333139353065336468732e6a7067" alt="img"></a></p><p>比如对一些计数业务，一条 <strong>Feed 被点赞</strong> 1万 次，如果更新 1万 次 DB 代价很大，而合并成一次请求直接加 1万，则是一个非常轻量的操作。但这种模型有个显著的缺点，即数据的一致性变差，甚至在一些极端场景下可能会丢失数据。</p><h4 id="5、多级缓存"><a href="#5、多级缓存" class="headerlink" title="5、多级缓存"></a>5、多级缓存</h4><p>**浏览器本地内存缓存：**专题活动，一旦上线，在活动期间是不会随意变更的。</p><p>**浏览器本地磁盘缓存：**Logo缓存，大图片懒加载</p><p>**服务端本地内存缓存：**由于没有持久化，重启时必定会被穿透</p><p><strong>服务端网络内存缓存</strong>：Redis等，针对穿透的情况下可以继续分层，必须保证数据库不被压垮</p><p><strong>为什么不是使用服务器本地磁盘做缓存？</strong></p><p> 当系统处理大量磁盘 IO 操作的时候，由于 CPU 和内存的速度远高于磁盘，可能导致 CPU 耗费太多时间等待磁盘返回处理的结果。对于这部分 CPU 在 IO 上的开销，我们称为 <strong>iowait</strong></p><h3 id="Redis七大经典问题"><a href="#Redis七大经典问题" class="headerlink" title="Redis七大经典问题"></a>Redis七大经典问题</h3><h4 id="1、缓存雪崩"><a href="#1、缓存雪崩" class="headerlink" title="1、缓存雪崩"></a>1、缓存雪崩</h4><p> 指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p><p> <strong>解决方案：</strong></p><ul><li><strong>Redis 高可用</strong>，主从+哨兵，Redis cluster，避免全盘崩溃</li><li>本地 ehcache 缓存 + hystrix <strong>限流&amp;降级</strong>，避免 MySQL 被打死</li><li>缓存数据的<strong>过期时间设置随机</strong>，防止同一时间大量数据过期现象发生。</li><li><strong>逻辑上永不过期</strong>给每一个缓存数据增加相应的<strong>缓存标记</strong>，缓存标记失效则更新数据缓存</li><li><strong>多级缓存</strong>，失效时通过二级更新一级，由第三方插件更新二级缓存。</li></ul><h4 id="2、缓存穿透"><a href="#2、缓存穿透" class="headerlink" title="2、缓存穿透"></a><strong>2、缓存穿透</strong></h4><p> <a href="https://blog.csdn.net/lin777lin/article/details/105666839">https://blog.csdn.net/lin777lin/article/details/105666839</a></p><p> 缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p><p> <strong>解决方案：</strong></p><p> 1）<strong>接口层增加校验</strong>，如用户鉴权校验，id做基础校验，id&lt;&#x3D;0的直接拦截；</p><p> 2）从缓存取不到的数据，在数据库中也没有取到，这时也可以将<strong>key-value对写为key-null</strong>，缓存有效时间可以设置短点，如30秒。这样可以防止攻击用户反复用同一个id暴力攻击；</p><p> 3）采用<strong>布隆过滤器</strong>，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。（宁可错杀一千不可放过一人）</p><h4 id="3、缓存击穿"><a href="#3、缓存击穿" class="headerlink" title="3、缓存击穿"></a><strong>3、缓存击穿</strong></h4><p> 这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指<strong>并发查同一条数据</strong>，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库</p><p> <strong>解决方案：</strong></p><p> 1）设置<strong>热点数据永远不过期</strong>，异步线程处理。</p><p> 2）加<strong>写回操作加互斥锁</strong>，查询失败默认值快速返回。</p><p> 3）缓存预热</p><p> 系统上线后，将相关**可预期（例如排行榜）**热点数据直接加载到缓存。</p><p> 写一个缓存刷新页面，手动操作热点数据**（例如广告推广）**上下线。</p><h4 id="4、数据不一致"><a href="#4、数据不一致" class="headerlink" title="4、数据不一致"></a>4、数据不一致</h4><p> 在缓存机器的带宽被打满，或者机房网络出现波动时，缓存更新失败，新数据没有写入缓存，就会导致缓存和 DB 的数据不一致。缓存 rehash 时，某个缓存机器反复异常，多次上下线，更新请求多次 rehash。这样，一份数据存在多个节点，且每次 rehash 只更新某个节点，导致一些缓存节点产生脏数据。</p><ul><li>Cache 更新失败后，可以进行重试，则将重试失败的 key 写入mq，待缓存访问恢复后，将这些 key 从缓存删除。这些 key 在再次被查询时，重新从 DB 加载，从而保证数据的一致性</li><li>缓存时间适当调短，让缓存数据及早过期后，然后从 DB 重新加载，确保数据的最终一致性。</li><li>不采用 rehash 漂移策略，而采用缓存分层策略，尽量避免脏数据产生。</li></ul><h4 id="5、数据并发竞争"><a href="#5、数据并发竞争" class="headerlink" title="5、数据并发竞争"></a>5、数据并发竞争</h4><p> 数据并发竞争在大流量系统也比较常见，比如车票系统，如果某个火车车次缓存信息过期，但仍然有大量用户在查询该车次信息。又比如微博系统中，如果某条微博正好被缓存淘汰，但这条微博仍然有大量的转发、评论、赞。上述情况都会造成并发竞争读取的问题。</p><ul><li>加<strong>写回操作加互斥锁</strong>，查询失败默认值快速返回。</li><li>对缓存数据保持多个备份，减少并发竞争的概率</li></ul><h4 id="6、热点key问题"><a href="#6、热点key问题" class="headerlink" title="6、热点key问题"></a>6、热点key问题</h4><p> 明星结婚、离婚、出轨这种特殊突发事件，比如奥运、春节这些重大活动或节日，还比如秒杀、双12、618 等线上促销活动，都很容易出现 Hot key 的情况。</p><p>如何提前发现HotKey？</p><ul><li>对于重要节假日、线上促销活动这些提前已知的事情，可以提前评估出可能的热 key 来。</li><li>而对于突发事件，无法提前评估，可以<strong>通过 Spark，对应流任务进行实时分析</strong>，及时发现新发布的热点 key。而对于之前已发出的事情，逐步发酵成为热 key 的，则可以通过 Hadoop 对批处理任务离线计算，找出最近历史数据中的高频热 key。</li></ul><p><strong>解决方案：</strong></p><ul><li>这 n 个 key 分散存在多个缓存节点，然后 client 端请求时，随机访问其中某个后缀的 hotkey，这样就可以把热 key 的请求打散，避免一个缓存节点过载</li><li>缓存集群可以单节点进行主从复制和垂直扩容</li><li>利用应用内的前置缓存，但是需注意需要设置上限</li><li>延迟不敏感，定时刷新，实时感知用主动刷新</li><li>和缓存穿透一样，限制逃逸流量，单请求进行数据回源并刷新前置</li><li>无论如何设计，最后都要写一个兜底逻辑，千万级流量说来就来</li></ul><h4 id="7、BigKey问题"><a href="#7、BigKey问题" class="headerlink" title="7、BigKey问题"></a>7、BigKey问题</h4><p> 比如互联网系统中需要保存用户最新 1万 个粉丝的业务，比如一个用户个人信息缓存，包括基本资料、关系图谱计数、发 feed 统计等。微博的 feed 内容缓存也很容易出现，一般用户微博在 140 字以内，但很多用户也会发表 1千 字甚至更长的微博内容，这些长微博也就成了大 key</p><ul><li>首先Redis底层数据结构里，根据Value的不同，会进行数据结构的重新选择</li><li>可以扩展新的数据结构，进行序列化构建，然后通过 restore 一次性写入</li><li>将大 key 分拆为多个 key，设置较长的过期时间</li></ul><h3 id="Redis分区容错"><a href="#Redis分区容错" class="headerlink" title="Redis分区容错"></a>Redis分区容错</h3><h4 id="1、redis数据分区"><a href="#1、redis数据分区" class="headerlink" title="1、redis数据分区"></a><strong>1、redis数据分区</strong></h4><p><strong>Hash：（不稳定）</strong></p><p> 客户端分片：哈希+取余</p><p> 节点伸缩：数据节点关系变化，导致数据迁移</p><p> 迁移数量和添加节点数量有关：建议翻倍扩容</p><p> 一个简单直观的想法是直接用Hash来计算，以Key做哈希后对节点数取模。可以看出，在key足够分散的情况下，均匀性可以获得，但一旦有节点加入或退出，所有的原有节点都会受到影响，稳定性无从谈起。</p><p><strong>一致性Hash：（不均衡）</strong></p><p> 客户端分片：哈希+顺时针（优化取余）</p><p> 节点伸缩：只影响邻近节点，但是还是有数据迁移</p><p> 翻倍伸缩：保证最小迁移数据和负载均衡</p><p> 一致性Hash可以很好的解决稳定问题，可以将所有的存储节点排列在收尾相接的Hash环上，每个key在计算Hash后会顺时针找到先遇到的一组存储节点存放。而当有节点加入或退出时，仅影响该节点在Hash环上顺时针相邻的后续节点，将数据从该节点接收或者给予。但这又带来均匀性的问题，即使可以将存储节点等距排列，也会在<strong>存储节点个数变化时带来数据的不均匀</strong>。</p><p><strong>Codis的Hash槽</strong></p><p> Codis 将所有的 key 默认划分为 1024 个槽位(slot)，它首先对客户端传过来的 key 进行 crc32 运算计算 哈希值，再将 hash 后的整数值对 1024 这个整数进行取模得到一个余数，这个余数就是对应 key 的槽位。</p><p><strong>RedisCluster</strong></p><p> Redis-cluster把所有的物理节点映射到[0-16383]个<strong>slot</strong>上,对key采用crc16算法得到hash值后对16384取模，基本上采用平均分配和连续分配的方式。</p><h4 id="2、主从模式-简单"><a href="#2、主从模式-简单" class="headerlink" title="2、主从模式&#x3D;简单"></a><strong>2、主从模式&#x3D;简单</strong></h4><p> 主从模式最大的优点是<strong>部署简单</strong>，最少<strong>两个节点便可以构成主从模式</strong>，并且可以通过<strong>读写分离避免读和写同时不可用</strong>。不过，一旦 Master 节点出现故障，主从节点就<strong>无法自动切换</strong>，直接导致 SLA 下降。所以，主从模式一般<strong>适合业务发展初期，并发量低，运维成本低</strong>的情况</p><p><a href="https://camo.githubusercontent.com/57c39c05c9c63072ca6ee048e33086532da6d55e8e4651193363118a6d0674c5/68747470733a2f2f73302e6c677374617469632e636f6d2f692f696d6167652f4d30302f38302f32352f4369716331465f5167504f41614c38544141433545694e6c766f343739352e706e67"><img src="https://camo.githubusercontent.com/57c39c05c9c63072ca6ee048e33086532da6d55e8e4651193363118a6d0674c5/68747470733a2f2f73302e6c677374617469632e636f6d2f692f696d6167652f4d30302f38302f32352f4369716331465f5167504f41614c38544141433545694e6c766f343739352e706e67" alt="Drawing 1.png"></a></p><p><strong>主从复制原理：</strong></p><p> ①通过从服务器发送到PSYNC命令给主服务器</p><p> ②如果是首次连接，触发一次<strong>全量复制</strong>。此时主节点会启动一个后台线程，生成 RDB 快照文件</p><p> ③主节点会将这个 RDB 发送给从节点，slave 会先写入本地磁盘，再从本地磁盘加载到内存中</p><p> ④master会将此过程中的写命令写入缓存，从节点<strong>实时同步</strong>这些数据</p><p> ⑤如果网络断开了连接，自动重连后主节点通过命令传播<strong>增量复制</strong>给从节点部分缺少的数据</p><p><strong>缺点</strong></p><p> 所有的slave节点数据的复制和同步都由master节点来处理，会照成master节点压力太大，使用主从从结构来解决，redis4.0中引入psync2 解决了slave重启后仍然可以增量同步。</p><h4 id="3、哨兵模式-读多"><a href="#3、哨兵模式-读多" class="headerlink" title="3、哨兵模式&#x3D;读多"></a>3、<strong>哨兵模式</strong>&#x3D;读多</h4><p> 由一个或多个sentinel实例组成sentinel集群可以监视一个或多个主服务器和多个从服务器。<strong>哨兵模式适合读请求远多于写请求的业务场景，比如在秒杀系统</strong>中用来缓存活动信息。 如果写请求较多，当集群 Slave 节点数量多了后，Master 节点同步数据的压力会非常大。</p><p><a href="https://camo.githubusercontent.com/14be4fd4607c8bae515a137326103bc995acafafb559a74c85c89389ec2f336e/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676c757136766c76676c6a33306e773065303736662e6a7067"><img src="https://camo.githubusercontent.com/14be4fd4607c8bae515a137326103bc995acafafb559a74c85c89389ec2f336e/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676c757136766c76676c6a33306e773065303736662e6a7067" alt="image-20201220231241725"></a></p><p>当主服务器进入下线状态时，sentinel可以将该主服务器下的某一从服务器升级为主服务器继续提供服务，从而保证redis的高可用性。</p><p><strong>检测主观下线状态</strong></p><p> Sentinel每秒一次向所有与它建立了命令连接的实例(主服务器、从服务器和其他Sentinel)发送PING命 令</p><p> 实例在down-after-milliseconds毫秒内返回无效回复Sentinel就会认为该实例主观下线(<strong>SDown</strong>)</p><p><strong>检查客观下线状态</strong></p><p> 当一个Sentinel将一个主服务器判断为主观下线后 ，Sentinel会向监控这个主服务器的所有其他Sentinel发送查询主机状态的命令</p><p> 如果达到Sentinel配置中的quorum数量的Sentinel实例都判断主服务器为主观下线，则该主服务器就会被判定为客观下线(<strong>ODown</strong>)。</p><p><strong>选举Leader Sentinel</strong></p><p> 当一个主服务器被判定为客观下线后，监视这个主服务器的所有Sentinel会通过选举算法(raft)，选出一个Leader Sentinel去执行**failover(故障转移)**操作。</p><p> <strong>Raft算法</strong></p><p> Raft协议是用来解决分布式系统一致性问题的协议。 Raft协议描述的节点共有三种状态:Leader, Follower, Candidate。 Raft协议将时间切分为一个个的Term(任期)，可以认为是一种“逻辑时间”。 选举流程: ①Raft采用心跳机制触发Leader选举系统启动后，全部节点初始化为Follower，term为0</p><p> ②节点如果收到了RequestVote或者AppendEntries，就会保持自己的Follower身份</p><p> ③节点如果一段时间内没收到AppendEntries消息，在该节点的超时时间内还没发现Leader，Follower就会转换成Candidate，自己开始竞选Leader。 一旦转化为Candidate，该节点立即开始下面几件事情: –增加自己的term，启动一个新的定时器 –给自己投一票，向所有其他节点发送RequestVote，并等待其他节点的回复。</p><p> ④如果在计时器超时前，节点收到多数节点的同意投票，就转换成Leader。同时通过 AppendEntries，向其他节点发送通知。</p><p> ⑤每个节点在一个term内只能投一票，采取先到先得的策略，Candidate投自己， Follower会投给第一个收到RequestVote的节点。</p><p> ⑥Raft协议的定时器采取随机超时时间（选举的关键），先转为Candidate的节点会先发起投票，从而获得多数票。</p><p><strong>主服务器的选择</strong></p><p> 当选举出Leader Sentinel后，Leader Sentinel会根据以下规则去从服务器中选择出新的主服务器。</p><ol><li>过滤掉主观、客观下线的节点</li><li>选择配置slave-priority最高的节点，如果有则返回没有就继续选择</li><li>选择出复制偏移量最大的系节点，因为复制偏移量越大则数据复制的越完整</li><li>选择run_id最小的节点，因为run_id越小说明重启次数越少</li></ol><p><strong>故障转移</strong></p><p> 当Leader Sentinel完成新的主服务器选择后，Leader Sentinel会对下线的主服务器执行故障转移操作，主要有三个步骤:</p><p> 1、它会将失效 Master 的其中一个 Slave 升级为新的 Master , 并让失效 Master 的其他 Slave 改为复制新的 Master ;</p><p> 2、当客户端试图连接失效的 Master 时，集群会向客户端返回新 Master 的地址，使得集群当前状态只有一个Master。</p><p> 3、Master 和 Slave 服务器切换后， Master 的 redis.conf 、 Slave 的 redis.conf 和 sentinel.conf 的配置文件的内容都会发生相应的改变，即 Master 主服务器的 redis.conf配置文件中会多一行 replicaof 的配置， sentinel.conf 的监控目标会随之调换。</p><h4 id="4、集群模式-写多"><a href="#4、集群模式-写多" class="headerlink" title="4、集群模式&#x3D;写多"></a>4、集群模式&#x3D;写多</h4><p> 为了避免单一节点负载过高导致不稳定，集群模式采用<strong>一致性哈希算法或者哈希槽的方法</strong>将 Key 分布到各个节点上。其中，每个 Master 节点后跟若干个 Slave 节点，用于<strong>出现故障时做主备切换</strong>，客户端可以<strong>连接任意 Master 节点</strong>，集群内部会按照<strong>不同 key 将请求转发到不同的 Master</strong> 节点</p><p> 集群模式是如何实现高可用的呢？集群内部节点之间会<strong>互相定时探测</strong>对方是否存活，如果多数节点判断某个节点挂了，则会将其踢出集群，然后从 <strong>Slave</strong> 节点中选举出一个节点<strong>替补</strong>挂掉的 Master 节点。<strong>整个原理基本和哨兵模式一致</strong></p><p> 虽然集群模式避免了 Master 单节点的问题，但<strong>集群内同步数据时会占用一定的带宽</strong>。所以，只有在<strong>写操作比较多的情况下人们才使用集群模式</strong>，其他大多数情况，使用<strong>哨兵模式</strong>都能满足需求</p><h4 id="5、分布式锁"><a href="#5、分布式锁" class="headerlink" title="5、分布式锁"></a>5、分布式锁</h4><p><strong>利用Watch实现Redis乐观锁</strong></p><p> 乐观锁基于CAS(Compare And Swap)比较并替换思想，不会产生锁等待而消耗资源，但是需要反复的重试，但也是因为重试的机制，能比较快的响应。因此我们可以利用redis来实现乐观锁**（秒杀）**。具体思路如下:</p><p>1、利用redis的watch功能，监控这个redisKey的状态值 2、获取redisKey的值，创建redis事务，给这个key的值+1 3、执行这个事务，如果key的值被修改过则回滚，key不加1</p><p><strong>利用setnx防止库存超卖</strong> 分布式锁是控制分布式系统之间同步访问共享资源的一种方式。 利用Redis的单线程特性对共享资源进行串行化处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 获取锁推荐使用set的方式</span><br><span class="line">String result = jedis.set(lockKey, requestId, &quot;NX&quot;, &quot;EX&quot;, expireTime);</span><br><span class="line">String result = jedis.setnx(lockKey, requestId); //如线程死掉，其他线程无法获取到锁</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 释放锁，非原子操作，可能会释放其他线程刚加上的锁</span><br><span class="line">if (requestId.equals(jedis.get(lockKey))) &#123; </span><br><span class="line">  jedis.del(lockKey);</span><br><span class="line">&#125;</span><br><span class="line">// 推荐使用redis+lua脚本</span><br><span class="line">String lua = &quot;if redis.call(&#x27;get&#x27;,KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;,KEYS[1]) else return 0 end&quot;;</span><br><span class="line">Object result = jedis.eval(lua, Collections.singletonList(lockKey),</span><br></pre></td></tr></table></figure><p><strong>分布式锁存在的问题</strong>：</p><ul><li><strong>客户端长时间阻塞导致锁失效问题</strong></li></ul><p> 计算时间内异步启动另外一个线程去检查的问题，这个key是否超时，当锁超时时间快到期且逻辑未执行完，延长锁超时时间。</p><ul><li><p>**Redis服务器时钟漂移问题导致同时加锁 redis的过期时间是依赖系统时钟的，如果时钟漂移过大时 理论上是可能出现的 **会影响到过期时间的计算。</p></li><li><p><strong>单点实例故障，锁未及时同步导致丢失</strong></p><p><strong>RedLock算法</strong></p></li></ul><ol><li><p>获取当前时间戳T0，配置时钟漂移误差T1</p></li><li><p>短时间内逐个获取全部N&#x2F;2+1个锁，结束时间点T2</p></li><li><p>实际锁能使用的处理时长变为：TTL - （T2 - T0）- T1</p><p>该方案通过多节点来<strong>防止Redis的单点故障</strong>，效果一般，也无法防止：</p></li></ol><ul><li><p><strong>主从切换导致的两个客户端同时持有锁</strong></p><p>大部分情况下<strong>持续时间极短</strong>，而且使用<strong>Redlock在切换的瞬间</strong>获取到节点的锁，也存在问题。已经是极低概率的时间，无法避免。<strong>Redis分布式锁适合幂等性事务</strong>，如果一定要<strong>保证安全</strong>，应该<strong>使用Zookeeper或者DB</strong>，但是，<strong>性能会急剧下降</strong>。</p></li></ul><p><strong>与zookeeper分布式锁对比</strong></p><ul><li>redis 分布式锁，其实<strong>需要自己不断去尝试获取锁</strong>，比较消耗性能。</li><li>zk 分布式锁，注册个监听器即可，不需要不断主动尝试获取锁，ZK获取锁会按照加锁的顺序，所以是公平锁，性能和mysql差不多，和redis差别大</li></ul><p><strong>Redission生产环境的分布式锁</strong></p><p> Redisson是基于NIO的Netty框架上的一个Java驻内存数据网格(In-Memory Data Grid)分布式锁开源组件。</p><p>[<img src="https://camo.githubusercontent.com/d4bb39450b12931a1c541b9f4cf298c192b80e07401161695c63af3589cdcc02/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676c75726c66727270346a3330716b3067383736632e6a7067" alt="image-20201221000119586"></p><p><a href="https://camo.githubusercontent.com/d4bb39450b12931a1c541b9f4cf298c192b80e07401161695c63af3589cdcc02/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676c75726c66727270346a3330716b3067383736632e6a7067"></a></p><ol><li>客户端请求加锁</li></ol><ul><li><strong>客户端1请求加锁</strong>：客户端1通过 Redisson 向 Redis 发送加锁请求。</li><li><strong>是否加锁</strong>：Redisson 会检查是否能够成功获取锁。如果能获取锁，则进入下一步，否则根据哈希算法选择一个节点进行加锁。</li></ul><ol start="2"><li>加锁过程</li></ol><ul><li><strong>根据哈希算法选择一个节点</strong>：Redisson 根据哈希算法选择一个 Redis 主节点来处理加锁请求。</li><li><strong>执行Lua脚本加锁</strong>：加锁操作通过 Lua 脚本在 Redis 主节点上执行，确保操作的原子性。</li></ul><ol start="3"><li>看门狗机制</li></ol><ul><li><strong>看门狗定时续约</strong>：一旦客户端1成功获取锁，Redisson 的看门狗机制启动。看门狗每隔10秒检查锁的状态，如果客户端还持有锁，则会自动延长锁的生存时间，防止锁过期。</li></ul><ol start="4"><li>客户端释放锁</li></ol><ul><li><strong>释放锁和删除 key</strong>：当客户端1完成任务后，会主动释放锁并删除对应的 Redis 键。</li></ul><ol start="5"><li>另一个客户端请求加锁</li></ol><ul><li><strong>客户端2请求加锁</strong>：客户端2通过 Redisson 发送加锁请求。</li><li><strong>是否加锁</strong>：Redisson 会检查是否能够成功获取锁。如果不能成功获取锁，客户端2会进入一个循环，不断尝试获取锁，直到成功。</li></ul><p>Redis 集群</p><ul><li><strong>Redis 集群架构</strong>：Redis 集群由多个主从节点组成，主节点负责写操作，从节点负责读操作和数据复制。</li></ul><p>但当业务必须要数据的强一致性，即不允许重复获得锁，比如金融场景(重复下单，重复转账)，<strong>请不要使用redis分布式锁</strong>。可以使用CP模型实现，比如:<strong>zookeeper和etcd。</strong></p><table><thead><tr><th></th><th>Redis</th><th>zookeeper</th><th>etcd</th></tr></thead><tbody><tr><td>一致性算法</td><td>无</td><td>paxos(ZAB)</td><td>raft</td></tr><tr><td>CAP</td><td>AP</td><td>CP</td><td>CP</td></tr><tr><td>高可用</td><td>主从集群</td><td>n+1</td><td>n+1</td></tr><tr><td>实现</td><td>setNX</td><td>createNode</td><td>restfulAPI</td></tr></tbody></table><h4 id="6、redis心跳检测"><a href="#6、redis心跳检测" class="headerlink" title="6、redis心跳检测"></a>6、redis心跳检测</h4><p>在命令传播阶段，从服务器默认会以每秒一次的频率向主服务器发送ACK命令:</p><p> 1、检测主从的连接状态 检测主从服务器的网络连接状态</p><p> lag的值应该在0或1之间跳动，如果超过1则说明主从之间的连接有 故障。</p><p> 2、辅助实现min-slaves,Redis可以通过配置防止主服务器在不安全的情况下执行写命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write 3 (min-replicas-to-write 3 )</span><br><span class="line"></span><br><span class="line">min-slaves-max-lag 10 (min-replicas-max-lag 10)</span><br></pre></td></tr></table></figure><p> 上面的配置表示:从服务器的数量少于3个，或者三个从服务器的延迟(lag)值都大于或等于10 秒时，主服务器将拒绝执行写命令。</p><p> 3、检测命令丢失，增加重传机制</p><p> 如果因为网络故障，主服务器传播给从服务器的写命令在半路丢失，那么当从服务器向主服务器发 送REPLCONF ACK命令时，主服务器将发觉从服务器当前的复制偏移量少于自己的复制偏移量， 然后主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区里面找到从服务器缺少的数据，并将这些数据重新发送给从服务器。</p><h3 id="Redis实战"><a href="#Redis实战" class="headerlink" title="Redis实战"></a>Redis实战</h3><h4 id="1、Redis优化"><a href="#1、Redis优化" class="headerlink" title="1、Redis优化"></a>1、Redis优化</h4><p><a href="https://camo.githubusercontent.com/4a389e85310aee19c0ed6e9c1a5c881ace5b5a181ebdc4f240b7a64b7d6e0a51/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303865476d5a456c7931676f726d356d376234676a3330757930686a7766702e6a7067"><img src="https://camo.githubusercontent.com/4a389e85310aee19c0ed6e9c1a5c881ace5b5a181ebdc4f240b7a64b7d6e0a51/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303865476d5a456c7931676f726d356d376234676a3330757930686a7766702e6a7067" alt="img"></a></p><p><strong>读写方式</strong> 简单来说就是不用<strong>keys</strong>等，用<strong>range、contains</strong>之类。比如，用户粉丝数，大 V 的粉丝更是高达几千万甚至过亿，因此，获取粉丝列表只能部分获取。另外在判断某用户是否关注了另外一个用户时，也只需要关注列表上进行检查判断，然后返回 True&#x2F;False 或 0&#x2F;1 的方式更为高效。</p><p><strong>KV size</strong> 如果单个业务的 KV size 过大，需要分拆成多个 KV 来缓存。拆分时应<strong>考虑访问频率</strong></p><p><strong>key 的数量</strong> 如果数据量巨大，则在缓存中尽可能只保留频繁访问的热数据，对于冷数据直接访问 DB。</p><p><strong>读写峰值</strong> 如果小于 10万 级别，简单分拆到独立 Cache 池即可 如果达到 100万 级的QPS，则需要对 Cache 进行分层处理，可以同时使用 Local-Cache 配合远程 cache，甚至远程缓存内部继续分层叠加分池进行处理。<strong>（多级缓存）</strong></p><p><strong>命中率</strong> 缓存的命中率对整个服务体系的性能影响甚大。对于核心高并发访问的业务，需要预留足够的容量，确保核心业务缓存维持较高的命中率。比如微博中的 Feed Vector Cache（<strong>热点资讯</strong>），常年的命中率高达 99.5% 以上。为了持续保持缓存的命中率，缓存体系需要持续监控，及时进行故障处理或故障转移。同时在部分缓存节点异常、命中率下降时，故障转移方案，需要考虑是采用一致性 Hash 分布的访问漂移策略，还是采用数据多层备份策略。</p><p><strong>过期策略</strong></p><p> 可以设置较短的过期时间，让冷 key 自动过期；也可以让 key 带上时间戳，同时设置较长的过期时间，比如很多业务系统内部有这样一些 key：key_20190801。</p><p><strong>缓存穿透时间</strong> 平均缓存穿透加载时间在某些业务场景下也很重要，对于一些缓存穿透后，加载时间特别长或者需要复杂计算的数据，而且访问量还比较大的业务数据，要配置更多容量，维持更高的命中率，从而减少穿透到 DB 的概率，来确保整个系统的访问性能。</p><p><strong>缓存可运维性</strong> 对于缓存的可运维性考虑，则需要考虑缓存体系的集群管理，如何进行一键扩缩容，如何进行缓存组件的升级和变更，如何快速发现并定位问题，如何持续监控报警，最好有一个完善的运维平台，将各种运维工具进行集成。</p><p><strong>缓存安全性</strong> 对于缓存的安全性考虑，一方面可以限制来源 IP，只允许内网访问，同时加密鉴权访问。</p><h4 id="2、Redis热升级"><a href="#2、Redis热升级" class="headerlink" title="2、Redis热升级"></a>2、Redis热升级</h4><blockquote><p>在 Redis 需要升级版本或修复 bug 时，如果直接重启变更，由于需要数据恢复，这个过程需要近 10 分钟的时间，时间过长，会严重影响系统的可用性。面对这种问题，可以对 Redis 扩展热升级功能，从而在毫秒级完成升级操作，完全不影响业务访问。</p></blockquote><p>热升级方案如下，首先构建一个 Redis 壳程序，将 redisServer 的所有属性（包括redisDb、client等）保存为全局变量。然后将 Redis 的处理逻辑代码全部封装到动态连接库 so 文件中。Redis 第一次启动，从磁盘加载恢复数据，在后续升级时，通过指令，壳程序重新加载 Redis 新的 redis-4.so 到 redis-5.so 文件，即可完成功能升级，毫秒级完成 Redis 的版本升级。而且整个过程中，所有 Client 连接仍然保留，在升级成功后，原有 Client 可以继续进行读写操作，整个过程对业务完全透明。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM基础</title>
      <link href="/2022/08/01/JVM/"/>
      <url>/2022/08/01/JVM/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><span id="more"></span><h1 id="JVM（执行字节码，转为机器码）"><a href="#JVM（执行字节码，转为机器码）" class="headerlink" title="JVM（执行字节码，转为机器码）"></a>JVM（执行字节码，转为机器码）</h1><h2 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol><li>Java虚拟机是一台执行<code>Java字节码</code>的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。</li><li>JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回收器，以及可靠的即时编译器。</li><li><strong>Java技术的核心就是Java虚拟机</strong>（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。</li></ol><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>​<strong>Java虚拟机就是二进制字节码的运行环境</strong>，负责装载字节码到其内部，解释&#x2F;编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>一次编译，到处运行</li><li>自动内存管理</li><li>自动垃圾回收功能</li></ol><h2 id="JVM的整体结构"><a href="#JVM的整体结构" class="headerlink" title="JVM的整体结构"></a>JVM的整体结构</h2><ol><li>类加载器</li><li>运行时数据区<ol><li>JVM 定义的Java 程序运行期间需要使用到的内存区域，简单来说，这块内存区域存放了字节码信息以及程序执行过程的数据。</li></ol></li><li>执行引擎</li></ol><p><img src="/iamges/jvm/1.png" alt="img"></p><p>使用基于<strong>栈</strong>的指令集架构</p><h3 id="基于栈的指令集架构（了解）"><a href="#基于栈的指令集架构（了解）" class="headerlink" title="基于栈的指令集架构（了解）"></a>基于栈的指令集架构（了解）</h3><p>基于栈式架构的特点：</p><ol><li>设计和实现更简单，适用于资源受限的系统；</li><li>避开了寄存器的分配难题：使用<code>零地址</code>指令方式分配</li><li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。<strong>指令集更小</strong>，编译器容易实现</li><li><strong>不需要硬件支持，可移植性更好，更好实现跨平台</strong></li></ol><h3 id="基于寄存器的指令级架构（了解）"><a href="#基于寄存器的指令级架构（了解）" class="headerlink" title="基于寄存器的指令级架构（了解）"></a>基于寄存器的指令级架构（了解）</h3><p>基于寄存器架构的特点：</p><ol><li>典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。</li><li>指令集架构则完全依赖硬件，与硬件的耦合度高，<strong>可移植性差</strong></li><li><strong>性能优秀和执行更高效</strong></li><li>花费更少的指令去完成一项操作</li><li>在大部分情况下，基于寄存器架构的指令集往往都以<code>一地址指令、二地址指令和三地址指令</code>为主，而基于栈式架构的指令集却是以零地址指令为主</li></ol><h2 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a>JVM的生命周期</h2><h3 id="虚拟机的启动"><a href="#虚拟机的启动" class="headerlink" title="虚拟机的启动"></a>虚拟机的启动</h3><p>Java虚拟机的启动是通过<code>引导类加载器</code>（bootstrap class loader）创建一个<code>初始类</code>（initial class）来完成的，这个类是由虚拟机的具体实现指定的</p><h3 id="虚拟机的执行"><a href="#虚拟机的执行" class="headerlink" title="虚拟机的执行"></a>虚拟机的执行</h3><ol><li>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序</li><li>程序开始执行时他才运行，程序结束时他就停止</li><li><strong>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程</strong></li></ol><h3 id="虚拟机的退出"><a href="#虚拟机的退出" class="headerlink" title="虚拟机的退出"></a>虚拟机的退出</h3><p><strong>有如下的几种情况：</strong></p><ol><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统用现错误而导致Java虚拟机进程终止</li><li>某线程调用Runtime类或System类的<code>exit()</code>方法，或Runtime类的<code>halt()</code>方法，并且Java安全管理器也允许这次exit()或halt()操作。</li><li>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。</li></ol><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><ol><li><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ul><li>通过一个类的全限定名获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</li></ul></li><li><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ol><li><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><ul><li>目的在于确保 Class 文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</li><li>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</li></ul></li><li><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><ul><li>为类变量分配内存并且设置该类变量的默认初始值，即零值。</li><li>这里不包括用 final 修饰的 static，因为 final 在编译的时候就会分配了，准备阶段会显示初始化。</li><li>这里不会为实例变量分配初始值，类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中。</li></ul></li><li><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><ul><li>将常量池内的符号引用转换为直接引用的过程。</li><li>事实上，解析操作往往会伴随着 JVM 在执行完初始化之后再执行。</li><li>符号引用就是一组符号来描述所引用的目标，符号引用的字面量形式明确定义在《Java 虚拟机规范》的 Class 文件格式中。直接引用就是直接指向目标的指针，相对偏移量或一个间接定位到目标的句柄。</li><li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的 CONSTANT_Class_info、CONSTANT_Filedref_info、CONSTANT_Methodref_ref 等。</li></ul></li></ol></li><li><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul><li>初始化阶段就是执行构造方法 clinit() 的过程。clinit() 不同于类的构造器。（关联：类的构造器是虚拟机视角下的 init()）</li><li>此方法不需定义，是 javac 编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。</li><li>构造器方法中指令按语句在源文件中出现的顺序执行。</li><li>若该类具有父类，JVM 会保证子类的 clinit() 执行前，父类的 clinit() 已经执行完毕。</li><li>虚拟机必须保证一个类的 clinit() 方法在多线程下被同步加锁。</li></ul></li></ol><p>Java类的加载过程是动态的，它不会一次性把程序所有的类全部加载后再运行，而是先保障程序运行的基础类加载到JVM虚拟机当中，其他的类，一般是再需要的时候才会去加载，这样的运行机制也达到了节约内存的目的。</p><p>当JVM虚拟机加载某个class文件的时候，采用的是双亲委派模式（任务委派模式），就是将请求交给父类去处理。</p><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a><strong>双亲委派机制</strong></h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>​双亲委派机制是指当一个类加载器收到某个类加载请求时，该类加载器首先会把请求委派给父类加载器。每个类加载器都是如此，它会先委托父类加载器在自己的搜索范围内找不到对应的类时，该类加载器才会尝试自己去加载。</p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p><img src="/iamges/jvm/2.png" alt="img"></p><ul><li><strong>Application ClassLoader</strong> 收到一个类加载请求时，首先它自己不会先去尝试加载这个类，而是先将这个加载请求委派给父类加载器Extension ClassLoader去加载。 </li><li>如果<strong>Extension ClassLoader</strong>收到一个类加载请求时，先将加载请求委派给父类加载器Bootstrap ClassLoader去完成。 </li><li>如果<strong>Bootstrap ClassLoader</strong>加载失败(在<JAVA_HOME>\lib中未找到所需类)，就会让<strong>Extension ClassLoader</strong>尝试加载；如果加载成功了就不再让<strong>Extension ClassLoader</strong>加载，过程结束。 </li><li>如果Extension ClassLoader也加载失败，就会使用<strong>Application ClassLoader</strong>加载；如果加载成功了就不再让<strong>Application ClassLoader</strong>加载，过程结束。 </li><li>如果<strong>Application ClassLoader</strong>也加载失败，就会使用自定义加载器去尝试加载。 </li><li>如果所有的加载都失败了，就会抛出ClassNotFoundException异常。</li></ul><p>理解：执行的情况都是由Bootstrap ClassLoader先加载，失败了轮到Extension ClassLoader加载，再失败了轮到Application ClassLoader，最后轮到自定义加载器加载。一般情况下大家<strong>写的java程序都是Application ClassLoader进行加载</strong>的。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li><strong>安全性高</strong>：<ul><li><strong>防止核心类库被篡改</strong>：通过双亲委派机制，核心类库（如<code>java.lang.*</code>包）由启动类加载器（Bootstrap ClassLoader）加载，避免被自定义类加载器加载和篡改。</li></ul></li><li><strong>类一致性</strong>：<ul><li><strong>防止重复加载</strong>：双亲委派机制确保一个类在整个应用程序中只有一个类加载器加载，避免了类的重复加载问题，从而保证了Java类的类型一致性。</li></ul></li><li><strong>简化类加载逻辑</strong>：<ul><li>通过委派机制，类加载器之间的关系更加清晰明了，减少了类加载器之间的复杂依赖关系，简化了类加载器的实现。</li></ul></li><li><strong>类加载的层次结构</strong>：<ul><li>维护了一个清晰的类加载层次结构，有助于代码的模块化和分层设计。</li></ul></li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li><strong>灵活性不足</strong>：<ul><li>对于某些特殊需求，双亲委派机制可能显得不够灵活。比如，在需要重载核心类库时，双亲委派机制会阻碍这种操作，因为它总是优先使用父类加载器加载的类。</li></ul></li><li><strong>调试复杂</strong>：<ul><li>当类加载出现问题（如类冲突或加载失败）时，由于双亲委派机制的层级关系，调试和排查问题可能变得更加复杂。</li></ul></li><li><strong>性能问题</strong>：<ul><li>在某些场景下，频繁的类加载请求可能会产生性能开销，因为每次加载请求都需要经过父类加载器的检查，这可能增加加载时间。</li></ul></li></ol><h3 id="自定义类加载器使用场景"><a href="#自定义类加载器使用场景" class="headerlink" title="自定义类加载器使用场景"></a>自定义类加载器使用场景</h3><ol><li><strong>网络下载类</strong>，某些应用可能需要动态从网络加载类，自定义类加载器可以实现这一功能。</li><li><strong>应用安全性</strong>，自定义类加载器可以实现自定义的类加载策略和安全检查，控制加载哪些类以及如何加载，提升应用的安全性。</li></ol><h3 id="破坏双亲委派机制："><a href="#破坏双亲委派机制：" class="headerlink" title="破坏双亲委派机制："></a><strong>破坏双亲委派机制：</strong></h3><ul><li>可以⾃⼰定义⼀个类加载器，重写loadClass方法；</li><li>Tomcat 可以加载自己目录下的 class 文件，并不会传递给父类的加载器；</li><li>Java 的 SPI，发起者 BootstrapClassLoader 已经是最上层了，它直接获取了 AppClassLoader 进行驱动加载，和双亲委派是相反的。</li></ul><h3 id="tomcat的类加载机制"><a href="#tomcat的类加载机制" class="headerlink" title="tomcat的类加载机制"></a>tomcat的类加载机制</h3><p><strong>步骤：</strong></p><ol><li>先在本地cache查找该类是否已经加载过，看看 Tomcat 有没有加载过这个类。</li><li>如果Tomcat 没有加载过这个类，则从系统类加载器的cache中查找是否加载过。</li><li>如果没有加载过这个类，尝试用ExtClassLoader类加载器类加载，重点来了，这里并没有首先使用 ApplicationClassLoader 来加载类。这个Tomcat 的 WebAPPClassLoader 违背了双亲委派机制，直接使用了 ExtClassLoader来加载类。这里注意 ExtClassLoader 双亲委派依然有效，ExtClassLoader 就会使用 Bootstrap ClassLoader 来对类进行加载，保证了 Jre 里面的核心类不会被重复加载。 比如在 Web 中加载一个 Object 类。<strong>WebAppClassLoader → ExtClassLoader → Bootstrap ClassLoader</strong>，这个加载链，就保证了 Object 不会被重复加载。</li><li>如果 BoostrapClassLoader，没有加载成功，就会调用自己的 findClass 方法由自己来对类进行加载，findClass 加载类的地址是自己本 web 应用下的 class。</li><li>加载依然失败，才使用 AppClassLoader 继续加载。</li><li>都没有加载成功的话，抛出异常。</li></ol><p><strong>总结一下以上步骤，WebAppClassLoader 加载类的时候，故意打破了JVM 双亲委派机制，绕开了 AppClassLoader，直接先使用 ExtClassLoader 来加载类。</strong></p><h2 id="JVM内存划分"><a href="#JVM内存划分" class="headerlink" title="JVM内存划分"></a>JVM内存划分</h2><h4 id="JVM运行时数据区域"><a href="#JVM运行时数据区域" class="headerlink" title="JVM运行时数据区域"></a><strong>JVM运行时数据区域</strong></h4><p>​运行时数据区： 堆，方法区（元空间），程序计数器，本地方法栈，虚拟机栈</p><p><img src="/iamges/jvm/3.png" alt="img"></p><p><strong>Heap（堆）：</strong></p><p>​对象实例和数组的内存在堆上进行分配，是一块线程共享区域，用来存放对象实例，也是垃圾回收（GC）的主要区域；开启逃逸分析后，某些未逃逸的对象可以通过标量替换的方式在栈中分配；</p><p>​堆细分：新生代、老年代，对于新生代又分为：<strong>Eden区</strong>和<strong>Surviver1</strong>和<strong>Surviver2</strong>区；</p><p><strong>方法区（永久区）：</strong></p><p>​存储<strong>已经</strong>被JVM加载的类信息，常量，静态变量；线程共享；Jdk1.8以后取消了方法区这个概念，称之为元空间（MetaSpace）；</p><p>​当应用中的 Java 类过多时，比如 <strong>Spring 等一些使用动态代理的框架生成了很多类</strong>，如果占用空间超出了我们的设定值，就会发生<strong>元空间溢出</strong>；</p><p><strong>虚拟机栈：</strong></p><p>​线程私有；生命周期和线程的生命周期一起。里面存放的是一个个栈帧（单位），每个方法在执行的时候都会创建一个栈帧，用来存放局部变量表，操作数栈，动态链接，返回地址；</p><p>​在Java虚拟机规范中，对此区域规定了两种异常状况：</p><ol><li>如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出<strong>StackOverflowError</strong>异常（栈溢出）；</li><li>如果虚拟机栈动态扩展时无法申请到足够的内存，就会抛出<strong>OutOfMemoryError</strong>异常（内存溢出OOM）。</li></ol><p><strong>本地方法栈：</strong></p><p>​线程私有；与虚拟机栈类似，不同的是虚拟机栈服务的是Java方法，而<strong>本地方法栈服务的是Native方法</strong>。在HotSpot虚拟机实现中是把本地方法栈和虚拟机栈合二为一的，同理它也会抛出<strong>StackOverflowError</strong>和<strong>OOM</strong>异常。</p><p><strong>PC程序计数器：</strong></p><p>​线程私有；PC指的是存放下一条指令的位置的一个指针；它是一块较小的内存空间；由于线程的切换，CPU在执行的过程中，需要记住原线程的下一条指令的位置，所以每一个线程都需要有自己的PC。</p><h4 id="堆内存分配策略"><a href="#堆内存分配策略" class="headerlink" title="堆内存分配策略"></a><strong>堆内存分配策略</strong></h4><p><img src="/iamges/jvm/4.png" alt="img"></p><ul><li><p>对象优先分配在Eden区，如果Eden区没有足够的空间进行分配时，虚拟机执行一次<strong>MinorGC</strong>。而那些无需回收的存活对象，将会进到 Survivor 的 From 区（From 区内存不足时，直接进入 Old 区）。</p></li><li><p>大对象直接进入老年代（需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。</p></li><li><p>长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄（Age Count）计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，直到达到阀值（默认15次），对象进入老年区。</p><p>（<strong>动态对象年龄判定</strong>：程序从年龄最小的对象开始累加，如果累加的对象大小，大于幸存区的一半，则将当前的对象 age 作为新的阈值，年龄大于此阈值的对象则直接进入老年代）</p></li><li><p>每次进行Minor GC或者大对象直接进入老年区时，JVM会计算所需空间大小如小于老年区的剩余值大小，则进行一次<strong>Full GC</strong>。</p></li></ul><h4 id="创建一个对象的步骤"><a href="#创建一个对象的步骤" class="headerlink" title="创建一个对象的步骤"></a><strong>创建一个对象的步骤</strong></h4><p><strong>步骤：类加载检查、分配内存、初始化零值、设置对象头、执行init方法</strong></p><h2 id="JVM垃圾回收"><a href="#JVM垃圾回收" class="headerlink" title="JVM垃圾回收"></a>JVM垃圾回收</h2><h3 id="1-JVM判断对象是否存活的算法"><a href="#1-JVM判断对象是否存活的算法" class="headerlink" title="1. JVM判断对象是否存活的算法"></a>1. JVM判断对象是否存活的算法</h3><p>​GC 的存活标准知道哪些区域的内存需要被回收之后，我们自然而然地想到了，如何去判断一个对象需要被回收呢？对于如何判断对象是否可以回收，有两种比较经典的判断策略。</p><ul><li>引用计数算法</li><li>可达性分析算法</li></ul><h4 id="引用计数算法（Reference-Counting-Collector）"><a href="#引用计数算法（Reference-Counting-Collector）" class="headerlink" title="引用计数算法（Reference Counting Collector）"></a>引用计数算法（Reference Counting Collector）</h4><p>​一个对象被创建之后，系统会给这个对象初始化一个引用计数器，当这个对象被引用了，则计数器 +1，而当该引用失效后，计数器便 -1，直到计数器为 0，意味着该对象不再被使用了，则可以将其进行回收了。</p><p> **优点：**实现简单，判定效率也很高</p><p> **缺点：**他很难解决对象之间相互循环引用的问题，基本上被抛弃</p><h4 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h4><p>​根搜索算法的中心思想，就是从某一些指定的根对象（GC Roots）（虚拟机<strong>栈帧引用</strong>，<strong>静态变量引用</strong>，<strong>JNI引用</strong>的对象）出发，一步步遍历找到和这个根对象具有引用关系的对象，然后再从这些对象开始继续寻找，从而形成一个个的引用链（其实就和图论的思想一致），然后不在这些引用链上面的对象便被标识为引用不可达对象，也就是我们说的“垃圾”，这些对象便需要回收掉。这种算法很好地解决了上面 <strong>引用计数算法</strong> 的循环引用的问题了。</p><h4 id="两次标记过程："><a href="#两次标记过程：" class="headerlink" title="两次标记过程："></a><strong>两次标记过程：</strong></h4><p> 对象被回收之前，该对象的finalize()方法会被调用；两次标记，即第一次标记不在“关系网”中的对象。第二次的话就要先判断该对象有没有实现finalize()方法了，如果没有实现就直接判断该对象可回收；如果实现了就会先放在一个队列中，并由虚拟机建立的一个低优先级的线程去执行它，随后就会进行第二次的小规模标记，在这次被标记的对象就会真正的被回收了。</p><h4 id="finalize-的定义和作用"><a href="#finalize-的定义和作用" class="headerlink" title="finalize()的定义和作用"></a>finalize()的定义和作用</h4><p>Java 允许定义这样的方法，它<strong>在对象被垃圾收集器析构(回收)之前调用</strong>，这个方法叫做 <code>finalize( )</code>，它用来清除回收对象。 不建议用<code>finalize()</code>方法完成“非内存资源”的清理工作，但建议用于：<br> ① 清理本地对象(通过JNI创建的对象)；<br> ② 确保某些非内存资源(如Socket、文件等)的释放：在<code>finalize()</code>方法中显式调用其他资源释放方法。</p><h3 id="2-常用的垃圾回收算法"><a href="#2-常用的垃圾回收算法" class="headerlink" title="2. 常用的垃圾回收算法"></a>2. 常用的垃圾回收算法</h3><ol><li><p>标记 - 清除算法（Tracing Collector）</p><p>标记出所有需要回收的对象，在标记完成后统⼀回收所有被标记的对象</p><p>缺点：效率低，标记清除后会产⽣⼤量不连续的碎⽚，需要预留空间给分配阶段的浮动垃圾</p></li><li><p>标记 - 整理算法（Compacting Collector）</p><p>标记过程仍然与“标记-清除”算法⼀样，再让所有存活的对象向⼀端移动，然后直接清理掉端边界以外的内存；</p><p>解决了产生大量不连续碎片问题</p></li><li><p>复制算法（Copying Collector）</p><p>将内存分为⼤⼩相同的两块，每次使⽤其中的⼀块。当这⼀块的内存使⽤完后，就将还存活的对象复制到另⼀块去，然后再把使⽤的空间⼀次清理掉。这样就使每次的内存回收都是对内存区间的⼀半进⾏回收；</p></li><li><p>适应性算法（Adaptive Collector）</p><p>适应性算法 <strong>其实不是一种单独的回收算法</strong>，他只是一种智能选择回收算法的机制，也就是该算法会根据堆内存具体的使用情况而自动选用更适合当前情况的回收算法。</p></li><li><p>分代回收算法</p><p><strong>分代收集算法是目前大部分JVM的垃圾收集器采用的算法。</strong></p></li></ol><h3 id="分代回收算法"><a href="#分代回收算法" class="headerlink" title="分代回收算法"></a>分代回收算法</h3><p>根据各个年代的特点选择合适的垃圾收集算法。</p><ul><li>新生代采用复制算法，新生代每次垃圾回收都要回收大部分对象，存活对象较少，即要复制的操作比较少，一般将新生代划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，每次使用Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中。</li><li>老年代的对象存活⼏率是⽐较⾼的，⽽且没有额外的空间对它进⾏分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进⾏垃圾收集。当老年代内存满时触发<code>Major GC</code>即<code>Full GC</code>，<code>Full GC</code>发生频率比较低，老年代对象存活时间比较长，存活率标记高。</li></ul><p>对象如果选择进入那个代参考堆内存分配策略</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础</title>
      <link href="/2022/07/01/mysql/"/>
      <url>/2022/07/01/mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL篇"><a href="#MySQL篇" class="headerlink" title="MySQL篇"></a>MySQL篇</h1><span id="more"></span><h3 id="WhyMysql？"><a href="#WhyMysql？" class="headerlink" title="WhyMysql？"></a>WhyMysql？</h3><p>NoSQL数据库四大家族</p><ul><li>列存储 Hbase</li><li>K-V存储 Redis</li><li>图像存储 Neo4j</li><li>文档存储 MongoDB</li></ul><p>云存储OSS</p><h4 id="海量Aerospike"><a href="#海量Aerospike" class="headerlink" title="海量Aerospike"></a>海量Aerospike</h4><p> Aerospike（简称AS）是一个分布式，可扩展的键值存储的NoSQL<strong>数据库</strong>。T级别大数据高并发的结构化**数据存储，**采用混合架构，索引存储在内存中，而数据可存储在机械硬盘(HDD)或固态硬盘(SSD) 上，读写操作达微妙级，99%的响应可在1毫秒内实现。</p><table><thead><tr><th></th><th>Aerospike</th><th>Redis</th></tr></thead><tbody><tr><td>类型</td><td>Nosql数据库</td><td>缓存</td></tr><tr><td>线程数</td><td>多线程</td><td>单线程</td></tr><tr><td>数据分片</td><td>自动处理相当于分片</td><td>提供分片算法、平衡各分片数据</td></tr><tr><td>数据扩容</td><td>动态增加数据卷平衡流量</td><td>需停机</td></tr><tr><td>数据同步</td><td>设置复制因子后可以透明的完成故障转移</td><td>手动故障转移和数据同步</td></tr><tr><td>载体</td><td>内存存储索引+SSD存储数据</td><td>内存</td></tr></tbody></table><p> Aerospike作为一个大容量的NoSql解决方案，适合对<strong>容量要求比较大，QPS相对低</strong>一些的场景，主要用在广告行业，<strong>个性化推荐厂告</strong>是建立在了和掌握消费者独特的偏好和习性的基础之上，对消费者的购买需求做出准确的预测或引导，在合适的位置、合适的时间，以合适的形式向消费者呈现与其需求高度吻合的广告，以此来促进用户的消费行为。</p><p><a href="https://camo.githubusercontent.com/cd14944dd2a162a3cc5ff7f769126d104281620ea41026b96b73b058862e5525/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676d616d3433623434626a333064393064346161372e6a7067"><img src="https://camo.githubusercontent.com/cd14944dd2a162a3cc5ff7f769126d104281620ea41026b96b73b058862e5525/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676d616d3433623434626a333064393064346161372e6a7067" alt="image-20210103170039711"></a></p><p> （ETL数据仓库技术）抽取（extract）、转换（transform）、加载（load）</p><ul><li><p>用户行为日志收集系统收集日志之后推送到ETL做数据的清洗和转换</p></li><li><p>把ETL过后的数据发送到推荐引擎计算每个消费者的推荐结果，其中推荐逻辑包括规则和算法两部分</p></li><li><p>收集用户最近浏览、最长停留等特征，分析商品相似性、用户相似性、相似性等算法。</p></li><li><p>把推荐引擎的结果存入Aerospike集群中，并提供给广告投放引擎实时获取</p><p>分别通过HDFS和HBASE对日志进行离线和实时的分析，然后把用户画像的标签(tag : 程序猿、宅男…)结果存入高性能的Nosql数据库Aerospike中，同时把数据备份到异地数据中心。前端广告投放请求通过决策引擎（投放引擎）向用户画像数据库中读取相应的用户画像数据，然后根据竞价算法出价进行竞价。竞价成功之后就可以展现广告了。而在竞价成功之后，具体给用户展现什么样的广告，就是有上面说的个性化推荐广告来完成的。</p></li></ul><table><thead><tr><th></th><th>Aerospike</th><th>Mysql</th></tr></thead><tbody><tr><td>库名</td><td>Namespace</td><td>Database</td></tr><tr><td>表名</td><td>Set</td><td>Table</td></tr><tr><td>记录</td><td>Bin</td><td>Column</td></tr><tr><td>字段</td><td>Record</td><td>Row</td></tr><tr><td>索引</td><td>key 、 pk 、kv</td><td>pk</td></tr></tbody></table><h4 id="图谱Neo4j"><a href="#图谱Neo4j" class="headerlink" title="图谱Neo4j"></a>图谱Neo4j</h4><blockquote><p>Neo4j是一个开源基于java开发的图形noSql数据库，它将结构化数据存储在图中而不是表中。它是一个嵌入式的、基于磁盘的、具备完全的事务特性的Java持久化引擎。程序数据是在一个面向对象的、灵活的网络结构下，而不是严格的表中，但具备完全的事务特性、企业级的数据库的所有好处。</p></blockquote><p>一种基于图的数据结构，由节点(Node)和边(Edge)组成。其中节点即实体，由一个全局唯一的ID标示，边就是关系用于连接两个节点。通俗地讲，知识图谱就是把所有不同种类的信息，连接在一起而得到的一个关系网络。知识图谱提供了从“关系”的角度去分析问题的能力。</p><p>互联网、大数据的背景下，谷歌、百度、搜狗等搜索引擎纷纷基于该背景，创建自己的知识图<strong>Knowledge Graph（谷歌</strong>）、<strong>知心（百度）和知立方（搜狗）</strong>，主要用于改进搜索质量。</p><p>自己项目主要用作好友推荐，图数据库(Graph database)指的是以图数据结构的形式来存储和查询数据的数据库。关系图谱中，关系的组织形式采用的就是图结构，所以非常适合用图库进行存储。</p><ul><li><p><a href="https://camo.githubusercontent.com/52f1c7041e734d0a78b73af0b6f593a5e4371fb7da13dbc3fdffa8c9ca7d84a5/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676d6171306a396f74646a3330707a30656e30766d2e6a7067"><img src="https://camo.githubusercontent.com/52f1c7041e734d0a78b73af0b6f593a5e4371fb7da13dbc3fdffa8c9ca7d84a5/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676d6171306a396f74646a3330707a30656e30766d2e6a7067" alt="image-20210103191540372"></a></p><p>优势总结:</p></li><li><p>性能上，使用cql查询，对长程关系的查询速度快</p></li><li><p>擅于发现隐藏的关系，例如通过判断图上两点之间有没有走的通的路径，就可以发现事物间的关联</p></li></ul><p><a href="https://camo.githubusercontent.com/96885ec084dd4190ed377c82069748bde17edbbf6abc920a2da49873d52fb3cf/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676d61716337357936626a333077633064363075342e6a7067"><img src="https://camo.githubusercontent.com/96885ec084dd4190ed377c82069748bde17edbbf6abc920a2da49873d52fb3cf/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676d61716337357936626a333077633064363075342e6a7067" alt="image-20210103192653004"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 查询三层级关系节点如下：with可以将前面查询结果作为后面查询条件</span><br><span class="line">match (na:Person)-[re]-(nb:Person) where na.name=&quot;林婉儿&quot; WITH na,re,nb match (nb:Person)- [re2:Friends]-&gt;(nc:Person) return na,re,nb,re2,nc</span><br><span class="line">// 直接拼接关系节点查询</span><br><span class="line">match data=(na:Person&#123;name:&quot;范闲&quot;&#125;)-[re]-&gt;(nb:Person)-[re2]-&gt;(nc:Person) return data</span><br><span class="line">// 使用深度运算符</span><br><span class="line">显然使用以上方式比较繁琐,可变数量的关系-&gt;节点可以使用-[:TYPE*minHops..maxHops]-。</span><br><span class="line">match data=(na:Person&#123;name:&quot;范闲&quot;&#125;)-[*1..2]-(nb:Person) return data</span><br></pre></td></tr></table></figure><h4 id="文档MongoDB"><a href="#文档MongoDB" class="headerlink" title="文档MongoDB"></a><strong>文档MongoDB</strong></h4><blockquote><p>MongoDB 是一个基于分布式文件存储的数据库，是非关系数据库中功能最丰富、最像关系数据库的。在高负载的情况下，通过添加更多的节点，可以保证服务器性能。由 C++ 编写，可以为 WEB 应用提供可扩展、高性能、易部署的数据存储解决方案。</p></blockquote><p><a href="https://camo.githubusercontent.com/f76c639d290aba63911606ba1168371bf87403a262711ed49c104170cf2a9662/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676d61717970373571736a333132713069387135662e6a7067"><img src="https://camo.githubusercontent.com/f76c639d290aba63911606ba1168371bf87403a262711ed49c104170cf2a9662/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676d61717970373571736a333132713069387135662e6a7067" alt="image-20210103194830654"></a></p><p><strong>什么是BSON</strong></p><blockquote><p>{key:value,key2:value2}和Json类似，是一种二进制形式的存储格式，支持内嵌的文档对象和数组对象，但是BSON有JSON没有的一些数据类型，比如 value包括字符串,double,Array,DateBSON可以做为网络数据交换的一种存储形式,它的优点是灵活性高，但它的缺点是空间利用率不是很理想。</p></blockquote><p>BSON有三个特点：轻量性、可遍历性、高效性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 查询 find() 方法可以传入多个键(key)，每个键(key)以逗号隔开*/</span><br><span class="line">db.collection.find(&#123;key1:value1, key2:value2&#125;).pretty()</span><br><span class="line">/* 更新 $set ：设置字段值 $unset :删除指定字段 $inc：对修改的值进行自增*/</span><br><span class="line">db.collection.update(&#123;where&#125;,&#123;$set:&#123;字段名:值&#125;&#125;,&#123;multi:true&#125;)</span><br><span class="line">/* 删除 justOne :如果设为true，只删除一个文档，默认false，删除所有匹配条件的文档*/</span><br><span class="line">db.collection.remove(&#123;where&#125;, &#123;justOne: &lt;boolean&gt;, writeConcern: &lt;回执&gt; &#125; )</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li><p><strong>文档结构的存储方式，能够更便捷的获取数据。</strong></p><p>对于一个层级式的数据结构来说，使用扁平式的，表状的结构来查询保存数据非常的困难。</p></li><li><p><strong>内置GridFS，支持大容量的存储。</strong></p><p>GridFS是一个出色的分布式文件系统，支持海量的数据存储，满足对大数据集的快速范围查询。</p></li><li><p><strong>性能优越</strong></p><p>千万级别的文档对象，近10G的数据，对有索引的ID的查询 不会比mysql慢，而对非索引字段的查询，则是全面胜出。 mysql实际无法胜任大数据量下任意字段的查询，而mongodb的查询性能实在牛逼。写入性能同样很令人满意，同样写入百万级别的数据，mongodb基本10分钟以下可以解决。</p></li></ul><p>缺点：</p><ul><li>不支持事务</li><li>磁盘占用空间大</li></ul><h4 id="MySQL-8-0-版本"><a href="#MySQL-8-0-版本" class="headerlink" title="MySQL 8.0 版本"></a>MySQL 8.0 版本</h4><p><strong>1. 性能</strong>：MySQL 8.0 的速度要比 MySQL 5.7 快 2 倍。</p><p><strong>2. NoSQL</strong>：MySQL 从 5.7 版本开始提供 NoSQL 存储功能，在 8.0 版本中nosql得到了更大的改进。</p><p><strong>3. 窗口函数</strong>：实现若干新的查询方式。窗口函数与 SUM()、COUNT() 这种集合函数类似，但它不会将多行查询结果合并为一行，而是将结果放回多行当中，即窗口函数不需要 GROUP BY。</p><p><strong>4. 隐藏索引</strong>：在 MySQL 8.0 中，索引可以被“隐藏”和“显示”。当对索引进行隐藏时，它不会被查询优化器所使用。我们可以使用这个特性用于性能调试，例如我们先隐藏一个索引，然后观察其对数据库的影响。如果数据库性能有所下降，说明这个索引是有用的，然后将其“恢复显示”即可；如果数据库性能看不出变化，说明这个索引是多余的，可以考虑删掉。</p><h4 id="云存储"><a href="#云存储" class="headerlink" title="云存储"></a><strong>云存储</strong></h4><table><thead><tr><th></th><th>OSS</th><th>自建</th></tr></thead><tbody><tr><td>可靠性</td><td>可用性不低于99.995% 数据设计持久性不低于99.9999999999%（12个9）</td><td>受限于硬件可靠性，易出问题，一旦出现磁盘坏道，容易出现不可逆转的数据丢失。人工数据恢复困难、耗时、耗力。</td></tr><tr><td>安全</td><td>服务端加密、客户端加密、防盗链、IP黑白名单等。多用户资源隔离机制，支持异地容灾机制。</td><td>需要另外购买清洗和黑洞设备。需要单独实现安全机制。</td></tr><tr><td>成本</td><td>多线BGP骨干网络，无带宽限制，上行流量免费。无需运维人员与托管费用，0成本运维。</td><td>单线或双线接入速度慢，有带宽限制，峰值时期需人工扩容。需专人运维，成本高。</td></tr></tbody></table><p><strong>使用步骤</strong></p><p> 1、开通服务</p><p> 2、创建存储空间</p><p> 3、上传文件、下载文件、删除文件</p><p> 4、域名绑定、日志记录</p><p> 5、根据开放接口进行鉴权访问</p><p><strong>功能</strong></p><p> 图片编辑（裁剪、模糊、水印）</p><p> 视频截图</p><p> 音频转码、视频修复</p><p><strong>CDN加速</strong></p><p> 对象存储OSS与阿里云CDN服务结合，可优化静态热点文件下载加速的场景（即同一地区大量用户同时下载同一个静态文件的场景）。可以将OSS的存储空间（Bucket）作为源站，利用阿里云CDN将源内容发布到边缘节点。当大量终端用户重复访问同一文件时，可以直接从边缘节点获取已缓存的数据，提高访问的响应速度</p><h4 id="FastDFS"><a href="#FastDFS" class="headerlink" title="FastDFS"></a><strong>FastDFS</strong></h4><blockquote><p><strong>开源的轻量级分布式文件系统</strong>。它对文件进行管理，功能包括：<strong>文件存储、文件同步、文件访问</strong>（文件上传、文件下载）等，解决了<strong>大容量存储和负载均衡</strong>的问题。使用FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。如<strong>相册网站、视频网站</strong>等</p></blockquote><p><strong>扩展能力:</strong> 支持水平扩展，可以动态扩容；</p><p><strong>高可用性:</strong> 一是整个文件系统的可用性，二是数据的完整和一致性；</p><p><strong>弹性存储:</strong> 可以根据业务需要灵活地增删存储池中的资源，而不需要中断系统运行。</p><p><a href="https://camo.githubusercontent.com/58747336811595da167be5bd93a23be0b220e6573eb6b9e51c3abfebed2afd88/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303865476d5a456c7931676d66686a6b766f35396a33307a753062346469622e6a7067"><img src="https://camo.githubusercontent.com/58747336811595da167be5bd93a23be0b220e6573eb6b9e51c3abfebed2afd88/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303865476d5a456c7931676d66686a6b766f35396a33307a753062346469622e6a7067" alt="image-20210107221022658"></a></p><p>特性</p><ul><li>和流行的web server无缝衔接，FastDFS已提供apache和nginx扩展模块</li><li>文件ID由FastDFS生成，作为文件访问凭证，FastDFS不需要传统的name server</li><li>分组存储，灵活简洁、对等结构，不存在单点</li><li>文件不分块存储，上传的文件和OS文件系统中的文件一一对应</li><li>中、小文件均可以很好支持，支持海量小文件存储</li><li>支持相同内容的文件只保存一份，节约磁盘空间</li><li>支持多块磁盘，支持单盘数据恢复</li><li>支持在线扩容 支持主从文件</li><li>下载文件支持多线程方式，支持断点续传</li></ul><p><strong>组成</strong></p><ul><li><p><strong>客户端（client）</strong></p><p>通过专有接口，使用TCP&#x2F;IP协议与跟踪器服务器或存储节点进行数据交互。</p></li><li><p><strong>跟踪器（tracker）</strong></p><p>Trackerserver作用是负载均衡和调度，通过Tracker server在文件上传时可以根据策略找到文件上传的地址。Tracker在访问上起负载均衡的作用。</p></li><li><p><strong>存储节点（storage）</strong></p><p>Storageserver作用是文件存储，客户端上传的文件最终存储在Storage服务器上，Storage server<strong>没有实现自己的文件系统而是利用操作系统的文件系统来管理文件</strong>。存储节点中的服务器均可以<strong>随时增加或下线而不会影响线上服务</strong>。</p></li></ul><p><strong>上传</strong></p><p><a href="https://camo.githubusercontent.com/edd264822ed486a33a9262901b6a53a5cde3594012a2d41e83bf6ae57236ba9a/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303865476d5a456c7931676d6668766b3077777a6a33307565306834646c772e6a7067"><img src="https://camo.githubusercontent.com/edd264822ed486a33a9262901b6a53a5cde3594012a2d41e83bf6ae57236ba9a/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303865476d5a456c7931676d6668766b3077777a6a33307565306834646c772e6a7067" alt="image-20210107222155291"></a></p><p><strong>下载</strong></p><p><a href="https://camo.githubusercontent.com/e900373916040832996ceba751552f1c87722d42ab4fdf042ee84a32ed64a952/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303865476d5a456c7931676d66687777387a6d666a333075773067366e33372e6a7067"><img src="https://camo.githubusercontent.com/e900373916040832996ceba751552f1c87722d42ab4fdf042ee84a32ed64a952/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303865476d5a456c7931676d66687777387a6d666a333075773067366e33372e6a7067" alt="image-20210107222312338"></a></p><p><strong>断点续传</strong></p><p> 续传涉及到的文件大小MD5不会改变。续传流程与文件上传类似，先<strong>定位到源storage</strong>，完成完整或部分上传，再<strong>通过binlog进行同group内server文件同步</strong>。</p><p><strong>配置优化</strong></p><p>配置文件：tracker.conf 和 storage.conf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// FastDFS采用内存池的做法。 </span><br><span class="line">// v5.04对预分配采用增量方式，tracker一次预分配 1024个，storage一次预分配256个。 </span><br><span class="line">max_connections = 10240</span><br><span class="line">// 根据实际需要将 max_connections 设置为一个较大的数值，比如 10240 甚至更大。</span><br><span class="line">// 同时需要将一个进程允许打开的最大文件数调大</span><br><span class="line">vi /etc/security/limits.conf 重启系统生效 </span><br><span class="line">* soft nofile 65535 </span><br><span class="line">* hard nofile 65535</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">work_threads = 4 </span><br><span class="line">// 说明：为了避免CPU上下文切换的开销，以及不必要的资源消耗，不建议将本参数设置得过大。</span><br><span class="line">// 公式为： work_threads + (reader_threads + writer_threads) = CPU数</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 对于单盘挂载方式，磁盘读写线程分 别设置为 1即可 </span><br><span class="line">// 如果磁盘做了RAID，那么需要酌情加大读写线程数，这样才能最大程度地发挥磁盘性能</span><br><span class="line">disk_rw_separated：磁盘读写是否分离 </span><br><span class="line">disk_reader_threads：单个磁盘读线程数 </span><br><span class="line">disk_writer_threads：单个磁盘写线程数 </span><br></pre></td></tr></table></figure><p><strong>避免重复</strong></p><p> 如何避免文件重复上传 解决方案 上传成功后计算文件对应的MD5然后<strong>存入MySQL</strong>,添加文件时把<strong>文件MD5和之前存入MYSQL中的存储的信息对比</strong> 。DigestUtils.md5DigestAsHex(bytes)。</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="1、事务4大特性"><a href="#1、事务4大特性" class="headerlink" title="1、事务4大特性"></a><strong>1、事务4大特性</strong></h4><p>**事务4大特性：**原子性、一致性、隔离性、持久性</p><p> <strong>原⼦性：</strong> 事务是最⼩的执⾏单位，不允许分割。事务的原⼦性确保动作要么全部完成，要么全不执行</p><p> <strong>一致性：</strong> 执⾏事务前后，数据保持⼀致，多个事务对同⼀个数据读取的结果是相同的；</p><p> <strong>隔离性：</strong> 并发访问数据库时，⼀个⽤户的事务不被其他事务所⼲扰，各并发事务之间数据库是独⽴的；</p><p> <strong>持久性：</strong> ⼀个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发⽣故障也不应该对其有任何影响。</p><p><strong>实现保证：</strong></p><p> MySQL的存储引擎InnoDB使用重做日志保证一致性与持久性，回滚日志保证原子性，使用各种锁来保证隔离性。</p><h4 id="2、事务隔离级别"><a href="#2、事务隔离级别" class="headerlink" title="2、事务隔离级别"></a><strong>2、事务隔离级别</strong></h4><p>**读未提交：**最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p><p>**读已提交：**允许读取并发事务已经提交的数据，可以阻⽌脏读，但是幻读或不可重复读仍有可能发⽣。</p><p>**可重复读：**同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务⾃⼰所修改，可以阻⽌脏读和不可重复读，会有幻读。</p><p>**串行化：**最⾼的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执⾏，这样事务之间就完全不可能产⽣⼲扰。</p><table><thead><tr><th>隔离级别</th><th>并发问题</th></tr></thead><tbody><tr><td>读未提交</td><td>可能会导致脏读、幻读或不可重复读</td></tr><tr><td>读已提交</td><td>可能会导致幻读或不可重复读</td></tr><tr><td>可重复读</td><td>可能会导致幻读</td></tr><tr><td>可串行化</td><td>不会产⽣⼲扰</td></tr></tbody></table><h4 id="3、默认隔离级别-RR"><a href="#3、默认隔离级别-RR" class="headerlink" title="3、默认隔离级别-RR"></a><strong>3、默认隔离级别-RR</strong></h4><p>**默认隔离级别：**可重复读；</p><p> 同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务⾃⼰所修改；</p><p> 可重复读是有可能出现幻读的，如果要保证绝对的安全只能把隔离级别设置成SERIALIZABLE；这样所有事务都只能顺序执行，自然不会因为并发有什么影响了，但是性能会下降许多。</p><p> 第二种方式，使用MVCC解决<strong>快照读幻读问题</strong>（如简单select），读取的不是最新的数据。维护一个字段作为version，这样可以控制到每次只能有一个人更新一个版本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id from table_xx where id = ? and version = V</span><br><span class="line">update id from table_xx where id = ? and version = V+1</span><br></pre></td></tr></table></figure><p> 第三种方式，如果需要读最新的数据，可以通过GapLock+Next-KeyLock可以解决<strong>当前读幻读问题</strong>，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id from table_xx where id &gt; 100 for update;</span><br><span class="line">select id from table_xx where id &gt; 100 lock in share mode;</span><br></pre></td></tr></table></figure><h4 id="4、RR和RC使用场景"><a href="#4、RR和RC使用场景" class="headerlink" title="4、RR和RC使用场景"></a><strong>4、RR和RC使用场景</strong></h4><p> 事务隔离级别RC(read commit)和RR（repeatable read）两种事务隔离级别基于多版本并发控制MVCC(multi-version concurrency control）来实现。</p><table><thead><tr><th></th><th>RC</th><th>RR</th></tr></thead><tbody><tr><td>实现</td><td>多条查询语句会创建多个不同的ReadView</td><td>仅需要一个版本的ReadView</td></tr><tr><td>粒度</td><td>语句级读一致性</td><td>事务级读一致性</td></tr><tr><td>准确性</td><td>每次语句执行时间点的数据</td><td>第一条语句执行时间点的数据</td></tr></tbody></table><h4 id="5、行锁，表锁，意向锁（事务隔离时用到的）"><a href="#5、行锁，表锁，意向锁（事务隔离时用到的）" class="headerlink" title="5、行锁，表锁，意向锁（事务隔离时用到的）"></a><strong>5、行锁，表锁，意向锁</strong>（事务隔离时用到的）</h4><p><strong>InnoDB⽀持⾏级锁(row-level locking)和表级锁,默认为⾏级锁</strong></p><p> InnoDB按照不同的分类的锁：</p><p> 共享&#x2F;排它锁(Shared and Exclusive Locks)：行级别锁，</p><p> 意向锁(Intention Locks)：表级别锁</p><p> 间隙锁(Gap Locks)：锁定一个区间</p><p> 记录锁(Record Locks)：锁定一个行记录</p><p><strong>表级锁：（串行化）</strong></p><p> Mysql中锁定 粒度最大的一种锁，对当前操作的整张表加锁，实现简单 ，资源消耗也比较少，加锁快，不会出现死锁 。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。</p><p><strong>行级锁：（RR、RC）</strong></p><p> Mysql中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。 InnoDB支持的行级锁，包括如下几种：</p><p> <strong>记录锁（Record Lock）:</strong> 对索引项加锁，锁定<strong>符合条件的行</strong>。其他事务不能修改和删除加锁项；</p><p> <strong>间隙锁（Gap Lock）:</strong> 对索引项之间的“间隙”加锁，锁定<strong>记录的范围</strong>，不包含索引项本身，其他事务不能在锁范围内插入数据。</p><p> <strong>Next-key Lock：</strong> 锁定索引项本身和索引范围。即Record Lock和Gap Lock的结合。可解决幻读问题。</p><p>InnoDB 支持多粒度锁（multiple granularity locking），它允许行级锁与表级锁共存，而意向锁就是其中的一种表锁。</p><p><strong>共享锁</strong>（ shared lock, S ）锁允许持有锁读取行的事务。加锁时将自己和子节点全加S锁，父节点直到表头全加IS锁</p><p><strong>排他锁</strong>（ exclusive lock， X ）锁允许持有锁修改行的事务。 加锁时将自己和子节点全加X锁，父节点直到表头全加IX锁</p><p><strong>意向共享锁</strong>（intention shared lock, IS）：事务有意向对表中的某些行加<strong>共享锁</strong>（S锁）</p><p><strong>意向排他锁</strong>（intention exclusive lock, IX）：事务有意向对表中的某些行加<strong>排他锁</strong>（X锁）</p><table><thead><tr><th>互斥性</th><th>共享锁（S）</th><th>排它锁（X）</th><th>意向共享锁IS</th><th>意向排他锁IX</th></tr></thead><tbody><tr><td>共享锁（S）</td><td>✅</td><td>❌</td><td>✅</td><td>❌</td></tr><tr><td>排它锁（X）</td><td>❌</td><td>❌</td><td>❌</td><td>❌</td></tr><tr><td>意向共享锁IS</td><td>✅</td><td>❌</td><td>✅</td><td>✅</td></tr><tr><td>意向排他锁IX</td><td>❌</td><td>❌</td><td>✅</td><td>✅</td></tr></tbody></table><h4 id="6、MVCC多版本并发控制"><a href="#6、MVCC多版本并发控制" class="headerlink" title="6、MVCC多版本并发控制"></a><strong>6、MVCC多版本并发控制</strong></h4><p> MVCC是一种多版本并发控制机制，通过事务的可见性看到自己预期的数据，能降低其系统开销.（RC和RR级别工作）</p><p> InnoDB的MVCC,是通过在每行记录后面保存系统版本号(可以理解为事务的ID)，每开始一个新的事务，系统版本号就会自动递增，事务开始时刻的系统版本号会作为事务的ID。这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的，防止幻读的产生。</p><p> 1.MVCC手段只适用于Msyql隔离级别中的读已提交（Read committed）和可重复读（Repeatable Read）.</p><p> 2.Read uncimmitted由于存在脏读，即能读到未提交事务的数据行，所以不适用MVCC.</p><p> 3.简单的select快照度不会加锁，删改及select for update等需要当前读的场景会加锁</p><p> 原因是MVCC的创建版本和删除版本只要在事务提交后才会产生。客观上，mysql使用的是乐观锁的一整实现方式，就是每行都有版本号，保存时根据版本号决定是否成功。Innodb的MVCC使用到的快照存储在Undo日志中，该日志通过回滚指针把一个数据行所有快照连接起来。</p><p><strong>版本链</strong></p><p>在InnoDB引擎表中，它的聚簇索引记录中有两个必要的隐藏列：</p><p><strong>trx_id</strong></p><p>这个id用来存储的每次对某条聚簇索引记录进行修改的时候的事务id。</p><p><strong>roll_pointer</strong></p><p>每次对哪条聚簇索引记录有修改的时候，都会把老版本写入undo日志中。这个roll_pointer就是存了一个指针，它指向这条聚簇索引记录的上一个版本的位置，通过它来获得上一个版本的记录信息。(注意插入操作的undo日志没有这个属性，因为它没有老版本)</p><p>每次修改都会在版本链中记录。**SELECT可以去版本链中拿记录，这就实现了读-写，写-读的并发执行，**提升了系统的性能。</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="1、Innodb和Myisam引擎"><a href="#1、Innodb和Myisam引擎" class="headerlink" title="1、Innodb和Myisam引擎"></a><strong>1、Innodb和Myisam引擎</strong></h4><p>**Myisam：**支持表锁，适合读密集的场景，不支持外键，不支持事务，索引与数据在不同的文件</p><p>**Innodb：**支持行、表锁，默认为行锁，适合并发场景，支持外键，支持事务，索引与数据同一文件</p><h4 id="2、哈希索引"><a href="#2、哈希索引" class="headerlink" title="2、哈希索引"></a><strong>2、哈希索引</strong></h4><p> 哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存执该值所在行数据的物理位置，因为使用散列算法，因此访问速度非常快，但是一个值只能对应一个hashCode，而且是散列的分布方式，<strong>因此哈希索引不支持范围查找和排序的功能</strong></p><h4 id="3、B-树索引"><a href="#3、B-树索引" class="headerlink" title="3、B+树索引"></a><strong>3、B+树索引</strong></h4><p><strong>优点：</strong></p><p> B+树的磁盘读写代价低，更少的查询次数，查询效率更加稳定，有利于对数据库的扫描</p><p> B+树是B树的升级版，B+树只有叶节点存放数据，其余节点用来索引。索引节点可以全部加入内存，增加查询效率，叶子节点可以做双向链表，从而<strong>提高范围查找的效率，增加的索引的范围</strong></p><p> 在大规模数据存储的时候，红黑树往往出现由于<strong>树的深度过大</strong>而造成磁盘IO读写过于频繁，进而导致效率低下的情况。所以，只要我们通过某种较好的树结构减少树的结构尽量减少树的高度，B树与B+树可以有多个子女，从几十到上千，可以降低树的高度。</p><p> <strong>磁盘预读原理</strong>：将一个节点的大小设为等于一个页，这样每个节点只需要一次I&#x2F;O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证<strong>一个节点物理上也存储在一个页里</strong>，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I&#x2F;O。</p><h4 id="4、创建索引"><a href="#4、创建索引" class="headerlink" title="4、创建索引"></a>4、创建索引</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE  [UNIQUE | FULLTEXT]  INDEX  索引名 ON  表名(字段名) [USING 索引方法]；</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">UNIQUE:可选。表示索引为唯一性索引。</span><br><span class="line">FULLTEXT:可选。表示索引为全文索引 加速大文本。</span><br><span class="line">NORMAL：可选。加速查询操作，包括精确匹配、范围查询和排序。</span><br><span class="line">SPATIAL：可选。专门用于处理地理空间数据，支持几何数据类型。</span><br><span class="line">INDEX和KEY:用于指定字段为索引，两者选择其中之一就可以了，作用是一样的。</span><br><span class="line">索引名:可选。给创建的索引取一个新名称。</span><br><span class="line">字段名1:指定索引对应的字段的名称，该字段必须是前面定义好的字段。</span><br><span class="line">注：索引方法默认使用B+TREE。</span><br></pre></td></tr></table></figure><h4 id="5、聚簇索引和非聚簇索引"><a href="#5、聚簇索引和非聚簇索引" class="headerlink" title="5、聚簇索引和非聚簇索引"></a><strong>5、聚簇索引和非聚簇索引</strong></h4><p> **聚簇索引：**将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据（存储的是表的主键）（<strong>主键索引</strong>）</p><p> **非聚簇索引：**将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置（<strong>辅助索引</strong>）</p><p>聚集索引和非聚集索引的区别：<br>1.聚集索引中的非叶子节点存储的是表的主键，非聚集索引的非叶子节点存储的是自己设置的索引字段对应的值(如果是联合索引，那就是联合索引的几个字段对应的值)<br>2.聚集索引的叶子节点，存储着当前表中每条记录的所有信息；非聚集索引的叶子节点，只存储当前记录对应的主键ID(也就是聚集索引的非叶子节点存储的值)</p><h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>在MySQL的InnoDB存储引擎中，聚簇索引是自动管理的，不需要显式创建。以下是几种情况：</p><ol><li><p><strong>使用主键创建聚簇索引</strong>：</p><ul><li>如果在表定义时创建了主键，那么该主键会自动成为聚簇索引。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE my_table (</span><br><span class="line">    id INT PRIMARY KEY,</span><br><span class="line">    name VARCHAR(50),</span><br><span class="line">    age INT</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>id</code>列是主键，因此会自动成为聚簇索引。</p></li><li><p><strong>没有主键但有唯一非空索引</strong>：</p><ul><li>如果表中没有主键，但有一个唯一非空索引，那么这个唯一索引将成为聚簇索引。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE my_table (</span><br><span class="line">    id INT NOT NULL,</span><br><span class="line">    name VARCHAR(50) UNIQUE NOT NULL,</span><br><span class="line">    age INT</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>name</code>列是唯一且非空的，因此会成为聚簇索引。</p></li><li><p><strong>没有主键和唯一非空索引</strong>：</p><ul><li>如果表中既没有主键，也没有唯一非空索引，InnoDB会自动创建一个隐藏的聚簇索引。</li></ul></li></ol><h4 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h4><p>非聚簇索引需要显式创建，可以在创建表时定义，也可以在表创建后添加。</p><ol><li><p><strong>在创建表时定义非聚簇索引</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE my_table (</span><br><span class="line">    id INT PRIMARY KEY,</span><br><span class="line">    name VARCHAR(50),</span><br><span class="line">    age INT,</span><br><span class="line">    INDEX (name)</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>name</code>列上的索引是一个非聚簇索引。</p></li><li><p><strong>在表创建后添加非聚簇索引</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_name ON my_table(name);</span><br></pre></td></tr></table></figure><p>这个命令在<code>my_table</code>表的<code>name</code>列上创建了一个非聚簇索引。</p></li></ol><h4 id="6、最左前缀问题"><a href="#6、最左前缀问题" class="headerlink" title="6、最左前缀问题"></a>6、最左前缀问题</h4><p> 最左前缀原则主要使用在联合索引中，联合索引的B+Tree是按照第一个关键字进行索引排列的。</p><p> 联合索引的底层是一颗B+树，只不过联合索引的B+树节点中存储的是键值。由于构建一棵B+树只能根据一个值来确定索引关系，所以数据库依赖联合索引最左的字段来构建。</p><p> 采用&gt;、&lt;等进行匹配都会导致后面的列无法走索引，因为通过以上方式匹配到的数据是不可知的。</p><p><strong>创建索引时选择性高的列放在前面，以提高索引的效率。</strong></p><h3 id="SQL查询"><a href="#SQL查询" class="headerlink" title="SQL查询"></a>SQL查询</h3><h4 id="1、SQL语句的执行过程"><a href="#1、SQL语句的执行过程" class="headerlink" title="1、SQL语句的执行过程"></a><strong>1、SQL语句的执行过程</strong></h4><p><strong>查询语句：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student  A where A.age=&#x27;18&#x27; and A.name=&#x27;张三&#x27;;</span><br></pre></td></tr></table></figure><p><a href="https://camo.githubusercontent.com/5be2a1549f0d5ac83e11e42bdbd2d94f10da13bb82baf6e593ee3f023282ed62/687474703a2f2f73302e6c677374617469632e636f6d2f692f696d616765322f4d30312f38422f30462f43676f744f56313479534b414d786f6841414832564863417a6b453631322e706e67"><img src="https://camo.githubusercontent.com/5be2a1549f0d5ac83e11e42bdbd2d94f10da13bb82baf6e593ee3f023282ed62/687474703a2f2f73302e6c677374617469632e636f6d2f692f696d616765322f4d30312f38422f30462f43676f744f56313479534b414d786f6841414832564863417a6b453631322e706e67" alt="img"></a></p><p>结合上面的说明，我们分析下这个语句的执行流程：</p><p>①通过客户端&#x2F;服务器通信协议与 MySQL 建立连接。并查询是否有权限</p><p>②Mysql8.0之前开看是否开启缓存，开启了 Query Cache 且命中完全相同的 SQL 语句，则将查询结果直接返回给客户端；</p><p>③由解析器进行语法语义解析，并生成解析树。如查询是select、表名tb_student、条件是id&#x3D;’1’</p><p>④查询优化器生成执行计划。根据索引看看是否可以优化</p><p>⑤查询执行引擎执行 SQL 语句，根据存储引擎类型，得到查询结果。若开启了 Query Cache，则缓存，否则直接返回。</p><h4 id="2、回表查询和覆盖索引"><a href="#2、回表查询和覆盖索引" class="headerlink" title="2、回表查询和覆盖索引"></a><strong>2、回表查询和覆盖索引</strong></h4><p>解释：</p><p><a href="https://blog.csdn.net/CPLASF_/article/details/108799381">https://blog.csdn.net/CPLASF_/article/details/108799381</a></p><p><a href="https://www.cnblogs.com/Courage129/p/14166775.html">https://www.cnblogs.com/Courage129/p/14166775.html</a></p><p><strong>普通索引</strong>（唯一索引+联合索引+全文索引）需要扫描两遍索引树</p><p>（1）先通过普通索引定位到主键值id&#x3D;5；</p><p>（2）在通过聚集索引定位到行记录；</p><p>这就是所谓的<strong>回表查询</strong>，先定位主键值，再定位行记录，它的性能较扫一遍索引树更低。</p><p><strong>覆盖索引</strong>：主键索引&#x3D;&#x3D;聚簇索引&#x3D;&#x3D;覆盖索引</p><p> 如果where条件的列和返回的数据在一个索引中，那么不需要回查表，那么就叫覆盖索引。</p><p><strong>实现覆盖索引</strong>：常见的方法是，将被查询的字段，建立到联合索引里去。</p><h4 id="3、Explain及优化"><a href="#3、Explain及优化" class="headerlink" title="3、Explain及优化"></a>3、Explain及优化</h4><p>参考：<a href="https://www.jianshu.com/p/8fab76bbf448">https://www.jianshu.com/p/8fab76bbf448</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from staff;</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-------+</span><br><span class="line">|  1 | SIMPLE      | staff | ALL  | NULL          | 索引  | NULL    | NULL |    2 | NULL  |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-------+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure><p><strong>索引优化：</strong></p><p> ①最左前缀索引：like只用于’string%’，语句中的&#x3D;和in会动态调整顺序</p><p> ②唯一索引：唯一键区分度在0.1以上</p><p> ③无法使用索引：!&#x3D; 、is null 、 or、&gt;&lt; 、（<strong>5.7以后根据数量自动判定）in 、not in</strong></p><p> ④联合索引：避免select * ，查询列使用覆盖索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT uid From user Where gid = 2 order by ctime asc limit 10</span><br><span class="line">ALTER TABLE user add index idx_gid_ctime_uid(gid,ctime,uid) #创建联合覆盖索引，避免回表查询</span><br></pre></td></tr></table></figure><p><strong>语句优化：</strong></p><p> ①CHAR vs. VARCHAR</p><p>​<strong>CHAR</strong>：固定长度字符类型，查询效率较高，因为每个值占用的空间是固定的。适合存储定长字符串。</p><p>​<strong>VARCHAR</strong>：可变长度字符类型，第一个字节记录数据长度（在MySQL 5.0及以下版本中，第一个或两个字节记录长度，取决于最大长度）。存储可变长度的字符串更节省空间，但在查询时由于长度不固定，可能稍慢于CHAR。</p><p> ②应该针对Explain中Rows增加索引</p><p> ③group&#x2F;order by字段均会涉及索引</p><p> ④Limit中分页查询会随着start值增大而变缓慢，通过子查询+表连接解决</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mytbl <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">100000</span>,<span class="number">10</span>  改进后的<span class="keyword">SQL</span>语句如下：</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mytbl <span class="keyword">where</span> id <span class="operator">&gt;=</span> ( <span class="keyword">select</span> id <span class="keyword">from</span> mytbl <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">100000</span>,<span class="number">1</span> ) limit <span class="number">10</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mytbl <span class="keyword">inner</span> ori <span class="keyword">join</span> (<span class="keyword">select</span> id <span class="keyword">from</span> mytbl <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">100000</span>,<span class="number">10</span>) <span class="keyword">as</span> tmp <span class="keyword">on</span> tmp.id<span class="operator">=</span>ori.id;</span><br></pre></td></tr></table></figure><p> ⑤count会进行全表扫描，如果估算可以使用explain</p><p> ⑥delete删除表时会增加大量undo和redo日志， 确定删除可使用trancate</p><p>​</p><p><strong>表结构优化：</strong></p><p> ①单库不超过200张表</p><p> ②单表不超过500w数据</p><p> ③单表不超过40列</p><p> ④单表索引不超过5个</p><p><strong>数据库范式</strong> ：</p><p> ①第一范式（1NF）列不可分割</p><p> ②第二范式（2NF）属性完全依赖于主键 [ 消除部分子函数依赖 ]</p><p> ③第三范式（3NF）属性不依赖于其它非主属性 [ 消除传递依赖 ]</p><p>数据库范式（Normal Forms）是数据库设计中的重要概念，通过规范化规则确保数据库结构的合理性和有效性。以下是关于数据库第一范式（1NF）、第二范式（2NF）和第三范式（3NF）的详细解释：</p><h5 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h5><p><strong>定义</strong>：表中的每一列都是原子的，即每一个列值都是不可再分的基本数据项。</p><p><strong>特点</strong>：</p><ul><li>每一列只能包含一个值，不能有重复的列。</li><li>表中的每一个字段必须是单一值，不允许有表或数组类型的字段。</li></ul><p><strong>示例</strong>：</p><p>不符合第一范式的表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plaintext复制代码| StudentID | Name       | Subjects        |</span><br><span class="line">|-----------|------------|-----------------|</span><br><span class="line">| 1         | Alice      | Math, Science   |</span><br><span class="line">| 2         | Bob        | Math, History   |</span><br></pre></td></tr></table></figure><p>符合第一范式的表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plaintext复制代码| StudentID | Name       | Subject   |</span><br><span class="line">|-----------|------------|-----------|</span><br><span class="line">| 1         | Alice      | Math      |</span><br><span class="line">| 1         | Alice      | Science   |</span><br><span class="line">| 2         | Bob        | Math      |</span><br><span class="line">| 2         | Bob        | History   |</span><br></pre></td></tr></table></figure><h5 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h5><p><strong>定义</strong>：在满足第一范式的基础上，表中的每一个非主键列必须完全依赖于主键，不能依赖于主键的一部分。</p><p><strong>特点</strong>：</p><ul><li>必须已经满足1NF。</li><li>所有非主键列都完全依赖于主键，消除部分依赖。</li></ul><p><strong>示例</strong>：</p><p>不符合第二范式的表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plaintext复制代码| StudentID | CourseID | StudentName | CourseName |</span><br><span class="line">|-----------|----------|-------------|------------|</span><br><span class="line">| 1         | 101      | Alice       | Math       |</span><br><span class="line">| 2         | 102      | Bob         | History    |</span><br></pre></td></tr></table></figure><p>符合第二范式的表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">plaintext复制代码Students</span><br><span class="line">| StudentID | StudentName |</span><br><span class="line">|-----------|-------------|</span><br><span class="line">| 1         | Alice       |</span><br><span class="line">| 2         | Bob         |</span><br><span class="line"></span><br><span class="line">Courses</span><br><span class="line">| CourseID | CourseName |</span><br><span class="line">|----------|------------|</span><br><span class="line">| 101      | Math       |</span><br><span class="line">| 102      | History    |</span><br><span class="line"></span><br><span class="line">Enrollments</span><br><span class="line">| StudentID | CourseID |</span><br><span class="line">|-----------|----------|</span><br><span class="line">| 1         | 101      |</span><br><span class="line">| 2         | 102      |</span><br></pre></td></tr></table></figure><h5 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h5><p><strong>定义</strong>：在满足第二范式的基础上，表中的每一个非主键列必须直接依赖于主键，而不是通过其他非主键列传递依赖于主键。</p><p><strong>特点</strong>：</p><ul><li>必须已经满足2NF。</li><li>消除传递依赖，即非主键列之间不应该有依赖关系，所有非主键列都应该直接依赖于主键。</li></ul><p><strong>示例</strong>：</p><p>不符合第三范式的表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plaintext复制代码| StudentID | StudentName | Advisor | AdvisorOffice |</span><br><span class="line">|-----------|-------------|---------|---------------|</span><br><span class="line">| 1         | Alice       | Dr. Smith | Room 101     |</span><br><span class="line">| 2         | Bob         | Dr. Jones | Room 102     |</span><br></pre></td></tr></table></figure><p>符合第三范式的表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">plaintext复制代码Students</span><br><span class="line">| StudentID | StudentName | AdvisorID |</span><br><span class="line">|-----------|-------------|-----------|</span><br><span class="line">| 1         | Alice       | 201       |</span><br><span class="line">| 2         | Bob         | 202       |</span><br><span class="line"></span><br><span class="line">Advisors</span><br><span class="line">| AdvisorID | AdvisorName | AdvisorOffice |</span><br><span class="line">|-----------|-------------|---------------|</span><br><span class="line">| 201       | Dr. Smith   | Room 101      |</span><br><span class="line">| 202       | Dr. Jones   | Room 102      |</span><br></pre></td></tr></table></figure><p>通过以上三个范式的规范化，可以避免数据冗余，提高数据的一致性和完整性。然而，在实际应用中，有时为了性能考虑，可能会适当地进行反规范化。了解和运用这些范式能够帮助设计出更高效、易维护的数据库结构。</p><p><strong>配置优化：</strong></p><p> 配置连接数、禁用Swap、增加内存、升级SSD硬盘</p><h4 id="4、JOIN查询"><a href="#4、JOIN查询" class="headerlink" title="4、JOIN查询"></a>4、JOIN查询</h4><p><a href="https://camo.githubusercontent.com/9ce7c502faf2ab3da4869e86c90b69fb9ef9d3d41d07e0847c4a642199eeaf56/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3237362f3738302f323736373830373538392d356331323235383661323363345f61727469636c6578"><img src="https://camo.githubusercontent.com/9ce7c502faf2ab3da4869e86c90b69fb9ef9d3d41d07e0847c4a642199eeaf56/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3237362f3738302f323736373830373538392d356331323235383661323363345f61727469636c6578" alt="img"></a></p><p><strong>left join(左联接)</strong> 返回包括左表中的所有记录和右表中关联字段相等的记录（返回左表中的所有行，无论右表中是否有匹配的行。如果右表没有匹配的行，右表的对应列将返回 <code>NULL</code>。）</p><p><strong>right join(右联接)</strong> 返回包括右表中的所有记录和左表中关联字段相等的记录（返回右表中的所有行，无论左表中是否有匹配的行。如果左表没有匹配的行，左表的对应列将返回 <code>NULL</code>。）</p><p><strong>inner join(等值连接)</strong> 只返回两个表中关联字段相等的行</p><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a><strong>集群</strong></h3><h4 id="1、主从复制过程"><a href="#1、主从复制过程" class="headerlink" title="1、主从复制过程"></a>1、主从复制过程</h4><p><strong>MySQl主从复制：</strong></p><ul><li><strong>原理</strong>：将主服务器的binlog日志复制到从服务器上执行一遍，达到主从数据的一致状态。</li><li><strong>过程</strong>：从库开启一个I&#x2F;O线程，向主库请求Binlog日志。主节点开启一个binlog dump线程，检查自己的二进制日志，并发送给从节点；从库将接收到的数据保存到中继日志（Relay log）中，另外开启一个SQL线程，把Relay中的操作在自身机器上执行一遍</li><li>优点<ul><li>作为备用数据库，并且不影响业务</li><li>可做读写分离，一个写库，一个或多个读库，在不同的服务器上，充分发挥服务器和数据库的性能，但要保证数据的一致性</li></ul></li></ul><p>**binlog记录格式：**statement、row、mixed</p><p> 基于语句statement的复制、基于行row的复制、基于语句和行（mix）的复制。其中基于row的复制方式更能保证主从库数据的一致性，但日志量较大，在设置时考虑磁盘的空间问题</p><h4 id="2、数据一致性问题及解决方案"><a href="#2、数据一致性问题及解决方案" class="headerlink" title="2、数据一致性问题及解决方案"></a>2、数据一致性问题及解决方案</h4><p>“主从复制有延时”，这个延时期间读取从库，可能读到不一致的数据。</p><p><strong>缓存记录写key法：</strong></p><p> 在cache里记录哪些记录发生过的写请求，来路由读主库还是读从库</p><p><strong>异步复制：</strong></p><p> 在异步复制中，主库执行完操作后，写入binlog日志后，就返回客户端，这一动作就结束了，并不会验证从库有没有收到，完不完整，所以这样可能<strong>会造成数据的不一致</strong>。</p><p><strong>半同步复制：</strong></p><p> 当主库每提交一个事务后，不会立即返回，而是等待其中一个从库接收到Binlog并成功写入Relay-log中才返回客户端，通过一份在主库的Binlog，另一份在其中一个从库的Relay-log，可以保证了数据的安全性和一致性。</p><p><strong>全同步复制：</strong></p><p> 指当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。因为需要等待所有从库执行完该事务才能返回，所以全同步复制的<strong>性能必然会收到严重的影响</strong>。</p><h4 id="3、集群架构"><a href="#3、集群架构" class="headerlink" title="3、集群架构"></a>3、集群架构</h4><p><strong>Keepalived + VIP + MySQL 主从&#x2F;双主</strong></p><p> 当写节点 Master db1 出现故障时，由 MMM Monitor 或 Keepalived 触发切换脚本，将 VIP 漂移到可用的 Master db2 上。当出现网络抖动或网络分区时，MMM Monitor 会误判，严重时来回切换写 VIP 导致集群双写，当数据复制延迟时，应用程序会出现数据错乱或数据冲突的故障。有效避免单点失效的架构就是<strong>采用共享存储</strong>，单点故障切换可以通过<strong>分布式哨兵系统监控</strong>。</p><p><a href="https://camo.githubusercontent.com/c5ba81924cc27fec84a1b232d67053d3bbad3569607c8162fbb8338acb0856e0/687474703a2f2f73302e6c677374617469632e636f6d2f692f696d616765322f4d30312f38392f34382f43676f42356c31324b7547414c662d634141477548566d4d6b48733734332e706e67"><img src="https://camo.githubusercontent.com/c5ba81924cc27fec84a1b232d67053d3bbad3569607c8162fbb8338acb0856e0/687474703a2f2f73302e6c677374617469632e636f6d2f692f696d616765322f4d30312f38392f34382f43676f42356c31324b7547414c662d634141477548566d4d6b48733734332e706e67" alt="img"></a></p><p>**架构选型：**MMM 集群 -&gt; MHA集群 -&gt; MHA+Arksentinel。</p><p><a href="https://camo.githubusercontent.com/8debfd1e74e7b81fec83c5f736263c63be82db1b90ef843ff77cd149f3a75eaf/687474703a2f2f73302e6c677374617469632e636f6d2f692f696d616765322f4d30312f38392f36382f43676f744f5631324b754b41655f484f4141426c2d7752415461303737322e706e67"><img src="https://camo.githubusercontent.com/8debfd1e74e7b81fec83c5f736263c63be82db1b90ef843ff77cd149f3a75eaf/687474703a2f2f73302e6c677374617469632e636f6d2f692f696d616765322f4d30312f38392f36382f43676f744f5631324b754b41655f484f4141426c2d7752415461303737322e706e67" alt="img"></a></p><h4 id="4、故障转移和恢复"><a href="#4、故障转移和恢复" class="headerlink" title="4、故障转移和恢复"></a>4、故障转移和恢复</h4><p><strong>转移方式及恢复方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 虚拟IP或DNS服务 （Keepalived +VIP/DNS  和 MMM 架构）</span><br></pre></td></tr></table></figure><p> 问题：在虚拟 IP 运维过程中，刷新ARP过程中有时会出现一个 VIP 绑定在多台服务器同时提供连接的问题。这也是为什么要避免使用 Keepalived+VIP 和 MMM 架构的原因之一，因为它处理不了这类问题而导致集群多点写入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. 提升备库为主库（MHA、QMHA）</span><br></pre></td></tr></table></figure><p> 尝试将原 Master 设置 read_only 为 on，避免集群多点写入。借助 binlog server 保留 Master 的 Binlog；当出现数据延迟时，再提升 Slave 为新 Master 之前需要进行数据补齐，否则会丢失数据。</p><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><h4 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h4><h5 id="如何进行分库分表"><a href="#如何进行分库分表" class="headerlink" title="如何进行分库分表"></a>如何进行分库分表</h5><blockquote><p><strong>分表</strong>用户id进行分表，每个表控制在300万数据。</p><p><strong>分库</strong>根据业务场景和地域分库，每个库并发不超过2000</p></blockquote><p><strong>Sharding-jdbc</strong> 这种 client 层方案的<strong>优点在于不用部署，运维成本低，不需要代理层的二次转发请求，性能很高</strong>，但是各个系统都需要<strong>耦合</strong> Sharding-jdbc 的依赖，升级比较麻烦</p><p><strong>Mycat</strong> 这种 proxy 层方案的<strong>缺点在于需要部署</strong>，自己运维一套中间件，运维成本高，但是<strong>好处在于对于各个项目是透明的</strong>，如果遇到升级之类的都是自己中间件那里搞就行了</p><p><strong>水平拆分</strong>：一个表放到多个库，分担高并发，加快查询速度</p><ul><li><strong>id</strong>保证业务在关联多张表时可以在同一库上操作</li><li><strong>range</strong>方便扩容和数据统计</li><li><strong>hash</strong>可以使得数据更加平均</li></ul><p><strong>垂直拆分</strong>：一个表拆成多个表，可以将一些冷数据拆分到冗余库中</p><blockquote><p>不是写瓶颈优先进行分表</p></blockquote><ul><li>分库数据间的数据无法再通过数据库直接查询了。会产生深分页的问题</li><li>分库越多，出现问题的可能性越大，维护成本也变得更高。</li><li>分库后无法保障跨库间事务，只能借助其他中间件实现最终一致性。</li></ul><p>分库首先需考虑满足业务最核心的场景：</p><p>1、订单数据按<strong>用户</strong>分库，可以<strong>提升用户的全流程体验</strong></p><p>2、超级客户导致<strong>数据倾斜</strong>可以使用最细粒度唯一标识进行hash拆分</p><p>3、按照最细粒度如订单号拆分以后，数据库就无法进行单库排重了</p><p>三个问题：</p><ul><li><p>富查询：采用分库分表之后，如何满足跨越分库的查询？<strong>使用ES</strong>的宽表</p><p>借助<strong>分库网关+分库业务</strong>虽然能够实现<strong>多维度查询的能力</strong>，但整体上性能不佳且对正常的写入请求有一定的影响。业界应对<strong>多维度实时查询</strong>的最常见方式便是借助 <strong>ElasticSearch</strong></p></li><li><p>数据倾斜：数据分库基础上再进行分表</p></li><li><p>分布式事务：跨多库的修改及多个微服务间的写操作导致的分布式事务问题？</p></li><li><p>深分页问题：按游标查询，或者叫每次查询都带上上一次查询经过排序后的最大 ID</p></li></ul><h3 id="查看当前线程操作"><a href="#查看当前线程操作" class="headerlink" title="查看当前线程操作"></a>查看当前线程操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">法一</span><br><span class="line"><span class="keyword">SHOW</span> PROCESSLIST;</span><br><span class="line">法二</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.PROCESSLIST;</span><br></pre></td></tr></table></figure><p><strong>完整查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">FULL</span> PROCESSLIST;</span><br></pre></td></tr></table></figure><p><strong>终止查询：</strong></p><ul><li><p>仅终止查询但不终止连接：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KILL QUERY Id;</span><br></pre></td></tr></table></figure></li></ul><p><strong>终止线程：</strong></p><ul><li><p>终止整个线程，包括连接：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KILL Id;</span><br></pre></td></tr></table></figure></li></ul><h3 id="表级锁和行级锁了解吗？有什么区别？"><a href="#表级锁和行级锁了解吗？有什么区别？" class="headerlink" title="表级锁和行级锁了解吗？有什么区别？"></a>表级锁和行级锁了解吗？有什么区别？</h3><ol><li>表级锁：粒度大，消耗资源少，加锁快，不会出现死锁，针对非索引字段，但是触发锁冲突概率高且并发下效率低。innodb和myisam都支持。</li><li>行级锁：粒度小，消耗资源大，加锁慢，会出现死锁，针对索引字段，但是并发下效率高，innodb支持</li></ol><h3 id="行级锁的使用有什么注意事项？"><a href="#行级锁的使用有什么注意事项？" class="headerlink" title="行级锁的使用有什么注意事项？"></a>行级锁的使用有什么注意事项？</h3><p>只针对索引字段生效，所以当update，delete时where子句没有命中索引的话会失效而会使用表级锁。</p><h3 id="InnDB有那些行级锁"><a href="#InnDB有那些行级锁" class="headerlink" title="InnDB有那些行级锁"></a>InnDB有那些行级锁</h3><ol><li>记录锁（record lock）：只锁住当前记录</li><li>间隙锁（gap lock）：锁住一个范围，不包括当前记录</li><li>临键锁 (next-key lock)：Record Lock+Gap Lock。锁住一个范围，包括当前记录。主要是为了解决幻读问题。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li></ol><p>在InnoDB默认的隔离级别（不可重复读）下，会有幻读的问题。因此当执行update，delete语句时，如果where子句不是命中<strong>唯一索引</strong>的话，会使用next-key lock方式。防止其他事务修改该记录，能保证当前事务执行时不会产生幻读问题。</p><p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20240722232804342.png" alt="image-20240722232804342"></p><h3 id="共享锁和排他锁呢？"><a href="#共享锁和排他锁呢？" class="headerlink" title="共享锁和排他锁呢？"></a>共享锁和排他锁呢？</h3><p><strong>不论是表级锁还是行级锁</strong>，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类</p><ul><li>共享锁：读锁S锁，事务在读取记录时会获取共享锁，允许多个事务同时获取（锁兼容）</li><li>排他锁：写锁X锁。事务写记录时获取，不允许事务同时获取（锁不兼容）</li></ul><p>排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。</p><table><thead><tr><th align="left"></th><th align="left">S 锁</th><th align="left">X 锁</th></tr></thead><tbody><tr><td align="left">S 锁</td><td align="left">不冲突</td><td align="left">冲突</td></tr><tr><td align="left">X 锁</td><td align="left">冲突</td><td align="left">冲突</td></tr></tbody></table><p>由于 MVCC（多版本并发控制） 的存在，对于一般的 <code>SELECT</code> 语句，InnoDB 不会加任何锁。不过， 你可以通过以下语句显式加共享锁或排他锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 共享锁 可以在 MySQL <span class="number">5.7</span> 和 MySQL <span class="number">8.0</span> 中使用</span><br><span class="line"><span class="keyword">SELECT</span> ... LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"># 共享锁 可以在 MySQL <span class="number">8.0</span> 中使用</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> SHARE;</span><br><span class="line"># 排他锁</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><h3 id="意向锁有什么作用"><a href="#意向锁有什么作用" class="headerlink" title="意向锁有什么作用?"></a>意向锁有什么作用?</h3><p>在并发下，如果有事务想要获取表级锁需要去判断该表是否有行级锁（事务一想要加表级锁并获取排他锁（写），而表中已经有事务二对一些行加了行级锁并获取了排他锁，这样事务一就会阻塞了）。需要一行行排查，效率底下。为了实现多粒度锁机制，所以有了意向锁，用来协调表锁和行锁。</p><p>意向锁是表锁：</p><ul><li>意向共享锁（IS）：当事务想对一些行加共享锁时，会对表加意向共享锁</li><li>意向排他锁（IX）：当事务想对一些行加排他锁时，会对表加意向排他锁</li></ul><p>意向共享锁和意向排他锁两两互相兼容</p><p>意向锁之间是互相兼容的。（不同事务锁住不同行就有会多个IS或者IX）</p><table><thead><tr><th></th><th>IS 锁</th><th>IX 锁</th></tr></thead><tbody><tr><td>IS 锁</td><td>兼容</td><td>兼容</td></tr><tr><td>IX 锁</td><td>兼容</td><td>兼容</td></tr></tbody></table><p>意向锁和共享锁和排它锁互斥（表级别的共享锁排他锁）</p><table><thead><tr><th>IS 锁</th><th>IX 锁</th><th></th></tr></thead><tbody><tr><td>S 锁</td><td>兼容</td><td>互斥</td></tr><tr><td>X 锁</td><td>互斥</td><td>互斥</td></tr></tbody></table><h3 id="多个人同时往表里插数据，数据库表主键是自增，能正常执行吗？"><a href="#多个人同时往表里插数据，数据库表主键是自增，能正常执行吗？" class="headerlink" title="多个人同时往表里插数据，数据库表主键是自增，能正常执行吗？"></a>多个人同时往表里插数据，数据库表主键是自增，能正常执行吗？</h3><p>可以的，在多用户并发插入数据的情况下，MySQL InnoDB使用自增锁（auto-increment lock）来确保自增主键的唯一性。自增锁有两种模式：</p><p><strong>传统模式（Traditional Mode）</strong>：</p><ul><li>自增锁是在每次插入新行时获取，并在插入操作完成后立即释放。这确保了自增列值的连续性和唯一性。传统模式下，所有并发插入都会被串行化，以确保自增值的正确性。</li></ul><p><strong>互斥锁模式（Interleaved Mode）</strong>：</p><ul><li>自MySQL 5.1.22起，引入了互斥锁模式。它使用轻量级的互斥锁（mutex），允许多个事务同时分配自增值，而不需要完全串行化。这提高了并发插入的性能。互斥锁模式下，自增值可能不连续，但仍然是唯一的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2022/06/01/JAVA/"/>
      <url>/2022/06/01/JAVA/</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><span id="more"></span><h2 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h2><p><strong>封装，继承，多态</strong></p><ul><li><strong>封装</strong>：将数据和基于数据的操作抽象化成一个对象并对其属性进行私有化，同时提供一些能被外界访问属性的方法；</li><li><strong>继承</strong>：子类扩展新的功能，并复用父类的属性和功能，单继承，多实现、</li><li><strong>多态</strong>：一个父类可以有多个子类（对同一方法进行多次重写），一个接口可以有多个实现，一个类可以实现多个接口（对接口进行不同的实现）</li></ul><h2 id="java与C-区别（都是面向对象）"><a href="#java与C-区别（都是面向对象）" class="headerlink" title="java与C++区别（都是面向对象）"></a>java与C++区别（都是面向对象）</h2><p>C++: 多继承，有指针概念可以手动管理内存</p><p>java：单继承但是有多实现，由JVM自动管理内存</p><h2 id="多态实现原理"><a href="#多态实现原理" class="headerlink" title="多态实现原理"></a>多态实现原理</h2><p>动态绑定，即在运行时才把方法调用与方法实现关联起来。</p><p><strong>静态绑定</strong>：编译时就绑定，比如重载。<br><strong>动态绑定</strong>：运行时绑定，比如重写，实现。</p><h2 id="static和final关键字"><a href="#static和final关键字" class="headerlink" title="static和final关键字"></a>static和final关键字</h2><ul><li><strong>static</strong>：修饰属性，方法（只会在堆中创建一份共享，随着类的加载而加载）</li><li><strong>final</strong>：修饰变量（修饰基础类型就不可被修改，修饰引用类型就不可被指向另一个对象），方法（锁定方法防止被子类重写，private方法隐式设置了final），类（不能被继承且所有方法被指定为final）</li></ul><h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><p><strong>抽象类</strong>：abstract修饰的类，即包含抽象方法的类。（有抽象方法的类一定是抽象类，但是抽象类不是一定要有抽象方法）；只能被继承（单继承）所以不能被final修饰；不能被实例化（因为可能有没提供完整的实现的方法）</p><p><strong>接口</strong>：interface修饰，属于抽象类型的类。。可以被多实现。不可以被实例化（有没提供完整的实现的方法）</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><h4 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a><strong>相同点：</strong></h4><ol><li>都不能被实例化</li><li>都可以定义抽象方法且子类必须重写</li></ol><h4 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a><strong>不同点：</strong></h4><ol><li>抽象类可以有普通方法，接口只能有抽象方法（默认是public abstract修饰，在java8之后，能存在被default和static修饰的存在方法体的方法）</li><li>抽象类有构造方法（可以初始化对象状态），接口没有</li><li>抽象类只能被单继承，接口可以被多实现</li><li>抽象类可以有不同修饰的成员变量，接口默认都是public static final 修饰</li></ol><h3 id="适合场景"><a href="#适合场景" class="headerlink" title="适合场景"></a><strong>适合场景</strong></h3><p><strong>抽象类</strong>：</p><pre><code>1. 需要有基础功能并且基础功能会经常改变，那就使用抽象类，改变抽象类的基础方法就能让所有子类同时改变，达到解耦的目的。（如果是接口就需要改变每一个实现类中的方法）1. 拥有一些方法（但不再乎其如何实现）并且想让它们中的一些有默认实现，还想拥有实例变量，需要构造方法。</code></pre><p><strong>接口</strong>：</p><ol><li>需要多实现的场景（更多需要从业务出发，每个接口涉及不同业务，但是实现类需要涉及两个业务）</li><li>需要解耦更加彻底的场景。根据不同条件获取不同实现的场景，用接口可以实现解耦（调用类只需要注入接口不要关心具体要用那个实现类）</li></ol><h2 id="泛型与泛型擦除"><a href="#泛型与泛型擦除" class="headerlink" title="泛型与泛型擦除"></a>泛型与泛型擦除</h2><p>泛型： 参数化类型，将所需要的类型参数化，用<T>来声明一个类型参数。可以用于类、接口、方法的创建</p><p>泛型擦除：java泛型是伪泛型，虽然使用泛型的时候加上类型参数（比如ArrayList<Integer> list &#x3D; new ArrayList<Integer>();）但是编译生成字节码的时候会类型擦除（实际上变成了List）。而由泛型附加的类型信息对 JVM 来说是不可见的。因此说是伪泛型。可以通过反射添加其它类型元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">list.add(1);  //这样调用 add 方法只能存储整形，因为泛型类型的实例为 Integer</span><br><span class="line"></span><br><span class="line">//使用反射想Integer类型中加入String的记录</span><br><span class="line">list.getClass().getMethod(&quot;add&quot;, Object.class).invoke(list, &quot;asd&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p><strong>概念</strong>：在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且都能够调用它的任意一个方法；</p><p><strong>如何得到Class的实例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.类名.class(就是一份字节码)</span><br><span class="line">2.Class.forName(String className);根据一个类的全限定名来构建Class对象</span><br><span class="line">3.每一个对象多有getClass()方法:obj.getClass();返回对象的真实类型</span><br></pre></td></tr></table></figure><p><strong>适合场景：</strong></p><ol><li><strong>自定义注解</strong>：对被注解对象的操作需要用反射来执行</li><li><strong>动态代理</strong>：AOP中拦截方法使用动态代理就需要反射</li><li><strong>开发通用框架</strong></li></ol><h2 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h2><p><strong>Throwable</strong>是超类，往下分为<strong>Error</strong>和<strong>Exception</strong><br>一般来讲，程序无法捕获的异常就是Error，如JVM内部错误<br>Exception是由程序产生的，分为运行时异常（空指针，数组下标越界等）和编译时异常（语法错误等）</p><p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20240510220456126.png" alt="image-20240510220456126"></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="ArrayList和LinkedList"><a href="#ArrayList和LinkedList" class="headerlink" title="ArrayList和LinkedList"></a>ArrayList和LinkedList</h3><p>​<strong>ArrayList：</strong></p><p>​底层为数组（一段连续的内存），支持对元素的快速访问，适合随机访问，不合适插入和删除（移动元素代价高）。默认初始大小为10（初始化时容量为0，当有第一个数据进来才会初始化空间为10），扩容机制是扩大到当前的1.5倍，然后移动到新数组，移动方法：Array.copyof()。</p><p>​<strong>LinkedList：</strong></p><p>​底层为链表（不需要连续的内存），适合数据插入和删除。可以当作堆栈，队列使用（出栈入栈对应插入删除）</p><p><strong>均为线程不安全</strong></p><h4 id="实现线程安全："><a href="#实现线程安全：" class="headerlink" title="实现线程安全："></a>实现线程安全：</h4><ol><li>使用原生的Vector，但是效率很低。底层通过synchronizedList</li><li>使用<strong>CopyOnWriteArrayList</strong>，<strong>写时加锁</strong>，使用了一种叫写时复制的方法；读操作是可以不用加锁的，推荐使用</li></ol><h4 id="fail-fast"><a href="#fail-fast" class="headerlink" title="fail-fast"></a><strong>fail-fast</strong></h4><p>快速失败机制：</p><ul><li><p>在迭代器遍历元素的过程中，如果集合的结构（modCount）被改变的话，就会抛出异常ConcurrentModificationException，防止继续遍历。这就是所谓的快速失败机制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 10; i &lt; 100; i++)&#123;</span><br><span class="line">        map.put(i, i);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    for(int i = 0; i &lt; 20; i++)&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line">    int temp = 0;</span><br><span class="line">    while(it.hasNext())&#123;</span><br><span class="line">        if(temp == 3)&#123;</span><br><span class="line">            temp++;</span><br><span class="line">            list.remove(3);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            temp++;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上诉代码会抛出异常，修改成以下代码就不会,不能直接使用集合的 <code>remove</code> 方法来删除元素，而应该使用 <code>Iterator</code> 的 <code>remove</code> 方法，这样可以避免 <code>ConcurrentModificationException</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 使用 Iterator 遍历并删除元素</span><br><span class="line">        Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line">        int temp = 0;</span><br><span class="line">        while (it.hasNext()) &#123;</span><br><span class="line">            if (temp == 3) &#123;</span><br><span class="line">                temp++;</span><br><span class="line">                it.next(); // 移动到下一个元素，因为 remove 需要在 next() 之后调用</span><br><span class="line">                it.remove(); // 使用 Iterator 的 remove 方法</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                temp++;</span><br><span class="line">                System.out.println(it.next());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="fail-safe"><a href="#fail-safe" class="headerlink" title="fail-safe"></a><strong>fail-safe</strong></h4><p>安全失败机制：</p><ul><li>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。由于在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发ConcurrentModificationException。</li><li><strong>缺点</strong>：基于拷贝内容的优点是避免了ConcurrentModificationException，但同样地，迭代器并不能访问到<strong>修改后</strong>的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</li><li>适用场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</li></ul><h3 id="HashMap详解（JDK-1-8）"><a href="#HashMap详解（JDK-1-8）" class="headerlink" title="HashMap详解（JDK 1.8）"></a>HashMap详解（JDK 1.8）</h3><p><a href="https://juejin.cn/post/6844904111817637901">https://juejin.cn/post/6844904111817637901</a></p><h4 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h4><p>​底层数据结构采用数组+链表+红黑树。通过散列映射来存储键值对数据。</p><h4 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h4><p>​HashMap 是使用哈希表来存储数据的。哈希表为了解决冲突，一般有两种方案：<strong>开放地址法</strong> 和 <strong>链地址法</strong>。HashMap 采用的便是 <strong>链地址法</strong>，即在数组的每个索引处都是一个链表结构，这样就可以有效解决 hash 冲突。</p><h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认的初始容量为 16 （PS：aka 应该是 as know as）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大容量（容量不够时需要扩容）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>; <span class="comment">//2的30次方</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认的负载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表长度为 8 的时候会转为红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 长度为 6 的时候会从红黑树转为链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有桶内数据量大于 64 的时候才会允许转红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>初始容量是 16，可以扩容，但是扩容之后的容量，也是 2 的幂次方也就是一倍。另外， <strong>MIN_TREEIFY_CAPACITY</strong>，虽然说当链表长度大于 8 的时候，链表会转为红黑树，但是也是需要满足桶内存储的数据量大于上述这个参数的值，否则不仅不会转红黑树，反而会进行扩容操作。</p><p><img src="C:\Users\JIA\AppData\Roaming\Typora\typora-user-images\image-20240512232213041.png" alt="image-20240512232213041"></p><h4 id="重要参数"><a href="#重要参数" class="headerlink" title="重要参数"></a>重要参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map 中存储的数据量，即 key-value 键值对的数量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap 内部结构发生变化的次数，即新增、删除数据的时候都会记录，</span></span><br><span class="line"><span class="comment">// 注意：修改某个 key 的值，并不会改变这个 modCount</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重点，代表最多能容纳的数据量（初始为16 * 0.75 = 12）</span></span><br><span class="line"><span class="comment">// 即最多能容纳的 key-value 键值对的数量</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负载因子，默认为 0.75</span></span><br><span class="line"><span class="comment">// 注意，这个值是可以大于 1 的</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>threshold</strong> 代表最多能容纳的 Node 数量，一般 <code>threshold = 数组长度（初始为16） * loadFactor</code>，也就是说要想 HashMap 能够存储更多的数据（即获得较大的 threshold），有两种方案，一种是扩容（即增大数组长度 ），另一种便是增大负载因子。</p><h4 id="自动扩容原理"><a href="#自动扩容原理" class="headerlink" title="自动扩容原理"></a>自动扩容原理</h4><p>​<strong>初始化为空数组，第-次put 时才实例。<strong>当数据容量size达到threshold 阈值时会触发扩容机制。调用resize()，将</strong>数组长度</strong>扩大到原来的2倍。</p><h5 id="threshold阈值怎么计算"><a href="#threshold阈值怎么计算" class="headerlink" title="threshold阈值怎么计算"></a>threshold阈值怎么计算</h5><p>​threshold &#x3D; 数组长度（初始为16） * loadFactor（负载因子）</p><h5 id="数组怎么扩容"><a href="#数组怎么扩容" class="headerlink" title="数组怎么扩容"></a>数组怎么扩容</h5><pre><code>1. 获取旧数组，旧数组长度，旧数组阈值2. 如果旧数组长度 &gt; 0 1.  旧数组长度 &gt;=最大值，就将阈值调为Integer.MAX_VALUE（2的31次方-1），数组长度不变； 2. 数组长度变为原来的2倍，阈值 = 新数组长度 * 负载因子0.753. 如果旧数组长度 = 0，但是旧阈值 &gt; 0，正常是带参初始化hashmap，将旧阈值作为数组长度4. 如果旧数组长度 = 0 ，旧阈值 = 0，就是无参初始化hashmap，将默认初始容量 `DEFAULT_INITIAL_CAPACITY（16）`和默认负载因子 `DEFAULT_LOAD_FACTOR（0.75）`计算出新数组长度 newCap 和新阈值 newThr。5. 将旧数组元素复制到新数组，一部分下标索引不变，一部分变为（原索引+旧数据长度）（索引不是指链表位置）</code></pre><h4 id="添加元素时怎么确定存放的底层数组（桶）的索引下标？"><a href="#添加元素时怎么确定存放的底层数组（桶）的索引下标？" class="headerlink" title="添加元素时怎么确定存放的底层数组（桶）的索引下标？"></a>添加元素时怎么确定存放的底层数组（桶）的索引下标？</h4><p>​通过这个与运算 <code>(n - 1) &amp; hash</code>，其中变量 n 为数组的长度，变量 hash 就是通过 <code>hash()</code> 方法计算后的结果</p><h4 id="简单介绍一下-hash-原理？"><a href="#简单介绍一下-hash-原理？" class="headerlink" title="简单介绍一下 hash()原理？"></a>简单介绍一下 <code>hash()</code>原理？</h4><p>​HashMap的<code>hash()</code>就是将key对象的hashCode值进行处理（降低hash冲突的可能），得到最终的哈希值（hash）</p><h4 id="JDK1-7与JDK1-8中HashMap的区别"><a href="#JDK1-7与JDK1-8中HashMap的区别" class="headerlink" title="JDK1.7与JDK1.8中HashMap的区别"></a>JDK1.7与JDK1.8中HashMap的区别</h4><ol><li>旧数组长度jdk1.8计算索引方式不同，扩容时计算新索引下标只需要（hash &amp; 旧数组长度）即可，结果为0则新索引&#x3D;原索引n，结果为旧数组长度则新索引&#x3D;原索引n + 旧数组长度。jdk1.7扩容时需要一直（n-1）&amp;hash</li><li>1.8的链表引入了红黑树结构，当链表长度大于8且桶数组数据量大于64就变成红黑树，小于6则从红黑树退化为链表，。1.7则是数组+链表。</li><li>1.8扩容采用尾插法，1.7用头插法。尾插法能保证节点顺序和之前保持一致。</li></ol><h4 id="为什么1-8改用红黑树"><a href="#为什么1-8改用红黑树" class="headerlink" title="为什么1.8改用红黑树"></a>为什么1.8改用红黑树</h4><p>​当hash冲突过多时，链表过长，此时查询效率低下，大于8改为红黑树后查询方式性能得到了很好的提升，从原来的是O(n)到O(logn)。</p><h4 id="Hashmap-链表转红黑树条件"><a href="#Hashmap-链表转红黑树条件" class="headerlink" title="Hashmap 链表转红黑树条件"></a>Hashmap 链表转红黑树条件</h4><pre><code>1. 链表长度大于81. 数组长度大于64</code></pre><h4 id="HashMap允许空键空值么"><a href="#HashMap允许空键空值么" class="headerlink" title="HashMap允许空键空值么"></a>HashMap允许空键空值么</h4><p>​HashMap最多只允许一个键为Null(多条会覆盖)，但允许多个值为Null。hash()当key为null为返回0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h4><ol><li>两个线程同时计算索引时，可能会得出同一个索引位置，当A获取链表头节点后时间片用完，B获取链表头节点插入，此时A再插入数据就会造成B的数组被覆盖的问题。</li><li>（jdk1.7时采用、头插法）两个线程同时触发resize()，同时修改链表结构会产生一个循环链表。此时get会死循环</li></ol><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>​解决线程安全问题可以通过<strong>ConcurrentHashMap</strong> 和 <strong>Hashtable</strong>来实现线程安全；</p><p>​HashTable是原始API类，通过synchronize同步修饰，效率低下；</p><p>​ConcurrentHashMap通过分段锁实现，效率比HashTable要好；</p><h5 id="数据结构：-1"><a href="#数据结构：-1" class="headerlink" title="数据结构："></a>数据结构：</h5><p>​和HashMap一样采用数组 + 链表 + 红黑树实现。扩容机制也一样</p><h5 id="与1-7区别"><a href="#与1-7区别" class="headerlink" title="与1.7区别"></a>与1.7区别</h5><p>​jdk1.7的concurrentHashMap使用数组 + segment（段）+分段锁实现，其内部分为一个个段（Segment）数组，Segment 通过继承 ReentrantLock（可重入锁） 来进行加锁。每次锁一个段降低锁的粒度保证线程在段内操作的安全性。但是这样每次确定索引就需要两次定位：</p><ol><li>hash值 &amp; （段数组长度 - 1），确定所属段</li><li>hash值 &amp; （内部数组长度 - 1），确定所在桶</li></ol><p>​因此jdk1.8中优化了结构，取消分段锁，使用cas操作（compare and swap）和synchronied关键字实现优化。粒度直接到桶数组元素级别，锁住链表。</p><h5 id="不允许key和value为null"><a href="#不允许key和value为null" class="headerlink" title="不允许key和value为null"></a>不允许key和value为null</h5><p>​容易引起歧义，因为无法确认本身就是null还是被另一个线程修改的key-value</p><h5 id="如何保证线程的安全性？"><a href="#如何保证线程的安全性？" class="headerlink" title="如何保证线程的安全性？"></a>如何保证线程的安全性？</h5><p>​采用大量的分而治之的思想来降低锁的粒度，提升并发性能。使用大量的cas操作保证安全性，而不是和 HashTable 一样，不论什么方法，直接简单粗暴的使用 synchronized关键字来实现。</p><p>​cas：比较交换，通过拿一个旧值（期望值）和旧地址存的值作比较，如果相等就用新值设置并返回true，否则返回false证明已经被另一个线程修改了</p><h5 id="多并发下怎么实现扩容"><a href="#多并发下怎么实现扩容" class="headerlink" title="多并发下怎么实现扩容"></a>多并发下怎么实现扩容</h5><p>​采用分而治之的思想，分段进行扩容，即每个线程负责一段，默认最小是 16。也就是说如果 ConcurrentHashMap 中只有 16 个槽位，那么就只会有一个线程参与扩容。如果大于 16 则根据当前 CPU 数来进行分配，最大参与扩容线程数不会超过 CPU 数。<br>扩容后迁移数据，和hashmap类似，但是会用synchronized对当前节点加锁</p><h3 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a><strong>序列化和反序列化</strong></h3><p>​**序列化：**将java对象转化为字节序列的过程。持久化，用于存储和传输</p><p>​**反序列化：**将字节序列转化为java对象的过程。</p><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a><strong>优点：</strong></h5><p> a、实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上（通常存放在文件里）Redis的RDB</p><p> b、利用序列化实现远程通信，即在网络上传送对象的字节序列。 Google的protoBuf</p><h5 id="反序列化失败的场景："><a href="#反序列化失败的场景：" class="headerlink" title="反序列化失败的场景："></a><strong>反序列化失败的场景：</strong></h5><p> 序列化ID：serialVersionUID不一致的时候，导致反序列化失败（serialVersionUID是JRE根据类的内部细节自动生成，当修改对象属性或方法，serialVersionUID也会变化）</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a><strong>String</strong></h3><p>String 使用<strong>数组</strong>存储内容，数组使用 <strong>final</strong> 修饰，因此 String 定义的字符串的值也是<strong>不可变的</strong>，线程安全</p><table><thead><tr><th align="left">类型</th><th align="left">操作效率</th><th align="left">线程安全</th></tr></thead><tbody><tr><td align="left">String</td><td align="left">低</td><td align="left">安全（final）</td></tr><tr><td align="left">StringBuffer</td><td align="left">中</td><td align="left">安全（synchronized）</td></tr><tr><td align="left">StringBuilder</td><td align="left">高</td><td align="left">非安全</td></tr></tbody></table><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ol><li><p>饿汉式（立即加载）</p><p>饿汉式单例模式在类加载时就创建实例，线程安全，但如果实例初始化过程复杂且不一定会用到，可能会浪费资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonEager</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonEager</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 饿汉式在类加载时创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SingletonEager</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonEager</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供公共静态方法获取实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonEager <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>懒汉式 （延迟加载）</p><p>线程不安全懒汉式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonLazy</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonLazy</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 懒汉式在需要时创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonLazy instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供公共静态方法获取实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonLazy <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">SingletonLazy</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>线程安全的懒汉式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;   <span class="comment">//禁止指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>) &#123; <span class="comment">//减少加锁的损耗</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="literal">null</span>) <span class="comment">//确认是否初始化完成</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用双重<strong>双重检查锁定</strong>:</p><ul><li><strong>第一次检查</strong>：在同步块外检查 <code>instance</code> 是否为 <code>null</code>，目的是减少不必要的同步，提升性能。</li><li><strong>同步块</strong>：如果第一次检查发现 <code>instance</code> 为 <code>null</code>，进入同步块，确保只有一个线程能够执行此块代码。</li><li><strong>第二次检查</strong>：在同步块内再次检查 <code>instance</code> 是否为 <code>null</code>，因为可能有多个线程在第一次检查时都发现 <code>instance</code> 为 <code>null</code>，如果没有第二次检查，那么多个线程可能会创建多个实例。</li><li><strong>实例化</strong>：只有在确认 <code>instance</code> 为 <code>null</code> 的情况下，才会创建新的实例。</li></ul><p><strong>优化，使用静态内部类实现懒汉式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonLazy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonLazy</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 懒汉式在需要时创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonLazyHelper</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SingletonLazy</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonLazy</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供公共静态方法获取实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonLazy <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonLazyHelper.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ol><li><strong>私有构造函数</strong>：<code>private Singleton()</code> 确保外部无法实例化该类。</li><li><strong>静态内部类</strong>：<code>SingletonHolder</code> 是一个私有的静态内部类，它只在 <code>Singleton.getInstance()</code> 被调用时才会被加载和初始化。</li><li><strong>静态初始化器</strong>：<code>private static final Singleton INSTANCE = new Singleton();</code> 由 JVM 保证在类加载时线程安全。</li><li><strong>公共静态方法</strong>：<code>public static Singleton getInstance()</code> 通过调用 <code>SingletonHolder.INSTANCE</code> 返回单例实例。</li></ol><p>这种方式利用了 JVM 类加载机制的线程安全特性，不需要显式的同步机制，同时实现了懒加载，确保了单例实例只有在第一次使用时才会被创建。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><strong>延迟加载</strong>：单例实例在第一次使用时才被创建。</li><li><strong>线程安全</strong>：静态内部类的加载和初始化是由 JVM 保证的，天然是线程安全的。</li><li><strong>实现简单</strong>：不需要显式的同步代码，代码简洁明了。</li></ul></li></ol><h1 id="Spring篇"><a href="#Spring篇" class="headerlink" title="Spring篇"></a>Spring篇</h1><h3 id="设计思想-Beans"><a href="#设计思想-Beans" class="headerlink" title="设计思想&amp;Beans"></a>设计思想&amp;Beans</h3><h4 id="1、IOC-控制反转"><a href="#1、IOC-控制反转" class="headerlink" title="1、IOC 控制反转"></a><strong>1、IOC 控制反转</strong></h4><p> IoC（Inverse of Control:控制反转）是⼀种设计思想，就是将原本在程序中⼿动创建对象的控制权，交由Spring框架来管理。 IoC 在其他语⾔中也有应⽤，并⾮ Spring 特有。</p><p> IoC 容器是 Spring⽤来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注⼊。这样可以很⼤程度上简化应⽤的开发，把应⽤从复杂的依赖关系中解放出来。 IoC 容器就像是⼀个⼯⼚⼀样，当我们需要创建⼀个对象的时候，只需要配置好配置⽂件&#x2F;注解即可，完全不⽤考虑对象是如何被创建出来的。</p><p><strong>DI 依赖注入</strong></p><p> DI:（Dependancy Injection：依赖注入)站在容器的角度，将对象创建依赖的其他对象注入到对象中。</p><h4 id="2、AOP-动态代理"><a href="#2、AOP-动态代理" class="headerlink" title="2、AOP 动态代理"></a><strong>2、AOP 动态代理</strong></h4><p> AOP(Aspect-Oriented Programming:⾯向切⾯编程)能够将那些与业务⽆关，却为业务模块所共同调⽤的逻辑或责任（例如事务处理、⽇志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p><p> Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接⼝，那么Spring AOP会使⽤JDKProxy，去创建代理对象，<strong>⽽对于没有实现接⼝的对象，就⽆法使⽤ JDK Proxy 去进⾏代理了</strong>，这时候Spring AOP会使⽤基于asm框架字节流的Cglib动态代理 ，这时候Spring AOP会使⽤ Cglib ⽣成⼀个被代理对象的⼦类来作为代理。</p><h4 id="3、Bean生命周期"><a href="#3、Bean生命周期" class="headerlink" title="3、Bean生命周期"></a><strong>3、Bean生命周期</strong></h4><p><strong>单例对象：</strong> singleton</p><p>总结：单例对象的生命周期和容器相同</p><p><strong>多例对象：</strong> prototype</p><p>出生：使用对象时spring框架为我们创建</p><p>活着：对象只要是在使用过程中就一直活着</p><p>死亡：当对象长时间不用且没有其它对象引用时，由java的垃圾回收机制回收</p><p><a href="https://camo.githubusercontent.com/ff500845fb259b45f67c7d6fe787850907bedb69b49cb8cf236880c59ce77d83/68747470733a2f2f73302e6c677374617469632e636f6d2f692f696d616765332f4d30312f38392f30432f43677132786c365776487141646d743441414247416e32655369493633312e706e67"><img src="https://camo.githubusercontent.com/ff500845fb259b45f67c7d6fe787850907bedb69b49cb8cf236880c59ce77d83/68747470733a2f2f73302e6c677374617469632e636f6d2f692f696d616765332f4d30312f38392f30432f43677132786c365776487141646d743441414247416e32655369493633312e706e67" alt="img"></a></p><p>IOC容器初始化加载Bean流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">  // 第一步:刷新前的预处理 </span><br><span class="line">  prepareRefresh();</span><br><span class="line">  //第二步: 获取BeanFactory并注册到 BeanDefitionRegistry</span><br><span class="line">  ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">  // 第三步:加载BeanFactory的预准备工作(BeanFactory进行一些设置，比如context的类加载器等)</span><br><span class="line">  prepareBeanFactory(beanFactory);</span><br><span class="line">  try &#123;</span><br><span class="line">    // 第四步:完成BeanFactory准备工作后的前置处理工作 </span><br><span class="line">    postProcessBeanFactory(beanFactory);</span><br><span class="line">    // 第五步:实例化BeanFactoryPostProcessor接口的Bean </span><br><span class="line">    invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">    // 第六步:注册BeanPostProcessor后置处理器，在创建bean的后执行 </span><br><span class="line">    registerBeanPostProcessors(beanFactory);</span><br><span class="line">    // 第七步:初始化MessageSource组件(做国际化功能;消息绑定，消息解析); </span><br><span class="line">    initMessageSource();</span><br><span class="line">    // 第八步:注册初始化事件派发器 </span><br><span class="line">    initApplicationEventMulticaster();</span><br><span class="line">    // 第九步:子类重写这个方法，在容器刷新的时候可以自定义逻辑 </span><br><span class="line">    onRefresh();</span><br><span class="line">    // 第十步:注册应用的监听器。就是注册实现了ApplicationListener接口的监听器</span><br><span class="line">    registerListeners();</span><br><span class="line">    //第十一步:初始化所有剩下的非懒加载的单例bean 初始化创建非懒加载方式的单例Bean实例(未设置属性)</span><br><span class="line">    finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">    //第十二步: 完成context的刷新。主要是调用LifecycleProcessor的onRefresh()方法，完成创建</span><br><span class="line">    finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line">  ……</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>总结：</p><p><strong>四个阶段</strong></p><ul><li>实例化 Instantiation</li><li>属性赋值 Populate</li><li>初始化 Initialization</li><li>销毁 Destruction</li></ul><p><strong>多个扩展点</strong></p><ul><li>影响多个Bean<ul><li>BeanPostProcessor</li><li>InstantiationAwareBeanPostProcessor</li></ul></li><li>影响单个Bean<ul><li>Aware</li></ul></li></ul><p><strong>完整流程</strong></p><ol><li>实例化一个Bean－－也就是我们常说的<strong>new</strong>；</li><li>按照Spring上下文对实例化的Bean进行配置－－<strong>也就是IOC注入</strong>；</li><li>如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String)方法，也就是根据就是Spring配置文件中<strong>Bean的id和name进行传递</strong></li><li>如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现setBeanFactory(BeanFactory)也就是Spring配置文件配置的<strong>Spring工厂自身进行传递</strong>；</li><li>如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，和4传递的信息一样但是因为ApplicationContext是BeanFactory的子接口，所以<strong>更加灵活</strong></li><li>如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessBeforeInitialization()方法，BeanPostProcessor经常被用作是Bean内容的更改，由于这个是在Bean初始化结束时调用那个的方法，也可以被应用于<strong>内存或缓存技</strong>术</li><li>如果Bean在Spring配置文件中配置了init-method属性会自动调用其配置的初始化方法。</li><li>如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessAfterInitialization()，<strong>打印日志或者三级缓存技术里面的bean升级</strong></li><li>以上工作完成以后就可以应用这个Bean了，那这个Bean是一个Singleton的，所以一般情况下我们调用同一个id的Bean会是在内容地址相同的实例，当然在Spring配置文件中也可以配置非Singleton，这里我们不做赘述。</li><li>当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，或者根据spring配置的destroy-method属性，调用实现的destroy()方法</li></ol><h4 id="4、Bean作用域"><a href="#4、Bean作用域" class="headerlink" title="4、Bean作用域"></a><strong>4</strong>、Bean作用域</h4><table><thead><tr><th>名称</th><th>作用域</th></tr></thead><tbody><tr><td><strong>singleton</strong></td><td><strong>单例对象，默认值的作用域</strong></td></tr><tr><td><strong>prototype</strong></td><td><strong>每次获取都会创建⼀个新的 bean 实例</strong></td></tr><tr><td>request</td><td>每⼀次HTTP请求都会产⽣⼀个新的bean，该bean仅在当前HTTP request内有效。</td></tr><tr><td>session</td><td>在一次 HTTP session 中，容器将返回同一个实例</td></tr><tr><td>global-session</td><td>将对象存入到web项目集群的session域中,若不存在集群,则global session相当于session</td></tr></tbody></table><p>默认作用域是singleton，多个线程访问同一个bean时会存在线程不安全问题</p><p><strong>保障线程安全方法：</strong></p><ol><li>在Bean对象中尽量避免定义可变的成员变量（不太现实）。</li><li>在类中定义⼀个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中</li></ol><p><strong>ThreadLocal</strong>：</p><p> 每个线程中都有一个自己的ThreadLocalMap类对象，可以将线程自己的对象保持到其中，各管各的，线程可以正确的访问到自己的对象。</p><p> 将一个共用的ThreadLocal静态实例作为key，将不同对象的引用保存到不同线程的ThreadLocalMap中，然后<strong>在线程执行的各处通过这个静态ThreadLocal实例的get()方法取得自己线程保存的那个对象</strong>，避免了将这个对象作为参数传递的麻烦。</p><h4 id="5、循环依赖"><a href="#5、循环依赖" class="headerlink" title="5、循环依赖"></a>5、循环依赖</h4><p> 循环依赖其实就是循环引用，也就是两个或者两个以上的 Bean 互相持有对方，最终形成闭环。比如A 依赖于B，B又依赖于A</p><p>Spring中循环依赖场景有:</p><ul><li><p>prototype 原型 bean循环依赖</p></li><li><p>构造器的循环依赖（构造器注入）</p></li><li><p>Field 属性的循环依赖（set注入）</p><p>其中，构造器的循环依赖问题无法解决，在解决属性循环依赖时，可以使用懒加载，spring采用的是提前暴露对象的方法。</p></li></ul><p><strong>懒加载@Lazy解决循环依赖问题</strong></p><p> Spring 启动的时候会把所有bean信息(包括XML和注解)解析转化成Spring能够识别的BeanDefinition并存到Hashmap里供下面的初始化时用，然后对每个 BeanDefinition 进行处理。普通 Bean 的初始化是在容器启动初始化阶段执行的，而被lazy-init&#x3D;true修饰的 bean 则是在从容器里第一次进行<strong>context.getBean() 时进行触发</strong>。</p><p><strong>三级缓存解决循环依赖问题</strong></p><p><a href="https://camo.githubusercontent.com/de2991ecc66213f6d747a23957a07acf037eb3f0f4f0398e1cd1445a6e479fcf/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676c763769767275326c6a333139383071636e31332e6a7067"><img src="https://camo.githubusercontent.com/de2991ecc66213f6d747a23957a07acf037eb3f0f4f0398e1cd1445a6e479fcf/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f303038314b636b776c7931676c763769767275326c6a333139383071636e31332e6a7067" alt="循环依赖问题"></a></p><ol><li>Spring容器初始化ClassA通过构造器初始化对象后提前暴露到Spring容器中的singletonFactorys（三级缓存中）。</li><li>ClassA调用setClassB方法，Spring首先尝试从容器中获取ClassB，此时ClassB不存在Spring 容器中。</li><li>Spring容器初始化ClassB，ClasssB首先将自己暴露在三级缓存中，然后从Spring容器一级、二级、三级缓存中一次中获取ClassA 。</li><li>获取到ClassA后将自己实例化放入单例池中，实例 ClassA通过Spring容器获取到ClassB，完成了自己对象初始化操作。</li><li>这样ClassA和ClassB都完成了对象初始化操作，从而解决了循环依赖问题。</li></ol><h5 id="Spring-框架通过-“三级缓存”-机制来解决单例-Bean-的循环依赖问题。三级缓存主要涉及以下三个缓存："><a href="#Spring-框架通过-“三级缓存”-机制来解决单例-Bean-的循环依赖问题。三级缓存主要涉及以下三个缓存：" class="headerlink" title="Spring 框架通过 “三级缓存” 机制来解决单例 Bean 的循环依赖问题。三级缓存主要涉及以下三个缓存："></a>Spring 框架通过 “三级缓存” 机制来解决单例 Bean 的循环依赖问题。三级缓存主要涉及以下三个缓存：</h5><ol><li><strong>一级缓存</strong>（singletonObjects）：存储已经完全初始化的单例 Bean。</li><li><strong>二级缓存</strong>（earlySingletonObjects）：存储提前暴露的早期单例 Bean，未完成依赖注入但已经实例化。</li><li><strong>三级缓存</strong>（singletonFactories）：存储能够创建 Bean 的工厂对象，用于创建 Bean 的代理对象或提前曝光 Bean 的实例。</li></ol><p>三级缓存解决循环依赖问题的工作机制</p><ol><li><strong>Bean 实例化</strong>：<ul><li>Spring 在创建 Bean 的过程中，首先会实例化该 Bean（即调用构造函数创建 Bean 对象，但未进行依赖注入）。</li></ul></li><li><strong>将 Bean 的工厂对象加入三级缓存</strong>：<ul><li>Spring 会将创建 Bean 的工厂对象放入三级缓存（singletonFactories）。</li></ul></li><li><strong>依赖注入</strong>：<ul><li>当需要注入依赖时，Spring 会从缓存中获取依赖的 Bean。如果依赖的 Bean 已经在一级缓存中，则直接使用；如果在二级缓存中，也直接使用；如果在三级缓存中，Spring 会通过工厂对象获取 Bean 的早期引用，并将其移动到二级缓存中以供其他 Bean 使用。</li></ul></li><li><strong>完成依赖注入和初始化</strong>：<ul><li>一旦依赖注入完成，Spring 会将完全初始化的 Bean 移动到一级缓存中，同时从二级缓存和三级缓存中移除。</li></ul></li></ol><p>代码示例</p><p>为了更好地理解三级缓存的工作机制，以下是一个简化的代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">java复制代码import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.context.annotation.Scope;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">@Scope(&quot;singleton&quot;)</span><br><span class="line">public class A &#123;</span><br><span class="line">    private final B b;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public A(B b) &#123;</span><br><span class="line">        this.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">@Scope(&quot;singleton&quot;)</span><br><span class="line">public class B &#123;</span><br><span class="line">    private final A a;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public B(A a) &#123;</span><br><span class="line">        this.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，类 <code>A</code> 依赖于类 <code>B</code>，而类 <code>B</code> 也依赖于类 <code>A</code>，形成了循环依赖。</p><p>三级缓存的详细工作过程</p><ol><li><strong>实例化 Bean A</strong>：<ul><li>Spring 创建 Bean A 的实例，并将 Bean A 的工厂对象放入三级缓存。</li></ul></li><li><strong>实例化 Bean B</strong>：<ul><li>在创建 Bean B 的过程中，发现需要注入 Bean A。</li><li>Spring 从三级缓存中获取 Bean A 的工厂对象，通过工厂对象获取 Bean A 的早期引用（即尚未完成依赖注入的实例），并将其放入二级缓存。</li></ul></li><li><strong>完成 Bean B 的实例化和依赖注入</strong>：<ul><li>Spring 完成 Bean B 的实例化和依赖注入，将完全初始化的 Bean B 放入一级缓存。</li></ul></li><li><strong>完成 Bean A 的依赖注入</strong>：<ul><li>Spring 使用从二级缓存中获取的 Bean B 完成 Bean A 的依赖注入，并将完全初始化的 Bean A 移动到一级缓存。</li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过三级缓存机制，Spring 能够在 Bean 的创建过程中提前暴露一个创建中的 Bean，从而解决单例 Bean 的循环依赖问题。这种机制确保了依赖注入的顺利进行，同时避免了死循环或堆栈溢出错误。然而，这种机制仅适用于单例作用域的 Bean，对于原型作用域的 Bean，Spring 无法使用这种机制来解决循环依赖问题。</p><h3 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h3><h4 id="1、-SpringBoot"><a href="#1、-SpringBoot" class="headerlink" title="1、@SpringBoot"></a>1、@SpringBoot</h4><p> <strong>声明bean的注解</strong></p><p> <strong>@Component</strong> 通⽤的注解，可标注任意类为 Spring 组件</p><p> <strong>@Service</strong> 在业务逻辑层使用（service层）</p><p> <strong>@Repository</strong> 在数据访问层使用（dao层）</p><p> <strong>@Controller</strong> 在展现层使用，控制器的声明（controller层）</p><p> <strong>注入bean的注解</strong></p><p> <strong>@Autowired</strong>：默认按照类型来装配注入，<strong>@Qualifier</strong>：可以改成名称</p><p> <strong>@Resource</strong>：默认按照名称来装配注入，JDK的注解，新版本已经弃用</p><p><strong>@Autowired注解原理</strong></p><p> @Autowired的使用简化了我们的开发，</p><p> 实现 AutowiredAnnotationBeanPostProcessor 类，该类实现了 Spring 框架的一些扩展接口。 实现 BeanFactoryAware 接口使其内部持有了 BeanFactory（可轻松的获取需要依赖的的 Bean）。 实现 MergedBeanDefinitionPostProcessor 接口，实例化Bean 前获取到 里面的 @Autowired 信息并缓存下来； 实现 postProcessPropertyValues 接口， 实例化Bean 后从缓存取出注解信息，通过反射将依赖对象设置到 Bean 属性里面。</p><p><strong>@SpringBootApplication</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class JpaApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(JpaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@SpringBootApplication</strong>注解等同于下面三个注解：</p><ul><li><strong>@SpringBootConfiguration：</strong> 底层是<strong>Configuration</strong>注解，说白了就是支持<strong>JavaConfig</strong>的方式来进行配置</li><li><strong>@EnableAutoConfiguration：开启自动配置</strong>功能</li><li><strong>@ComponentScan：就是扫描</strong>注解，默认是扫描<strong>当前类下</strong>的package</li></ul><p><strong>其中<code>@EnableAutoConfiguration</code>是关键(启用自动配置)，内部实际上就去加载<code>META-INF/spring.factories</code>文件的信息，然后筛选出以<code>EnableAutoConfiguration</code>为key的数据，加载到IOC容器中，实现自动配置功能！</strong></p><p>它主要加载了@SpringBootApplication注解主配置类，这个@SpringBootApplication注解主配置类里边最主要的功能就是SpringBoot开启了一个@EnableAutoConfiguration注解的自动配置功能。</p><p><strong>@EnableAutoConfiguration作用：</strong></p><p>它主要利用了一个</p><p>EnableAutoConfigurationImportSelector选择器给Spring容器中来导入一些组件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Import(EnableAutoConfigurationImportSelector.class)</span><br><span class="line">public @interface EnableAutoConfiguration </span><br></pre></td></tr></table></figure><h4 id="2、-SpringMVC"><a href="#2、-SpringMVC" class="headerlink" title="2、@SpringMVC"></a><strong>2、@SpringMVC</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Controller 声明该类为SpringMVC中的Controller</span><br><span class="line">@RequestMapping 用于映射Web请求</span><br><span class="line">@ResponseBody 支持将返回值放在response内，而不是一个页面，通常用户返回json数据</span><br><span class="line">@RequestBody 允许request的参数在request体中，而不是在直接连接在地址后面。</span><br><span class="line">@PathVariable 用于接收路径参数</span><br><span class="line">@RequestMapping(&quot;/hello/&#123;name&#125;&quot;)申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。</span><br></pre></td></tr></table></figure><p><strong>SpringMVC原理</strong></p><p><a href="https://camo.githubusercontent.com/d9b573af7586c35692c03cf192231b9518ddd4a92bc805da05032edab42d4916/68747470733a2f2f696d672d626c6f672e6373646e2e6e65742f32303138313032323232343035383631373f77617465726d61726b2f322f746578742f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c3246335957746c5832787861413d3d2f666f6e742f3561364c354c32542f666f6e7473697a652f3430302f66696c6c2f49304a42516b46434d413d3d2f646973736f6c76652f3730"><img src="https://camo.githubusercontent.com/d9b573af7586c35692c03cf192231b9518ddd4a92bc805da05032edab42d4916/68747470733a2f2f696d672d626c6f672e6373646e2e6e65742f32303138313032323232343035383631373f77617465726d61726b2f322f746578742f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c3246335957746c5832787861413d3d2f666f6e742f3561364c354c32542f666f6e7473697a652f3430302f66696c6c2f49304a42516b46434d413d3d2f646973736f6c76652f3730" alt="img"></a></p><ol><li>客户端（浏览器）发送请求，直接请求到 DispatcherServlet 。</li><li>DispatcherServlet 根据请求信息调⽤ HandlerMapping ，解析请求对应的 Handler 。</li><li>解析到对应的 Handler （也就是 Controller 控制器）后，开始由HandlerAdapter 适配器处理。</li><li>HandlerAdapter 会根据 Handler 来调⽤真正的处理器开处理请求，并处理相应的业务逻辑。</li><li>处理器处理完业务后，会返回⼀个 ModelAndView 对象， Model 是返回的数据对象</li><li>ViewResolver 会根据逻辑 View 查找实际的 View 。</li><li>DispaterServlet 把返回的 Model 传给 View （视图渲染）。</li><li>把 View 返回给请求者（浏览器）</li></ol><h4 id="3、-SpringMybatis"><a href="#3、-SpringMybatis" class="headerlink" title="3、@SpringMybatis"></a>3、@SpringMybatis</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Insert ： 插入sql ,和xml insert sql语法完全一样</span><br><span class="line">@Select ： 查询sql, 和xml select sql语法完全一样</span><br><span class="line">@Update ： 更新sql, 和xml update sql语法完全一样</span><br><span class="line">@Delete ： 删除sql, 和xml delete sql语法完全一样</span><br><span class="line">@Param ： 入参</span><br><span class="line">@Results ： 设置结果集合@Result ： 结果</span><br><span class="line">@ResultMap ： 引用结果集合</span><br><span class="line">@SelectKey ： 获取最新插入id </span><br></pre></td></tr></table></figure><p><strong>mybatis如何防止sql注入？</strong></p><p> 简单的说就是#{}是经过预编译的，是安全的，<strong>$</strong>{}是未经过预编译的，仅仅是取变量的值，是非安全的，存在SQL注入。在编写mybatis的映射语句时，尽量采用**“#{xxx}”<strong>这样的格式。如果需要实现动态传入表名、列名，还需要做如下修改：添加属性</strong>statementType&#x3D;”STATEMENT”<strong>，同时sql里的属有变量取值都改成</strong>${xxxx}**</p><p><strong>Mybatis和Hibernate的区别</strong></p><p><strong>Hibernate 框架：</strong></p><p> <strong>Hibernate</strong>是一个开放源代码的对象关系映射框架,它对JDBC进行了非常轻量级的对象封装,建立对象与数据库表的映射。是一个全自动的、完全面向对象的持久层框架。</p><p><strong>Mybatis框架：</strong></p><p> <strong>Mybatis</strong>是一个开源对象关系映射框架，原名：ibatis,2010年由谷歌接管以后更名。是一个半自动化的持久层框架。</p><p><strong>区别：</strong></p><p><strong>开发方面</strong></p><p> 在项目开发过程当中，就速度而言：</p><p> hibernate开发中，sql语句已经被封装，直接可以使用，加快系统开发；</p><p> Mybatis 属于半自动化，sql需要手工完成，稍微繁琐；</p><p> 但是，凡事都不是绝对的，如果对于庞大复杂的系统项目来说，复杂语句较多，hibernate 就不是好方案。</p><p><strong>sql优化方面</strong></p><p> Hibernate 自动生成sql,有些语句较为繁琐，会多消耗一些性能；</p><p> Mybatis 手动编写sql，可以避免不需要的查询，提高系统性能；</p><p><strong>对象管理比对</strong></p><p> Hibernate 是完整的对象-关系映射的框架，开发工程中，无需过多关注底层实现，只要去管理对象即可；</p><p> Mybatis 需要自行管理映射关系；</p><h4 id="4、-Transactional"><a href="#4、-Transactional" class="headerlink" title="4、@Transactional"></a>4、@Transactional</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@EnableTransactionManagement </span><br><span class="line">@Transactional</span><br></pre></td></tr></table></figure><p>注意事项：</p><p> ①事务函数中不要处理耗时任务，会导致长期占有数据库连接。</p><p> ②事务函数中不要处理无关业务，防止产生异常导致事务回滚。</p><p><strong>事务传播属性</strong></p><p><strong>1) REQUIRED（默认属性）</strong> 如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。</p><ol><li>MANDATORY 支持当前事务，如果当前没有事务，就抛出异常。</li><li>NEVER 以非事务方式执行，如果当前存在事务，则抛出异常。</li><li>NOT_SUPPORTED 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li>REQUIRES_NEW 新建事务，如果当前存在事务，把当前事务挂起。</li><li>SUPPORTS 支持当前事务，如果当前没有事务，就以非事务方式执行。</li></ol><p><strong>7) NESTED</strong> （<strong>局部回滚</strong>） 支持当前事务，新增Savepoint点，与当前事务同步提交或回滚。 <strong>嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。</strong></p><h3 id="Spring源码阅读"><a href="#Spring源码阅读" class="headerlink" title="Spring源码阅读"></a>Spring源码阅读</h3><h4 id="1、Spring中的设计模式"><a href="#1、Spring中的设计模式" class="headerlink" title="1、Spring中的设计模式"></a><strong>1、Spring中的设计模式</strong></h4><p>参考：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485303&idx=1&sn=9e4626a1e3f001f9b0d84a6fa0cff04a&chksm=cea248bcf9d5c1aaf48b67cc52bac74eb29d6037848d6cf213b0e5466f2d1fda970db700ba41&token=255050878&lang=zh_CN%23rd">spring中的设计模式</a></p><p><strong>单例设计模式 :</strong> Spring 中的 Bean 默认都是单例的。</p><p><strong>⼯⼚设计模式 :</strong> Spring使⽤⼯⼚模式通过 BeanFactory 、 ApplicationContext 创建bean 对象。</p><p><strong>代理设计模式 :</strong> Spring AOP 功能的实现。</p><p><strong>观察者模式：</strong> Spring 事件驱动模型就是观察者模式很经典的⼀个应⽤。</p><p>**适配器模式：**Spring AOP 的增强或通知(Advice)使⽤到了适配器模式、spring MVC 中也是⽤到了适配器模式适配 Controller 。</p><h1 id="Springboot"><a href="#Springboot" class="headerlink" title="Springboot"></a>Springboot</h1><p>自动装配原理：</p><p>​基于spring框架的IOC（控制反转）和DI（依赖注入）机制，通过自动配置机制来简化Spring应用的配置过程。主要是通过核心注解@SpringbootApplication，可以看作<code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 注解的集合。其中最主要的是@EnableAutoConfiguration。@EnableAutoConfiguration实际是通过 <code>AutoConfigurationImportSelector</code>类（加载自动装配类），将符合条件的bean进行装配。</p><h2 id="自动配置的执行过程"><a href="#自动配置的执行过程" class="headerlink" title="自动配置的执行过程"></a>自动配置的执行过程</h2><p><strong>启动阶段</strong>：应用启动时，Spring Boot会扫描<code>META-INF/spring.factories</code>文件，找到所有自动配置类。</p><p><strong>加载阶段</strong>：使用<code>SpringFactoriesLoader</code>加载这些配置类。</p><p><strong>条件判断</strong>：对于每个自动配置类，Spring Boot会根据<code>@Conditional</code>注解的条件进行判断，如果满足条件，则装配相应的Bean。</p><p><strong>注入阶段</strong>：根据DI机制，将满足条件的Bean注入到Spring上下文中。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea新建多模块工程</title>
      <link href="/2022/06/01/idea%E6%96%B0%E5%BB%BA%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%B7%A5%E7%A8%8B/"/>
      <url>/2022/06/01/idea%E6%96%B0%E5%BB%BA%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%B7%A5%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="idea新建多模块工程"><a href="#idea新建多模块工程" class="headerlink" title="idea新建多模块工程"></a>idea新建多模块工程</h1><span id="more"></span><p>idea新建多模块工程</p><h3 id="创建继承关系模块-两个模块具有父子关系"><a href="#创建继承关系模块-两个模块具有父子关系" class="headerlink" title="创建继承关系模块(两个模块具有父子关系)"></a>创建继承关系模块(两个模块具有父子关系)</h3><h4 id="创建父子模块"><a href="#创建父子模块" class="headerlink" title="创建父子模块"></a>创建父子模块</h4><h5 id="第一步：创建父模块"><a href="#第一步：创建父模块" class="headerlink" title="第一步：创建父模块"></a>第一步：创建父模块</h5><p>依次点击 File -&gt; New -&gt; Project -&gt;Maven -&gt;Next</p><p><img src="/iamges/idea%E6%96%B0%E5%BB%BA%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%B7%A5%E7%A8%8B/1.png" alt="img"></p><p><img src="/iamges/idea%E6%96%B0%E5%BB%BA%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%B7%A5%E7%A8%8B/2.png" alt="img"></p><p>创建后目录结构如下：</p><p><img src="/iamges/idea%E6%96%B0%E5%BB%BA%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%B7%A5%E7%A8%8B/3.png" alt="img"></p><h5 id="第二步：修改父模块pom"><a href="#第二步：修改父模块pom" class="headerlink" title="第二步：修改父模块pom"></a>第二步：修改父模块pom</h5><p>在修改pom文件之前，先删掉父模块中的src目录。</p><p><img src="/iamges/idea%E6%96%B0%E5%BB%BA%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%B7%A5%E7%A8%8B/4.png" alt="img"></p><p>然后在修改pom文件，如果只是简单能用，其实只要修改如下两个配置即可：</p><p>1、添加标签并将其改为pom。</p><p>2、添加标签配置对所有模块依赖的管理。</p><p>修改后完整pom如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-im<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 当前工程作为父工程，它要去管理子工程，所以打包方式必须是 pom --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 子模块 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>redis-learn<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>pro-common<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 二选一，使用dependencyManagement标签配置对所有模块依赖的管理，单独选择 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- spring-boot 依赖 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- spring redis 依赖 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">      <span class="comment">&lt;!-- 二选一，也可以直接引入 Spring Boot 的依赖管理，供所有子模块统一使用 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="创建子模块"><a href="#创建子模块" class="headerlink" title="创建子模块"></a>创建子模块</h4><h5 id="第一步：创建子模块"><a href="#第一步：创建子模块" class="headerlink" title="第一步：创建子模块"></a>第一步：创建子模块</h5><p>选中父工程 pro-learn -&gt; New -&gt; Module -&gt; Spring Initializr -&gt; Module SDK(选择自己的jdk版本) -&gt; Next</p><p><img src="/iamges/idea%E6%96%B0%E5%BB%BA%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%B7%A5%E7%A8%8B/5.png" alt="img"></p><p>按自己需求填写如下信息，点击Next进入下一步。</p><p><img src="/iamges/idea%E6%96%B0%E5%BB%BA%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%B7%A5%E7%A8%8B/6.png" alt="img"></p><p>这里可以什么都不选，点击Next进入下一步，然后，按自己需求填写信息，最后点击create完成子模块的创建。</p><p><img src="/iamges/idea%E6%96%B0%E5%BB%BA%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%B7%A5%E7%A8%8B/7.png" alt="img"></p><p>创建子模块后的目录结构如下：</p><p><img src="/iamges/idea%E6%96%B0%E5%BB%BA%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%B7%A5%E7%A8%8B/8.png" alt="img"></p><h5 id="第二步：父模块中添加modules管理子模块"><a href="#第二步：父模块中添加modules管理子模块" class="headerlink" title="第二步：父模块中添加modules管理子模块"></a>第二步：父模块中添加modules管理子模块</h5><p>在父pom中添加如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--子模块--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>im-common<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="第三步：配置子模块pom"><a href="#第三步：配置子模块pom" class="headerlink" title="第三步：配置子模块pom"></a>第三步：配置子模块pom</h5><p>将redis-learn模块pom文件中parent中的坐标(groupId、<a href="https://so.csdn.net/so/search?q=artifactId&spm=1001.2101.3001.7020">artifactId</a>、version)改为父模块的坐标，及添加依赖，具体看以下pom文件中的注释：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用parent标签指定当前工程的父工程 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 父工程的坐标 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.im<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-im-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 子工程的坐标 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果子工程坐标中的groupId和version与父工程一致，可以省略 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>im-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 子工程引用父工程中的依赖信息时，可以把版本号去掉。--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 把版本号去掉就表示子工程中这个依赖的版本由父工程决定。 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 具体来说是由父工程的dependencyManagement来决定。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="创建依赖关系模块-一个模块引用另一个模块"><a href="#创建依赖关系模块-一个模块引用另一个模块" class="headerlink" title="创建依赖关系模块(一个模块引用另一个模块)"></a>创建依赖关系模块(一个模块引用另一个模块)</h3><p>在我们开发中，是不是经常把一些公用的方法，比如你的util工具类，常量类等放到一个单独的包中，比如放到common包中，如果分多模块，就可以把这些公共方法单独放到一个模块中。</p><h4 id="创建子模块-1"><a href="#创建子模块-1" class="headerlink" title="创建子模块"></a>创建子模块</h4><h5 id="第一步：创建子模块-1"><a href="#第一步：创建子模块-1" class="headerlink" title="第一步：创建子模块"></a>第一步：创建子模块</h5><p><img src="/iamges/idea%E6%96%B0%E5%BB%BA%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%B7%A5%E7%A8%8B/9.png" alt="img"></p><h5 id="第二步：在im-platform引用im-common"><a href="#第二步：在im-platform引用im-common" class="headerlink" title="第二步：在im-platform引用im-common"></a>第二步：在im-platform引用im-common</h5><p>修改im-platform模块中的pom文件，通过pro-common的坐标来引用im-common模块，在im-platform的pom中添加如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.im<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>im-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>至此，一个基本的maven管理的多模块项目就搭建完毕了。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Idea新建项目文件哪些可删</title>
      <link href="/2022/01/01/Idea%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E5%93%AA%E4%BA%9B%E5%8F%AF%E5%88%A0/"/>
      <url>/2022/01/01/Idea%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E5%93%AA%E4%BA%9B%E5%8F%AF%E5%88%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Idea新建项目文件哪些可删"><a href="#Idea新建项目文件哪些可删" class="headerlink" title="Idea新建项目文件哪些可删"></a>Idea新建项目文件哪些可删</h1><span id="more"></span><h2 id="Idea新建项目文件解释"><a href="#Idea新建项目文件解释" class="headerlink" title="Idea新建项目文件解释"></a>Idea新建项目文件解释</h2><p><img src="/iamges/Idea%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E5%93%AA%E4%BA%9B%E5%8F%AF%E5%88%A0/1.png" alt="img"></p><ul><li><p>.gitignore 用git做版本控制时 用这个文件控制那些文件或文件夹 不被提交（不用git的话可删除 没影响）</p></li><li><p>HELP.md md是一种文档格式 这个就是你项目的帮助文档（可删除 没影响）</p></li><li><p>mvnw linux上处理mevan版本兼容问题的脚本（可删除 没影响）</p></li><li><p>mvnw.cmd windows 上处理mevan版本兼容问题的脚本（可删除 没影响）</p></li><li><p>** 没影响）</p></li><li><p>cloud22020.iml 有的文件每个导入IDEA的项目都会生成一个项目同名的 .iml文件 用于保存你对这个项目的配置 （删了程序重新导入后还会生成 但由于配置丢失可能会造成程序异常）</p></li><li><p><code>.mvn</code> 目录：用于存放 Maven 项目的本地配置（如 <code>jvm.config</code>、<code>maven.config</code>）和 Maven Wrapper（版本管理）。</p><p><code>.mvn/wrapper</code> 目录：包含 Maven Wrapper 相关文件（<code>mvnw</code>、<code>mvnw.cmd</code>），确保项目使用固定版本的 Maven，可删除但影响自动管理。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud-Nacos：服务注册+配置中心</title>
      <link href="/2020/04/05/%E4%BD%BF%E7%94%A8fastdfs%E4%B8%8A%E4%BC%A0%E8%A7%86%E9%A2%91%E5%B9%B6%E4%BD%BF%E7%94%A8FFmpegFrameGrabberFrameGrabber%E5%9C%A8%E4%B8%8A%E4%BC%A0%E8%A7%86%E9%A2%91%E6%97%B6%E6%88%AA%E5%9B%BE%E4%BD%9C%E4%B8%BA%E5%B0%81%E9%9D%A2/"/>
      <url>/2020/04/05/%E4%BD%BF%E7%94%A8fastdfs%E4%B8%8A%E4%BC%A0%E8%A7%86%E9%A2%91%E5%B9%B6%E4%BD%BF%E7%94%A8FFmpegFrameGrabberFrameGrabber%E5%9C%A8%E4%B8%8A%E4%BC%A0%E8%A7%86%E9%A2%91%E6%97%B6%E6%88%AA%E5%9B%BE%E4%BD%9C%E4%B8%BA%E5%B0%81%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="使用fastdfs上传视频并使用FFmpegFrameGrabberFrameGrabber在上传视频时截图作为封面"><a href="#使用fastdfs上传视频并使用FFmpegFrameGrabberFrameGrabber在上传视频时截图作为封面" class="headerlink" title="使用fastdfs上传视频并使用FFmpegFrameGrabberFrameGrabber在上传视频时截图作为封面"></a>使用fastdfs上传视频并使用FFmpegFrameGrabberFrameGrabber在上传视频时截图作为封面</h1><span id="more"></span><p>最近为了参加一个比赛，需要一个视频上传功能，所以查了很多。以下为一个小demo</p><p>使用工具：idea，阿里云服务器，fastdfs</p><p>服务器部分</p><ol><li>在阿里云服务器上安装fastdfs分布式文件管理系统<br>安装方法参考<a href="https://www.cnblogs.com/handsomeye/p/9451568.html">https://www.cnblogs.com/handsomeye/p/9451568.html</a></li></ol><p>安装fastdfs踩过太多坑了，安装一定要注意，storage.conf，client.conf,tracker.conf这三个配置文件的路径设置什么的，然后要搭配nginx实现访问，nginx的配置文件nginx.conf也要注意<br><img src="/iamges/%E4%BD%BF%E7%94%A8fastdfs%E4%B8%8A%E4%BC%A0%E8%A7%86%E9%A2%91%E5%B9%B6%E4%BD%BF%E7%94%A8FFmpegFrameGrabberFrameGrabber%E5%9C%A8%E4%B8%8A%E4%BC%A0%E8%A7%86%E9%A2%91%E6%97%B6%E6%88%AA%E5%9B%BE%E4%BD%9C%E4%B8%BA%E5%B0%81%E9%9D%A2/1.png" alt="img"></p><h4 id="后端部分"><a href="#后端部分" class="headerlink" title="后端部分"></a>后端部分</h4><p>fastdfs和nginx配置并测试好了之后，开始写测试代码</p><h5 id="1-idea文件结构如图"><a href="#1-idea文件结构如图" class="headerlink" title="1.idea文件结构如图"></a>1.idea文件结构如图</h5><p><img src="/iamges/%E4%BD%BF%E7%94%A8fastdfs%E4%B8%8A%E4%BC%A0%E8%A7%86%E9%A2%91%E5%B9%B6%E4%BD%BF%E7%94%A8FFmpegFrameGrabberFrameGrabber%E5%9C%A8%E4%B8%8A%E4%BC%A0%E8%A7%86%E9%A2%91%E6%97%B6%E6%88%AA%E5%9B%BE%E4%BD%9C%E4%B8%BA%E5%B0%81%E9%9D%A2/2.png" alt="img"></p><h5 id="2-在idea新建springboot项目，导入相关依赖"><a href="#2-在idea新建springboot项目，导入相关依赖" class="headerlink" title="2.在idea新建springboot项目，导入相关依赖"></a>2.在idea新建springboot项目，导入相关依赖</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;</span><br><span class="line">                &lt;/exclusion&gt;</span><br><span class="line">            &lt;/exclusions&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--fastdfs依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;net.oschina.zcx7878&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;fastdfs-client-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.27.0.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.1.1&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">&lt;!-- 上传视频截图依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.bytedeco&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;javacv&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;0.8&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">         &lt;!--file转化为MultipartFile file的依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;httpcore&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.4.9&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.6.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="3-往resources中添加一个fastdfs的配置文件fastdfs-client-properties"><a href="#3-往resources中添加一个fastdfs的配置文件fastdfs-client-properties" class="headerlink" title="3.往resources中添加一个fastdfs的配置文件fastdfs-client.properties"></a>3.往resources中添加一个fastdfs的配置文件fastdfs-client.properties</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">## fastdfs-client.properties</span><br><span class="line"></span><br><span class="line">fastdfs.connect_timeout_in_seconds = 5</span><br><span class="line">fastdfs.network_timeout_in_seconds = 30</span><br><span class="line"></span><br><span class="line">fastdfs.charset = UTF-8</span><br><span class="line"></span><br><span class="line">fastdfs.http_anti_steal_token = false</span><br><span class="line">fastdfs.http_secret_key = FastDFS1234567890</span><br><span class="line">fastdfs.http_tracker_http_port = 80</span><br><span class="line"></span><br><span class="line">#你服务器的地址</span><br><span class="line">fastdfs.tracker_servers = xx.xx.xx.xx:22122</span><br><span class="line"></span><br><span class="line">## Whether to open the connection pool, if not, create a new connection every time</span><br><span class="line">fastdfs.connection_pool.enabled = true</span><br><span class="line"></span><br><span class="line">## max_count_per_entry: max connection count per host:port , 0 is not limit</span><br><span class="line">fastdfs.connection_pool.max_count_per_entry = 500</span><br><span class="line"></span><br><span class="line">## connections whose the idle time exceeds this time will be closed, unit: second, default value is 3600</span><br><span class="line">fastdfs.connection_pool.max_idle_time = 3600</span><br><span class="line"></span><br><span class="line">## Maximum waiting time when the maximum number of connections is reached, unit: millisecond, default value is 1000</span><br><span class="line">fastdfs.connection_pool.max_wait_time_in_ms = 1000</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="4-application-yml"><a href="#4-application-yml" class="headerlink" title="4.application.yml"></a>4.application.yml</h5><p><img src="/iamges/%E4%BD%BF%E7%94%A8fastdfs%E4%B8%8A%E4%BC%A0%E8%A7%86%E9%A2%91%E5%B9%B6%E4%BD%BF%E7%94%A8FFmpegFrameGrabberFrameGrabber%E5%9C%A8%E4%B8%8A%E4%BC%A0%E8%A7%86%E9%A2%91%E6%97%B6%E6%88%AA%E5%9B%BE%E4%BD%9C%E4%B8%BA%E5%B0%81%E9%9D%A2/3.png" alt="img"></p><h5 id="5-编写FastDFSVideoUtils工具类"><a href="#5-编写FastDFSVideoUtils工具类" class="headerlink" title="5.编写FastDFSVideoUtils工具类"></a>5.编写FastDFSVideoUtils工具类</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import org.csource.common.MyException;</span><br><span class="line">import org.csource.fastdfs.*;</span><br><span class="line">import org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class FastDFSVideoUtils &#123;</span><br><span class="line">    private static StorageClient1 client1;</span><br><span class="line"></span><br><span class="line">    private static StorageServer storeStorage;</span><br><span class="line"></span><br><span class="line">    private static StorageServer storageServer;</span><br><span class="line"></span><br><span class="line">    static&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ClientGlobal.initByProperties(&quot;fastdfs-client.properties&quot;);</span><br><span class="line">            TrackerClient trackerClient = new TrackerClient();</span><br><span class="line">            TrackerServer trackerServer = trackerClient.getConnection();</span><br><span class="line">            storeStorage = trackerClient.getStoreStorage(trackerServer);</span><br><span class="line">            String storageIp = storeStorage.getSocket().getInetAddress().getHostAddress();</span><br><span class="line">            Integer port = storeStorage.getSocket().getPort();</span><br><span class="line">            //0表示上传到图片目录，1表示上传到视频目录</span><br><span class="line">            storageServer = new StorageServer(storageIp, port, 1);</span><br><span class="line">            client1 = new StorageClient1(trackerServer, storageServer);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (MyException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String upload(MultipartFile file)&#123;</span><br><span class="line">        String oldName = file.getOriginalFilename();</span><br><span class="line">        try &#123;</span><br><span class="line">            return client1.upload_file1(file.getBytes(), oldName.substring(oldName.lastIndexOf(&quot;.&quot;)+1),null);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (MyException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还有截图工具类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import java.awt.Image;</span><br><span class="line">import java.awt.image.BufferedImage;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.util.UUID;</span><br><span class="line"></span><br><span class="line">import javax.imageio.ImageIO;</span><br><span class="line"></span><br><span class="line">import org.bytedeco.javacpp.opencv_core.IplImage;</span><br><span class="line">import org.bytedeco.javacv.FFmpegFrameGrabber;</span><br><span class="line">import org.bytedeco.javacv.Frame;</span><br><span class="line">import org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line">public class ScreenshotUtils &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取指定视频的帧并保存为图片至指定目录</span><br><span class="line">     * @param videourl  源视频文件路径</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static String fetchFrame(String videourl,MultipartFile file)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line">        //获取当前系统时间，类似new Date()，效率比较好</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        //储存截图的文件</span><br><span class="line">        //window下用\\,电脑要有D盘，不然换成你想要的盘</span><br><span class="line">        File targetFile = new File(&quot;D:\\video\\cutpic&quot;);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        if(!targetFile.exists())&#123;</span><br><span class="line">            targetFile.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String filename = file.getOriginalFilename();</span><br><span class="line">        String filenamePrefix = filename.substring(0, filename.lastIndexOf(&quot;.&quot;));</span><br><span class="line">        //创建储存截图的图片文件路径</span><br><span class="line">        //window下用\\</span><br><span class="line">        String coverimgPath = targetFile.getPath()+ &quot;\\&quot; + UUID.randomUUID().toString()+filenamePrefix + &quot;.jpg&quot;;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        File cutpic = new File(coverimgPath);</span><br><span class="line"></span><br><span class="line">        //FFmpegFrameGrabb读取时间随机截图类</span><br><span class="line">        FFmpegFrameGrabber ff = new FFmpegFrameGrabber(videourl);</span><br><span class="line">        ff.start();</span><br><span class="line">        // 表示视频的总图片数量</span><br><span class="line">        int lenght = ff.getLengthInFrames();</span><br><span class="line">        int i = 0;</span><br><span class="line">        Frame f = null;</span><br><span class="line">        while (i &lt; lenght) &#123;</span><br><span class="line">            // 过滤前5帧，避免出现全黑的图片，依自己情况而定</span><br><span class="line">            f = ff.grabFrame();</span><br><span class="line">            if ((i &gt; 5) &amp;&amp; (f.image != null)) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        IplImage img = f.image;</span><br><span class="line">        int owidth = img.width();</span><br><span class="line">        int oheight = img.height();</span><br><span class="line">        // 对截取的帧进行等比例缩放</span><br><span class="line">        int width = 800;</span><br><span class="line">        int height = (int) (((double) width / owidth) * oheight);</span><br><span class="line">        BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR);</span><br><span class="line">        bi.getGraphics().drawImage(f.image.getBufferedImage().getScaledInstance(width, height, Image.SCALE_SMOOTH),</span><br><span class="line">                0, 0, null);</span><br><span class="line">        ImageIO.write(bi, &quot;jpg&quot;, cutpic);</span><br><span class="line">        //ff.flush();</span><br><span class="line">        ff.stop();</span><br><span class="line">        System.out.println(System.currentTimeMillis() - start);</span><br><span class="line">        return coverimgPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-编写mapper文件和mapper-xml"><a href="#6-编写mapper文件和mapper-xml" class="headerlink" title="6.编写mapper文件和mapper.xml"></a>6.编写mapper文件和mapper.xml</h5><p>这里因为我的mybatis-config.xml有问题，不知道什么错，所以先用注解方式测试，就可以不用xml文件了</p><p><img src="/iamges/%E4%BD%BF%E7%94%A8fastdfs%E4%B8%8A%E4%BC%A0%E8%A7%86%E9%A2%91%E5%B9%B6%E4%BD%BF%E7%94%A8FFmpegFrameGrabberFrameGrabber%E5%9C%A8%E4%B8%8A%E4%BC%A0%E8%A7%86%E9%A2%91%E6%97%B6%E6%88%AA%E5%9B%BE%E4%BD%9C%E4%B8%BA%E5%B0%81%E9%9D%A2/4.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.upload.demo.mapper.VideoSaveMapper&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;insert id=&quot;insertVideoUrl&quot; &gt;</span><br><span class="line">        INSERT INTO video(video_url,user_id,professional_name,image_url,title,create_time,collection_count,thumb_count,visit_count,comment_count)</span><br><span class="line">        VALUES (#&#123;videoUrl&#125;,#&#123;userId&#125;,#&#123;professionalName&#125;,#&#123;imageUrl&#125;,#&#123;title&#125;,#&#123;createTime&#125;,#&#123;collectionCount&#125;,#&#123;thumbCount&#125;,#&#123;visitCount&#125;,#&#123;commentCount&#125;)</span><br><span class="line">     &lt;/insert&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>mybatis-config.xml</p><p><img src="/iamges/%E4%BD%BF%E7%94%A8fastdfs%E4%B8%8A%E4%BC%A0%E8%A7%86%E9%A2%91%E5%B9%B6%E4%BD%BF%E7%94%A8FFmpegFrameGrabberFrameGrabber%E5%9C%A8%E4%B8%8A%E4%BC%A0%E8%A7%86%E9%A2%91%E6%97%B6%E6%88%AA%E5%9B%BE%E4%BD%9C%E4%B8%BA%E5%B0%81%E9%9D%A2/5.png" alt="img"></p><p>数据库我建在了服务器上，要先安装mysql服务在服务器上哦，结构如下，连接数据库的方法请自行百度</p><p><img src="/iamges/%E4%BD%BF%E7%94%A8fastdfs%E4%B8%8A%E4%BC%A0%E8%A7%86%E9%A2%91%E5%B9%B6%E4%BD%BF%E7%94%A8FFmpegFrameGrabberFrameGrabber%E5%9C%A8%E4%B8%8A%E4%BC%A0%E8%A7%86%E9%A2%91%E6%97%B6%E6%88%AA%E5%9B%BE%E4%BD%9C%E4%B8%BA%E5%B0%81%E9%9D%A2/6.png" alt="img"></p><h5 id="7-VideoSaveService和VideoSaveServiceImpl"><a href="#7-VideoSaveService和VideoSaveServiceImpl" class="headerlink" title="7.VideoSaveService和VideoSaveServiceImpl"></a>7.VideoSaveService和VideoSaveServiceImpl</h5><p><img src="/iamges/%E4%BD%BF%E7%94%A8fastdfs%E4%B8%8A%E4%BC%A0%E8%A7%86%E9%A2%91%E5%B9%B6%E4%BD%BF%E7%94%A8FFmpegFrameGrabberFrameGrabber%E5%9C%A8%E4%B8%8A%E4%BC%A0%E8%A7%86%E9%A2%91%E6%97%B6%E6%88%AA%E5%9B%BE%E4%BD%9C%E4%B8%BA%E5%B0%81%E9%9D%A2/7.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">import com.upload.demo.config.FastDFSUtils;</span><br><span class="line">import com.upload.demo.config.FastDFSVideoUtils;</span><br><span class="line">import com.upload.demo.config.ScreenshotUtils;</span><br><span class="line">import com.upload.demo.mapper.VideoSaveMapper;</span><br><span class="line">import com.upload.demo.pojo.VideoSave;</span><br><span class="line">import com.upload.demo.service.VideoSaveService;</span><br><span class="line">import org.apache.http.entity.ContentType;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.mock.web.MockMultipartFile;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line">import org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class VideoSaveServiceImpl implements VideoSaveService &#123;</span><br><span class="line"></span><br><span class="line">    private VideoSaveMapper videoSaveMapper;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    VideoSaveServiceImpl(VideoSaveMapper videoSaveMapper)&#123;</span><br><span class="line">        this.videoSaveMapper = videoSaveMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;fastdfs.nginx.host&#125;&quot;)</span><br><span class="line">    String nginxHost;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Integer insertVideo(MultipartFile file,</span><br><span class="line">                               Integer userId,</span><br><span class="line">                               String professionalName,</span><br><span class="line">                               String title,</span><br><span class="line">                               Integer collectionCount,</span><br><span class="line">                               Integer thumbCount,</span><br><span class="line">                               Integer visitCount,</span><br><span class="line">                               Integer commentCount) throws Exception &#123;</span><br><span class="line">        final String fileId = FastDFSVideoUtils.upload(file);</span><br><span class="line">        String videoUrl = nginxHost + fileId;</span><br><span class="line">        Date date = new Date();</span><br><span class="line">        //HH为24小时制，hh为12小时制</span><br><span class="line">        SimpleDateFormat dateFormat= new SimpleDateFormat(&quot;yyyy-MM-dd :HH:mm:ss&quot;);</span><br><span class="line">        String createTime = dateFormat.format(date);</span><br><span class="line"></span><br><span class="line">        //将截图转化为file对象，再将file对象转化为MockMultipartFile 对象</span><br><span class="line">        String cutpicPath = ScreenshotUtils.fetchFrame(videoUrl, file);</span><br><span class="line">        File cutpic = new File(cutpicPath);</span><br><span class="line">        FileInputStream fileInputStream = new FileInputStream(cutpic);</span><br><span class="line">        MockMultipartFile cutPicFile = new MockMultipartFile(cutpic.getName(),</span><br><span class="line">                cutpic.getName(), ContentType.APPLICATION_OCTET_STREAM.toString(), fileInputStream);</span><br><span class="line"></span><br><span class="line">        //FastDFSUtils将上面转化的MockMultipartFile 对象上传</span><br><span class="line">        final String cutPicfileId = FastDFSVideoUtils.upload(cutPicFile);</span><br><span class="line">        String imageUrl = nginxHost + cutPicfileId;</span><br><span class="line">        return videoSaveMapper.insertVideoUrl(videoUrl,userId,professionalName,imageUrl,title,createTime,collectionCount,thumbCount,visitCount,commentCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="8-VideoUploadController控制器代码"><a href="#8-VideoUploadController控制器代码" class="headerlink" title="8.VideoUploadController控制器代码"></a>8.VideoUploadController控制器代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import com.upload.demo.config.FastDFSUtils;</span><br><span class="line">import com.upload.demo.config.FastDFSVideoUtils;</span><br><span class="line">import com.upload.demo.config.ScreenshotUtils;</span><br><span class="line">import com.upload.demo.service.VideoSaveService;</span><br><span class="line">import org.apache.http.entity.ContentType;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.mock.web.MockMultipartFile;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line">import org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class VideoUploadController &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;fastdfs.nginx.host&#125;&quot;)</span><br><span class="line">    String nginxHost;</span><br><span class="line"></span><br><span class="line">    private VideoSaveService videoSaveService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    VideoUploadController(VideoSaveService videoSaveService)&#123;</span><br><span class="line">        this.videoSaveService = videoSaveService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/uploadVideo&quot;)</span><br><span class="line">    public String UploadVideo(MultipartFile file,</span><br><span class="line">                              @RequestParam(value=&quot;userId&quot;,defaultValue=&quot;1&quot;) Integer userId,</span><br><span class="line">                              @RequestParam(value=&quot;professionalName&quot;,defaultValue=&quot;hhh&quot;) String professionalName,</span><br><span class="line">                              @RequestParam(value=&quot;title&quot;,defaultValue=&quot;123&quot;) String title,</span><br><span class="line">                              @RequestParam(value=&quot;collectionCount&quot;,defaultValue=&quot;0&quot;) Integer collectionCount,</span><br><span class="line">                              @RequestParam(value=&quot;thumbCount&quot;,defaultValue=&quot;0&quot;) Integer thumbCount,</span><br><span class="line">                              @RequestParam(value=&quot;visitCount&quot;,defaultValue=&quot;0&quot;) Integer visitCount,</span><br><span class="line">                              @RequestParam(value=&quot;commentCount&quot;,defaultValue=&quot;0&quot;) Integer commentCount</span><br><span class="line">                              ) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        if(videoSaveService.insertVideo(file,userId,professionalName,title,collectionCount,thumbCount,visitCount,commentCount)==1)&#123;</span><br><span class="line">            return &quot;/success&quot;;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return &quot;/false&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="前端部分"><a href="#前端部分" class="headerlink" title="前端部分"></a>前端部分</h4><p>都要放在template文件夹下，控制器要有一个跳转到index.html下的方法，return就行，很简单。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;Content-type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt;</span><br><span class="line">  &lt;title&gt;单文件上传&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form method=&quot;post&quot; action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;&lt;br&gt;</span><br><span class="line">  &lt;input type=&quot;submit&quot; value=&quot;上传头像&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;form method=&quot;post&quot; action=&quot;/uploadVideo&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;&lt;br&gt;</span><br><span class="line">  &lt;input type=&quot;submit&quot; value=&quot;上传视频&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>成功跳转到succes.html，失败跳转false.html</p><p><img src="/iamges/%E4%BD%BF%E7%94%A8fastdfs%E4%B8%8A%E4%BC%A0%E8%A7%86%E9%A2%91%E5%B9%B6%E4%BD%BF%E7%94%A8FFmpegFrameGrabberFrameGrabber%E5%9C%A8%E4%B8%8A%E4%BC%A0%E8%A7%86%E9%A2%91%E6%97%B6%E6%88%AA%E5%9B%BE%E4%BD%9C%E4%B8%BA%E5%B0%81%E9%9D%A2/8.png" alt="img"></p><p>运行截图：</p><p><img src="/iamges/%E4%BD%BF%E7%94%A8fastdfs%E4%B8%8A%E4%BC%A0%E8%A7%86%E9%A2%91%E5%B9%B6%E4%BD%BF%E7%94%A8FFmpegFrameGrabberFrameGrabber%E5%9C%A8%E4%B8%8A%E4%BC%A0%E8%A7%86%E9%A2%91%E6%97%B6%E6%88%AA%E5%9B%BE%E4%BD%9C%E4%B8%BA%E5%B0%81%E9%9D%A2/9.png" alt="img"></p><p><img src="/iamges/%E4%BD%BF%E7%94%A8fastdfs%E4%B8%8A%E4%BC%A0%E8%A7%86%E9%A2%91%E5%B9%B6%E4%BD%BF%E7%94%A8FFmpegFrameGrabberFrameGrabber%E5%9C%A8%E4%B8%8A%E4%BC%A0%E8%A7%86%E9%A2%91%E6%97%B6%E6%88%AA%E5%9B%BE%E4%BD%9C%E4%B8%BA%E5%B0%81%E9%9D%A2/10.png" alt="img"></p><p>将url在浏览器打开</p><p>视频</p><p><img src="/iamges/%E4%BD%BF%E7%94%A8fastdfs%E4%B8%8A%E4%BC%A0%E8%A7%86%E9%A2%91%E5%B9%B6%E4%BD%BF%E7%94%A8FFmpegFrameGrabberFrameGrabber%E5%9C%A8%E4%B8%8A%E4%BC%A0%E8%A7%86%E9%A2%91%E6%97%B6%E6%88%AA%E5%9B%BE%E4%BD%9C%E4%B8%BA%E5%B0%81%E9%9D%A2/11.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具类使用 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
